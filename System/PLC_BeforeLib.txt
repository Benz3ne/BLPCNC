local inst = mc.mcGetInstance()
local rc = 0

-- Sentinel value for invalid/uninitialized pound variables
local SENTINEL_VALUE = -999999

-- Safe pound variable getter with sentinel handling
local function getPV(n, default)
    local v = mc.mcCntlGetPoundVar(inst, n)
    if v == nil or v <= -1e307 then 
        return default or SENTINEL_VALUE 
    end
    return v
end

-- Safe numeric conversion helper
local function num(v, default)
    v = tonumber(v)
    if v == nil or v ~= v then -- NaN check (v~=v)
        return default or 0
    end
    return v
end

-- Get machine enabled state properly
local machEnabledHandle = _G.handleCache and _G.handleCache.machEnabled or mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
local machEnabled = 0
if machEnabledHandle and machEnabledHandle > 0 then
    machEnabled = mc.mcSignalGetState(machEnabledHandle)
end

-- Get machine state
local machState, rc = mc.mcCntlGetState(inst)
local inCycle = mc.mcCntlIsInCycle(inst)

-- Initialize tracking variables for end of script
local machStateOld = machState
local machWasEnabled = machEnabled

-- Get current tool
local currentTool = mc.mcToolGetCurrent(inst)

local STATE_IDLE = 0        -- Machine idle (CONFIRMED)
local STATE_FRUN = 100      -- Feed running (CONFIRMED)
local STATE_FHOLD = 101     -- Feed hold (CONFIRMED)
local STATE_PHOLD = 102     -- Probe hold during G31 (CONFIRMED)
local STATE_MRUN = 200      -- MDI/Macro running (CONFIRMED)
local STATE_MRUN_FH = 201   -- MDI/Macro feed hold (CONFIRMED)
local STATE_MHOLD = 103     -- Alternate hold state (probable)
local STATE_HOLD_SYNC = 110 -- Hold sync state (probable)
local STATE_STOP = 109      -- Stop state (probable)

-- PRODUCTION MODE CONTROL - Set to false for debugging
-- Can also be controlled via pound variable #4990 (1=debug, 0=production)
local debugPV = getPV(4990, 0)
_G.PRODUCTION_MODE = (debugPV ~= 1)  -- Debug enabled if #4990 == 1

-- Debug print function that respects production mode
local function debugPrint(tag, message)
    if not _G.PRODUCTION_MODE then
        if message then
            mc.mcCntlSetLastError(inst, string.format("[%s] %s", tag, message))
        else
            -- Single argument - no tag
            mc.mcCntlSetLastError(inst, tostring(tag))
        end
    end
end

-- Shorter alias for debug
local function dbg(tag, msg)
    debugPrint(tag, msg)
end

-- Simple debug counter if needed
if not _G.dustDebug then
    _G.dustDebug = { 
        cycleCount = 0  -- Keep only essential counter
    }
end

-- Increment cycle counter
_G.dustDebug.cycleCount = _G.dustDebug.cycleCount + 1



-------------------------------------------------------
--  Set plate align (G68) Led
-------------------------------------------------------
local curLedState = math.tointeger(scr.GetProperty("ledPlateAlign", "Value"))
local curAlignState = math.tointeger((mc.mcCntlGetPoundVar(inst, 4016) - 69))
curAlignState = math.abs(curAlignState)
if (curLedState ~= curAlignState) then
	scr.SetProperty("ledPlateAlign", "Value", tostring(curAlignState))
end

-------------------------------------------------------
--  Coroutine resume
-------------------------------------------------------
if (wait ~= nil) and (machState == 0) then
    local state = coroutine.status(wait)
    if state == "suspended" then
        coroutine.resume(wait)
    end
end

-------------------------------------------------------
--  Cycle time label update
-------------------------------------------------------
if (machEnabled == 1) then
	local cycletime = mc.mcCntlGetRunTime(inst)
	local timeStr = SystemLib and SystemLib.Display and SystemLib.Display.SecondsToTime 
		and SystemLib.Display.SecondsToTime(cycletime) 
		or string.format("%02d:%02d:%05.2f", 
			math.floor(cycletime/3600), 
			math.floor((cycletime%3600)/60), 
			cycletime%60)
	scr.SetProperty("CycleTime", "Label", timeStr)
end

-------------------------------------------------------
--  Set Height Offset Led and Monitor H Sync
-------------------------------------------------------
local HOState = mc.mcCntlGetPoundVar(inst, 4008)
local activeH = mc.mcCntlGetPoundVar(inst, 4120)

-- Update LED
if (HOState == 49) then
    scr.SetProperty("ledHOffset", "Value", "0")
else
    scr.SetProperty("ledHOffset", "Value", "1")
end

-------------------------------------------------------
--  Set Spindle Ratio DRO
-------------------------------------------------------
local spinmotormax, rangemax, ratio
spinmotormax, rc = scr.GetProperty('droSpinMotorMax', 'Value')
spinmotormax = tonumber(spinmotormax) or 1   
rangemax, rc = scr.GetProperty('droRangeMax', 'Value')
rangemax = tonumber(rangemax) or 1
ratio = (rangemax / spinmotormax)    
scr.SetProperty('droRatio', 'Value', tostring(ratio))

-------------------------------------------------------
--  Set Feedback Ratio DRO Updated 5-30-16
-------------------------------------------------------
local range, rc = mc.mcSpindleGetCurrentRange(inst)
local fbratio, rc = mc.mcSpindleGetFeedbackRatio(inst, range)
scr.SetProperty('droFeedbackRatio', 'Value', tostring(fbratio))

-------------------------------------------------------
--  PLC First Run
-------------------------------------------------------
if (testcount == 1) then
    local iReg = mc.mcIoGetHandle (inst, "Keyboard/Enable")
    mc.mcIoSetState(iReg, 0)  -- Disable keyboard inputs on initialization
    KeyboardInputsToggle()
    DecToFrac(0)
    DecToFrac(1)
    DecToFrac(2)
	
    DROTable = {
	[1034] = "droEdgeFinder",
    [1035] = "droGageBlock",
    [1036] = "droGageBlockT"
    }

    for name,number in pairs (DROTable) do
        local droName = (DROTable[name])
        local val = mc.mcProfileGetString(inst, "PersistentDROs", (droName), "NotFound")
        if(val ~= "NotFound")then
            scr.SetProperty((droName), "Value", val)
        end
    end
end

-- Initialize persistent globals on first run
if not _G.toolPLCInit then
    _G.toolPLCInit = true
    _G.lastTool = -999
	_G.lastSyncedTool = -999
    _G.lastPollTime = os.clock()
    _G.debounceStart = nil
    _G.debouncing = false
    _G.enablePromptDone = false
    _G.toolPresentHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    
    if not _G.toolPresentHandle or _G.toolPresentHandle <= 0 then
        mc.mcCntlSetLastError(inst, "ERROR: Invalid handle for Input #17 (Tool Present)")
        _G.toolPresentHandle = nil
    end
    
    mc.mcToolSetCurrent(inst, 0)
end

-- Cache signal handles for performance (avoid repeated lookups)
if not _G.signalHandlesInit then
    _G.signalHandlesInit = true
    _G.handleCache = {
        machEnabled = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED),
        output1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1),
        output2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2),
        output3 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3),
        output4 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT4),
        output5 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT5),
        output6 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6),
        output7 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7),
        input6 = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT6),
        input8 = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT8),
        input17 = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    }
end

-- Non-blocking tool prompt request - sets flags for ScreenLoad to handle
local function requestToolPrompt(isStartup)
    local virtualToolActive = mc.mcCntlGetPoundVar(inst, 406) >= 90
    local suppressPrompt = mc.mcCntlGetPoundVar(inst, 498) == 1
	
    if not _G.toolChoices or not _G.toolNumbers then
        mc.mcCntlSetLastError(inst, "ERROR: Tool configuration not loaded")
        mc.mcToolSetCurrent(inst, 0)
        return
    end

    if virtualToolActive or suppressPrompt then
        return
    end
    
    -- Just set flags for ScreenLoad timer to detect and handle
    _G.needToolPrompt = true
    _G.toolPromptIsStartup = isStartup
    _G.toolPromptRequestTime = os.clock()
end

-- Legacy function name for compatibility
local promptToolSelection = requestToolPrompt

-- Check for enable condition
if machEnabled == 1 and not _G.enablePromptDone and _G.toolPresentHandle then
    local toolPresent = mc.mcSignalGetState(_G.toolPresentHandle)
    
    local m6Running = mc.mcCntlGetPoundVar(inst, 499) == 1
    local suppressPrompt = mc.mcCntlGetPoundVar(inst, 498) == 1
    
    if toolPresent == 1 and currentTool == 0 and not suppressPrompt and currentTool < 90 then
        promptToolSelection(true)
    end
    _G.enablePromptDone = true
elseif machEnabled == 0 then
    _G.enablePromptDone = false
end

-- Monitor current tool and sync dropdown
currentTool = mc.mcToolGetCurrent(inst)
if currentTool ~= _G.lastTool then
    local toolChangeTime = os.clock()
    _G.lastTool = currentTool
	
    local machState = mc.mcCntlGetState(inst)
    local m6Running = mc.mcCntlGetPoundVar(inst, 499) == 1
    
    local timeSinceLastSync = toolChangeTime - (_G.hOffsetLastSync or 0)
    
    if machState == 0 and timeSinceLastSync > 1.0 then
        local currentH = mc.mcCntlGetPoundVar(inst, 4120)
        local compMode = mc.mcCntlGetPoundVar(inst, 4008)
        
        local needsSync = false
        if currentTool == 0 and compMode == 43 then
            needsSync = true
        elseif currentTool > 0 and (compMode == 49 or currentH ~= currentTool) then
            needsSync = true
        end
        
        if needsSync then
            mc.mcCntlGcodeExecuteWait(inst, "G49")
            if currentTool > 0 then
                mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", currentTool))
            end
            _G.hOffsetLastSync = os.clock()
        end
    end
    
    if not _G.selectedToolIndex then
        local index = -1
        if _G.toolNumbers then
            for i, t in ipairs(_G.toolNumbers) do
                if t == currentTool then
                    index = i - 1
                    break
                end
            end
        end
        
        if index >= 0 then
            scr.SetProperty("lstCurrentTool", "Value", tostring(index))
        else
            scr.SetProperty("lstCurrentTool", "Value", "0")
        end
        
        if UpdateToolPreview then
            UpdateToolPreview()
        end
    end
end






-- Initialize button state tracking if needed
if not _G.dustButtonStates then
    _G.dustButtonStates = {
        boot = -1,
        collect = -1,
        vacRear = -1,
        vacFront = -1
    }
end

-- Optimized button update function - only updates on state change
local function UpdateAllDustButtons()
    -- Dust Boot
    local bootHandle = _G.handleCache and _G.handleCache.output3 or mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
    if bootHandle and bootHandle > 0 then
        local bootState = mc.mcSignalGetState(bootHandle)
        if bootState ~= _G.dustButtonStates.boot then
            scr.SetProperty("btnDustBoot", "Bg Color", bootState == 1 and "#00FF00" or "#FF0000")
            scr.SetProperty("btnDustBoot", "Label", bootState == 1 and "Dust Boot\nDOWN" or "Dust Boot\nUP")
            _G.dustButtonStates.boot = bootState
        end
    end
    
    -- Dust Collection
    local dustHandle = _G.handleCache and _G.handleCache.output4 or mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT4)
    if dustHandle and dustHandle > 0 then
        local dustState = mc.mcSignalGetState(dustHandle)
        if dustState ~= _G.dustButtonStates.collect then
            scr.SetProperty("btnDustCollect", "Bg Color", dustState == 1 and "#00FF00" or "#FF0000")
            scr.SetProperty("btnDustCollect", "Label", dustState == 1 and "Dust Collect\nON" or "Dust Collect\nOFF")
            _G.dustButtonStates.collect = dustState
        end
    end
    
    -- Rear Vacuum (OUTPUT5)
    local vacRearHandle = _G.handleCache and _G.handleCache.output5 or mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT5)
    if vacRearHandle and vacRearHandle > 0 then
        local vacRearState = mc.mcSignalGetState(vacRearHandle)
        if vacRearState ~= _G.dustButtonStates.vacRear then
            scr.SetProperty("btnVacuumRear", "Bg Color", vacRearState == 1 and "#00FF00" or "#FF0000")
            scr.SetProperty("btnVacuumRear", "Label", vacRearState == 1 and "Rear Vacuum\nON" or "Rear Vacuum\nOFF")
            _G.dustButtonStates.vacRear = vacRearState
        end
    end
    
    -- Front Vacuum (OUTPUT6)
    local vacFrontHandle = _G.handleCache and _G.handleCache.output6 or mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
    if vacFrontHandle and vacFrontHandle > 0 then
        local vacFrontState = mc.mcSignalGetState(vacFrontHandle)
        if vacFrontState ~= _G.dustButtonStates.vacFront then
            scr.SetProperty("btnVacuumFront", "Bg Color", vacFrontState == 1 and "#00FF00" or "#FF0000")
            scr.SetProperty("btnVacuumFront", "Label", vacFrontState == 1 and "Front Vacuum\nON" or "Front Vacuum\nOFF")
            _G.dustButtonStates.vacFront = vacFrontState
        end
    end
end

-- Unified dust/boot control (single source of truth)
if dustLib then
    dustLib.init(inst)     -- idempotent; safe per tick
    dustLib.update(inst)   -- compute policy + write OUTPUT3/4
end

-- Unified tool control (single source of truth)
if ToolLib then
    ToolLib.init(inst)     -- idempotent; safe per tick
    ToolLib.update(inst)   -- handles OUTPUT1/2/7 and state
end

-- Update button display (library doesn't handle UI)
UpdateAllDustButtons()





-- ===== HOMING INDICATOR AND WARNING RESET =====
do
    local inst = mc.mcGetInstance()
    
    if _G.lastHomingFlashState == nil then
        _G.lastHomingFlashState = nil
        _G.lastHomedState = nil
        _G.AXES_HOMED = false
    end
    
    local allHomed = true
    local unhomedAxes = {}
    
    for axis = 0, 5 do
        local enabledOk, enabled = pcall(mc.mcAxisIsEnabled, inst, axis)
        local homedOk, homed = pcall(mc.mcAxisIsHomed, inst, axis)
        
        if enabledOk and homedOk then
            if enabled == 1 and homed ~= 1 then
                allHomed = false
                table.insert(unhomedAxes, axis)
            end
        end
    end
    
    local flashOn = (math.floor(testcount / 6) % 2) == 0
    
    if not allHomed then
        if _G.lastHomingFlashState ~= flashOn or _G.lastHomedState ~= allHomed then
            local color = flashOn and "#FFFF00" or "#4B4B4B"
            
            pcall(scr.SetProperty, "btnRefAllAxes", "Bg Color", color)
            pcall(scr.SetProperty, "btnRefAllAxes", "Fg Color", "#000000")
            pcall(scr.SetProperty, "btnRefAllAxes", "Label", "HOME\nREQUIRED")
            
            _G.lastHomingFlashState = flashOn
        end
    else
        if _G.lastHomedState == false or _G.lastHomedState == nil then
            pcall(scr.SetProperty, "btnRefAllAxes", "Bg Color", "#4B4B4B")
            pcall(scr.SetProperty, "btnRefAllAxes", "Fg Color", "#FFFFFF")
            pcall(scr.SetProperty, "btnRefAllAxes", "Label", "Ref All\nAxis")
        end
        
        if _G.HOMING_WARNING_IGNORED then
            _G.HOMING_WARNING_IGNORED = false
        end
    end
    
    _G.lastHomedState = allHomed
    _G.AXES_HOMED = allHomed
end

-- Work Offset Monitoring Section
if not _G.lastWorkOffset then
    _G.lastWorkOffset = -1
end

if not _G.tabMonitor then
    _G.tabMonitor = {
        lastTab = -1,
        checkCounter = 0,
        checkInterval = 5,
        needsRefresh = false
    }
end

local currentOffset = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14 or 5220)

if currentOffset ~= _G.lastWorkOffset then
    if UpdateWorkOffsetButtons then
        UpdateWorkOffsetButtons()
    end
    
    if _G.lastWorkOffset ~= -1 then
        if currentOffset >= 54 and currentOffset <= 59 then
            mc.mcCntlSetLastError(inst, string.format("Work Offset: G%.0f", currentOffset))
        elseif math.abs(currentOffset - 54.1) < 0.01 then
            local pNumber = mc.mcCntlGetPoundVar(inst, mc.SV_BUFP or 5219)
            mc.mcCntlSetLastError(inst, string.format("WARNING: G54.1 P%d active - not shown in UI", pNumber))
        else
            mc.mcCntlSetLastError(inst, string.format("WARNING: Unknown work offset %.1f", currentOffset))
        end
    end
    
    _G.lastWorkOffset = currentOffset
end

_G.tabMonitor.checkCounter = _G.tabMonitor.checkCounter + 1
if _G.tabMonitor.checkCounter >= _G.tabMonitor.checkInterval then
    _G.tabMonitor.checkCounter = 0
    
    local ok, tabStr = pcall(scr.GetProperty, "MainTabs", "Current Tab")
    if ok and tabStr then
        local currentTab = tonumber(tabStr) or -1
        
        if currentTab ~= _G.tabMonitor.lastTab and currentTab >= 0 then
            _G.tabMonitor.needsRefresh = true
            _G.tabMonitor.lastTab = currentTab
        end
    end
end

if _G.tabMonitor.needsRefresh then
    _G.tabMonitor.needsRefresh = false
    
    if UpdateWorkOffsetButtons then
        UpdateWorkOffsetButtons()
    end
    
    if SyncSoftLimitsButton then
        SyncSoftLimitsButton()
    end
    
    if SyncDustButtons then
        SyncDustButtons()
    end
end

-- SOFT LIMITS STATE MONITORING
if not _G.softLimitsInit then
    _G.softLimitsInit = true
    _G.lastSoftLimitsState = nil
end

local function getActualSoftLimitsEnabled()
    for axis = 0, 5 do
        if mc.mcAxisIsEnabled(inst, axis) == 1 then
            local state = mc.mcSoftLimitGetState(inst, axis)
            if state and state == 1 then
                return 1
            end
        end
    end
    return 0
end

local softLimitsEnabled = getActualSoftLimitsEnabled()

if softLimitsEnabled ~= _G.lastSoftLimitsState then
    if softLimitsEnabled == 1 then
        scr.SetProperty("btnSoftLimits", "Bg Color", "#00FF00")
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nENABLED")
        
        if _G.lastSoftLimitsState ~= nil then
            mc.mcCntlSetLastError(inst, "Soft limits ENABLED")
        end
    else
        scr.SetProperty("btnSoftLimits", "Bg Color", "#FF0000")
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nDISABLED")
        
        if _G.lastSoftLimitsState ~= nil then
            mc.mcCntlSetLastError(inst, "WARNING: Soft limits DISABLED")
        end
    end
    
    _G.lastSoftLimitsState = softLimitsEnabled
end

-- TOUCH PROBE BUTTON STATE MONITORING
if not _G.lastProbeOutputState then 
    _G.lastProbeOutputState = -1 
end

local output7Handle = _G.handleCache and _G.handleCache.output7 or mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
if output7Handle and output7Handle > 0 then
    local probeActive = mc.mcSignalGetState(output7Handle)
    
    if probeActive ~= _G.lastProbeOutputState then
        if probeActive == 1 then
            scr.SetProperty("btnTouchProbe", "Bg Color", "#00FF00")
            scr.SetProperty("btnTouchProbe", "Label", "Deactivate Probe\nChange to T0")
        else
            scr.SetProperty("btnTouchProbe", "Bg Color", "#FF0000")
            scr.SetProperty("btnTouchProbe", "Label", "Activate Probe\nChange to T90")
        end
        _G.lastProbeOutputState = probeActive
    end
end

-- LASER DEPLOY BUTTON STATE MONITORING (LaserDown button - T91 tool control)
if not _G.lastLaserOutputState then 
    _G.lastLaserOutputState = -1 
end

local output1Handle = _G.handleCache and _G.handleCache.output1 or mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
if output1Handle and output1Handle > 0 then
    local laserActive = mc.mcSignalGetState(output1Handle)
    
    if laserActive ~= _G.lastLaserOutputState then
        if laserActive == 1 then
            scr.SetProperty("btnLaserDown", "Bg Color", "#00FF00")
            scr.SetProperty("btnLaserDown", "Label", "Retract Laser\nChange to T0")
        else
            scr.SetProperty("btnLaserDown", "Bg Color", "#FF0000")
            scr.SetProperty("btnLaserDown", "Label", "Deploy Laser\nChange to T91")
        end
        _G.lastLaserOutputState = laserActive
    end
end

-- ACTIVATE LASER BUTTON STATE MONITORING (ESS test mode activation)
if not _G.lastActivateLaserState then 
    _G.lastActivateLaserState = -1 
end

-- Monitor ESS laser test mode activation state
local success, hregActivate = pcall(mc.mcRegGetHandle, inst, "ESS/Laser/Test_Mode_Activate")
if success and hregActivate then
    local activateLaserActive = mc.mcRegGetValue(hregActivate) or 0
    
    if activateLaserActive ~= _G.lastActivateLaserState then
        if activateLaserActive == 1 then
            scr.SetProperty("btnActivateLaser", "Bg Color", "#00FF00")
            scr.SetProperty("btnActivateLaser", "Label", "Laser ON\nClick to turn OFF")
        else
            scr.SetProperty("btnActivateLaser", "Bg Color", "#FF0000")
            scr.SetProperty("btnActivateLaser", "Label", "Activate Laser\nClick to turn ON")
        end
        _G.lastActivateLaserState = activateLaserActive
    end
end

-- Input 8 to Output 2 Mirroring and Tool Detection
if not _G.lastInput8State then 
    _G.lastInput8State = -1 
    _G.toolCheckPending = false
    _G.toolCheckTime = 0
    _G.toolCheckStartTime = nil
    _G.lastToolSensorState = -1
    _G.toolSettleNeeded = false
    _G.toolSettleTime = 0
end

local input8Handle = _G.handleCache and _G.handleCache.input8 or mc.mcSignalGetHandle(inst, mc.ISIG_INPUT8)
if input8Handle and input8Handle > 0 then
    local input8State = mc.mcSignalGetState(input8Handle)
    
    -- CHECK IF M6 IS RUNNING FIRST!
    local m6Running = mc.mcCntlGetPoundVar(inst, 499)
    
    -- Only mirror if M6 is NOT running
    if m6Running ~= 1 then
        -- ToolLib now handles OUTPUT2 writes with proper protection
        -- Keeping the handle check for future use
        local out2Handle = _G.handleCache and _G.handleCache.output2 or mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
    end
    
    -- Rest of the code for detecting button release...
    if input8State ~= _G.lastInput8State then
        if input8State == 0 and _G.lastInput8State == 1 then
            _G.toolCheckPending = true
            _G.toolCheckTime = os.clock() + 1.0
        end
        _G.lastInput8State = input8State
    end
end

-- Handle pending tool check after delay
if _G.toolCheckPending and os.clock() >= _G.toolCheckTime then
    
    if not _G.toolCheckStartTime then
        _G.toolCheckStartTime = os.clock()
    end
    
    if os.clock() - _G.toolCheckStartTime > 30 then
        mc.mcCntlSetLastError(inst, "Tool check cancelled - machine stayed busy for 30 seconds")
        _G.toolCheckPending = false
        _G.toolCheckStartTime = nil
        local handle17 = _G.handleCache and _G.handleCache.input17 or mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
        _G.lastToolSensorState = mc.mcSignalGetState(handle17)
        return
    end
    
    local machState = mc.mcCntlGetState(inst)
    local inCycle = mc.mcCntlIsInCycle(inst)
    
    local inMacro = (machState == mc.MC_STATE_MRUN_MACRO) or 
                    (machState == mc.MC_STATE_MRUN_MACRO_HOLD) or
                    (machState == mc.MC_STATE_MRUN_MACROH)
    
    if machState ~= 0 or inCycle == 1 then
        _G.toolCheckPending = true
        _G.toolCheckTime = os.clock() + 1.0
        return
    end
    
    _G.toolCheckPending = false
    _G.toolCheckStartTime = nil
    
    -- Set flag to wait for signal settling (non-blocking)
    _G.toolSettleNeeded = true
    _G.toolSettleTime = os.clock() + 0.05  -- 50ms delay
    return
end

-- Handle tool signal settling delay (non-blocking replacement for wxMilliSleep)
if _G.toolSettleNeeded and os.clock() >= _G.toolSettleTime then
    _G.toolSettleNeeded = false
    
    local toolPresentHandle = _G.handleCache and _G.handleCache.input17 or mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    if not toolPresentHandle or toolPresentHandle <= 0 then
        return
    end
    
    local toolPresent = mc.mcSignalGetState(toolPresentHandle)
    local currentTool = mc.mcToolGetCurrent(inst)
    
    -- TOOL INSERTION: Sensor goes from 0 to 1
    if toolPresent == 1 and (_G.lastToolSensorState == 0 or _G.lastToolSensorState == -1) then
        
        local virtualToolActive = mc.mcCntlGetPoundVar(inst, 406) >= 90
        
        if virtualToolActive then
            if RetractVirtualTool then
                RetractVirtualTool()
                mc.mcCntlSetLastError(inst, "Virtual tool retracted for manual change")
            else
                mc.mcCntlSetLastError(inst, "ERROR: RetractVirtualTool function not found!")
            end
            currentTool = mc.mcToolGetCurrent(inst)
        end
        
        promptToolSelection(false)
        
    -- TOOL REMOVAL: Sensor goes from 1 to 0
    elseif toolPresent == 0 and _G.lastToolSensorState == 1 then
        -- Tool was removed - set to T0
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")  -- Cancel height offset
        
        -- Update tool preview if function exists
        if UpdateToolPreview then
            UpdateToolPreview()
        end
        
        mc.mcCntlSetLastError(inst, "Tool removed - T0 set")
        
        -- Force tool dropdown to update
        _G.lastTool = 0  -- Force PLC tool monitoring to see the change
    end
    
    _G.lastToolSensorState = toolPresent
end

-- LOW AIR PRESSURE MONITORING
if not _G.lowAirInit then
    _G.lowAirInit = true
    _G.lastLowAirState = -1
    _G.lowAirDisabled = false
    _G.lowAirDialogShown = false
    _G.lowAirDebounceCount = 0
    _G.restoredDialogShown = false
end

local lowAirHandle = _G.handleCache and _G.handleCache.input6 or mc.mcSignalGetHandle(inst, mc.ISIG_INPUT6)

if lowAirHandle and lowAirHandle > 0 then
    local rawAirState = mc.mcSignalGetState(lowAirHandle)
    
    if rawAirState ~= _G.lastLowAirState then
        _G.lowAirDebounceCount = _G.lowAirDebounceCount + 1
        
        if _G.lowAirDebounceCount < 3 then
            return
        end
        
        _G.lowAirDebounceCount = 0
        
        if rawAirState == 1 then
            if not _G.lowAirDisabled then
                local machState = mc.mcCntlGetState(inst)
                local inCycle = mc.mcCntlIsInCycle(inst)
                
                if inCycle == 1 then
                    mc.mcCntlFeedHold(inst)
                    
                    local waitCount = 0
                    while mc.mcCntlIsInCycle(inst) == 1 and waitCount < 5 do
                        waitCount = waitCount + 1
                    end
                    
                    mc.mcCntlCycleStop(inst)
                end
                
                local spindleOn = mc.mcSpindleGetCommandRPM(inst) > 0
                if spindleOn then
                    mc.mcSpindleSetDirection(inst, 0)
                end
                
                mc.mcCntlEnable(inst, 0)
                _G.lowAirDisabled = true
                _G.restoredDialogShown = false
                
                mc.mcCntlSetLastError(inst, "*** MACHINE DISABLED: LOW AIR PRESSURE DETECTED ***")
                
                if not _G.lowAirDialogShown then
                    _G.lowAirDialogShown = true
                    
                    -- Set flag for ScreenLoad timer to show dialog
                    _G.needLowAirDialog = true
                    _G.lowAirDialogType = "error"
                    _G.lowAirDialogMessage = "LOW AIR PRESSURE DETECTED!\n\n" ..
                        "Machine has been disabled for safety.\n" ..
                        "1. Check air compressor\n" ..
                        "2. Check for air leaks\n" ..
                        "3. Restore air pressure above minimum\n" ..
                        "4. Re-enable machine when pressure is normal"
                end
            end
            
        else
            if _G.lowAirDisabled then
                mc.mcCntlSetLastError(inst, "Air pressure restored - machine can be re-enabled")
                _G.lowAirDisabled = false
                _G.lowAirDialogShown = false
                
                if not _G.restoredDialogShown then
                    _G.restoredDialogShown = true
                    
                    -- Set flag for ScreenLoad timer to show dialog
                    _G.needLowAirDialog = true
                    _G.lowAirDialogType = "info"
                    _G.lowAirDialogMessage = "Air pressure has been restored.\n\n" ..
                        "Please verify system is safe before re-enabling machine."
                end
            end
        end
        
        _G.lastLowAirState = rawAirState
    else
        _G.lowAirDebounceCount = 0
    end
    
    if rawAirState == 1 then
        local machEnabledHandle = _G.handleCache and _G.handleCache.machEnabled or mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
        if machEnabledHandle and machEnabledHandle > 0 then
            local currentlyEnabled = mc.mcSignalGetState(machEnabledHandle)
            
            if currentlyEnabled == 1 and _G.lowAirDisabled then
                mc.mcCntlEnable(inst, 0)
                mc.mcCntlSetLastError(inst, "*** CANNOT ENABLE: Air pressure still too low! ***")
                
                if testcount % 100 == 0 then
                    mc.mcCntlSetLastError(inst, "*** WARNING: Fix air pressure before enabling! ***")
                end
            end
        end
    end
    
    if testcount % 10 == 0 then
        if scr.GetProperty("btnAirPressure", "Bg Color") ~= nil then
            if rawAirState == 1 then
                scr.SetProperty("btnAirPressure", "Bg Color", "#FF0000")
                scr.SetProperty("btnAirPressure", "Label", "Air Pressure\nLOW!")
            else
                scr.SetProperty("btnAirPressure", "Bg Color", "#00FF00")
                scr.SetProperty("btnAirPressure", "Label", "Air Pressure\nNORMAL")
            end
        end
        
        if scr.GetProperty("ledAirPressure", "Value") ~= nil then
            scr.SetProperty("ledAirPressure", "Value", rawAirState == 1 and "0" or "1")
        end
    end
    
elseif _G.lastLowAirState ~= -2 then
    mc.mcCntlSetLastError(inst, "WARNING: Cannot monitor air pressure - Input 6 not configured")
    _G.lastLowAirState = -2
end





-------------------------------------------------------
-- This is the last thing we do. So keep it at the end of the script!
machStateOld = machState;
machWasEnabled = machEnabled;