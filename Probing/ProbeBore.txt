-- Probe Bore v4.0 - Library Enhanced Edition
-- Finds the center of a bore/hole using 3-point measurement
-- Uses ProbeLib v2.1 enhanced library functions

-- Load libraries
local ProbeLib = require("ProbeLib")
local SystemLib = require("SystemLib")
local UILib = require("UILib")

local inst = ProbeLib.Core.GetInstance()

-- ============================================
-- ROTATION CHECK
-- ============================================
if not ProbeLib.Safety.CheckRotation(inst, "warn") then
    return  -- User cancelled due to rotation
end

-- ============================================
-- TOOL CHECK (using ProbeLib)
-- ============================================
if not ProbeLib.Core.ActivateProbeTool(inst) then
    return  -- User cancelled tool activation
end

-- ============================================
-- PROBE PRECHECK
-- ============================================
if not ProbeLib.Safety.EnsureProbeNotTripped(inst) then
    return  -- Probe is stuck triggered
end

-- ============================================
-- SETTINGS MANAGEMENT (using ProbeLib)
-- ============================================
local settings = SystemLib.Storage.CreateSettings(inst, "ProbeBore", {
    ProbeDepth = 0.25,   -- Depth to probe into bore
    ActionMode = 1,      -- 1=Set Datum, 2=Print Coords
    ProbePoints = 3      -- 3 or 4 point measurement
})

-- Load saved settings
local lastProbeDepth = settings:getFloat("ProbeDepth", 0.25)
local lastActionMode = settings:getInt("ActionMode", 1)
local lastProbePoints = settings:getInt("ProbePoints", 3)

-- ============================================
-- CREATE DIALOG (using UILib resizable dialog)
-- ============================================
local parent = UILib.Msg.GetParent()

-- Create resizable dialog with saved geometry
local dlg, panel, mainSizer = UILib.ResizableDialog.CreateWithPanel(
    parent, "Probe Bore Setup", "ProbeBoreProbe", 380, 420
)

-- Instructions
local instructText = wx.wxStaticText(panel, wx.wxID_ANY,
    "Position the probe inside the bore:\n" ..
    "• Roughly centered in the bore\n" ..
    "• Above the desired measurement depth\n" ..
    "• Probe will measure 3 or 4 points to find center")
instructText:SetFont(UILib.Styles.Fonts.Default)
mainSizer:Add(instructText, 0, wx.wxALL, 10)

-- Measurement Options
local measureBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Measurement Settings")

-- Probe points selection
local pointChoices = {"3-Point Circle", "4-Point (X/Y axes)"}
local pointRadio = UILib.Controls.CreateRadioBox(panel, "Measurement Method", pointChoices, 
    lastProbePoints == 3 and 0 or 1, 2)
measureBox:Add(pointRadio, 0, wx.wxEXPAND + wx.wxALL, 5)

-- Probe depth input
local depthSizer, depthInput = UILib.Controls.CreateNumberInput(panel, "Probe depth into bore:", lastProbeDepth, 80)
measureBox:Add(depthSizer, 0, wx.wxALL + wx.wxEXPAND, 5)

-- Visual representation
local visualPanel = wx.wxPanel(panel, wx.wxID_ANY, wx.wxDefaultPosition, wx.wxSize(150, 150))
visualPanel:SetBackgroundColour(wx.wxColour(240, 240, 240))

-- Draw visual representation
visualPanel:Connect(wx.wxEVT_PAINT, function(event)
    local dc = wx.wxPaintDC(visualPanel)
    local w = visualPanel:GetSize():GetWidth()
    local h = visualPanel:GetSize():GetHeight()
    local centerX, centerY = w/2, h/2
    local radius = 50
    
    -- Draw bore circle
    dc:SetBrush(wx.wxBrush(wx.wxColour(220, 220, 220), wx.wxSOLID))
    dc:SetPen(wx.wxPen(wx.wxColour(100, 100, 100), 2))
    dc:DrawCircle(centerX, centerY, radius)
    
    -- Draw probe points based on selection
    dc:SetBrush(wx.wxBrush(wx.wxColour(255, 0, 0), wx.wxSOLID))
    dc:SetPen(wx.wxPen(wx.wxColour(200, 0, 0), 1))
    
    local numPoints = pointRadio:GetSelection() == 0 and 3 or 4
    
    if numPoints == 3 then
        -- 3-point: 0°, 120°, 240°
        for i = 0, 2 do
            local angle = i * 120 * math.pi / 180
            local px = centerX + radius * 0.8 * math.cos(angle)
            local py = centerY + radius * 0.8 * math.sin(angle)
            dc:DrawCircle(px, py, 4)
        end
    else
        -- 4-point: +X, -X, +Y, -Y
        dc:DrawCircle(centerX + radius * 0.8, centerY, 4)  -- +X
        dc:DrawCircle(centerX - radius * 0.8, centerY, 4)  -- -X
        dc:DrawCircle(centerX, centerY - radius * 0.8, 4)  -- +Y
        dc:DrawCircle(centerX, centerY + radius * 0.8, 4)  -- -Y
    end
    
    -- Draw center point
    dc:SetBrush(wx.wxBrush(wx.wxColour(0, 0, 255), wx.wxSOLID))
    dc:DrawCircle(centerX, centerY, 3)
    
    dc:delete()
end)

measureBox:Add(visualPanel, 0, wx.wxALL + wx.wxALIGN_CENTER, 10)

mainSizer:Add(measureBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Action Options
local actionBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Action")
local actionChoices = {"Set Datum (X=0, Y=0)", "Print Bore Center & Diameter"}
local actionRadio = UILib.Controls.CreateRadioBox(panel, "After Probing", actionChoices, lastActionMode - 1, 1)
actionBox:Add(actionRadio, 0, wx.wxEXPAND + wx.wxALL, 5)
mainSizer:Add(actionBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Update visual when probe points change
pointRadio:Connect(wx.wxID_ANY, wx.wxEVT_COMMAND_RADIOBOX_SELECTED, function(event)
    visualPanel:Refresh()
end)

-- Spacer
mainSizer:AddStretchSpacer()

-- Buttons
local buttonSizer, okBtn, cancelBtn = UILib.Controls.CreateButtonSizer(panel, "OK", "Cancel")
mainSizer:Add(buttonSizer, 0, wx.wxALL + wx.wxALIGN_CENTER, 8)

-- Apply layout
panel:SetSizer(mainSizer)
dlg:Fit()

-- ============================================
-- SHOW DIALOG AND PROCESS
-- ============================================
if dlg:ShowModal() == wx.wxID_OK then
    -- Get values
    local probePoints = pointRadio:GetSelection() == 0 and 3 or 4
    local probeDepth = depthInput:GetNumber(0.25)
    local actionSel = actionRadio:GetSelection() + 1
    
    -- Save settings
    settings:setInt("ProbePoints", probePoints)
    settings:setFloat("ProbeDepth", probeDepth)
    settings:setInt("ActionMode", actionSel)
    
    dlg:Destroy()
    
    -- ============================================
    -- EXECUTE PROBE SEQUENCE
    -- ============================================
    local function ExecuteProbeBore()
        -- Check if probe is already triggered
        if ProbeLib.Core.IsProbeTriggered(inst) then
            UILib.Msg.Error("Probe is already triggered!\n\nPlease clear the probe and try again.", "Probe Error")
            return false
        end
        
        -- Store starting position
        local startState = {
            machX = mc.mcAxisGetMachinePos(inst, 0),
            machY = mc.mcAxisGetMachinePos(inst, 1),
            machZ = mc.mcAxisGetMachinePos(inst, 2),
            workX = mc.mcAxisGetPos(inst, mc.X_AXIS),
            workY = mc.mcAxisGetPos(inst, mc.Y_AXIS),
            workZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
        }
        
        -- Get probe parameters
        local fastFeed = mc.mcCntlGetPoundVar(inst, 303) or 30
        local slowFeed = mc.mcCntlGetPoundVar(inst, 304) or 5
        local maxTravel = mc.mcCntlGetPoundVar(inst, 305) or 1.0
        
        -- Move down to probe depth
        mc.mcCntlSetLastError(inst, "Moving to probe depth...")
        local depthCmd = string.format("G0 Z%.4f", startState.workZ - probeDepth)
        mc.mcCntlGcodeExecuteWait(inst, depthCmd)
        
        local probePoints = {}
        local success = true
        local errorMsg = nil
        
        -- Define probe sequence based on point count
        local probeSequence = {}
        
        if probePoints == 3 then
            -- 3-point measurement at 0°, 120°, 240°
            probeSequence = {
                {angle = 0, direction = 1, name = "0°", axis = "X", sign = 1},
                {angle = 120, direction = nil, name = "120°"},  -- Custom angle
                {angle = 240, direction = nil, name = "240°"}   -- Custom angle
            }
        else
            -- 4-point measurement on axes
            probeSequence = {
                {direction = 1, name = "+X", axis = "X", retract = -0.1},
                {direction = 2, name = "-X", axis = "X", retract = 0.1},
                {direction = 3, name = "+Y", axis = "Y", retract = -0.1},
                {direction = 4, name = "-Y", axis = "Y", retract = 0.1}
            }
        end
        
        -- Execute probes
        for i, probe in ipairs(probeSequence) do
            -- Check probe state
            if ProbeLib.Core.IsProbeTriggered(inst) then
                errorMsg = string.format("Probe stuck before %s measurement", probe.name)
                success = false
                break
            end
            
            -- For 3-point, we need custom probe movements
            if probePoints == 3 and probe.angle then
                mc.mcCntlSetLastError(inst, string.format("Probing at %s...", probe.name))
                
                -- Calculate probe direction based on angle
                local angleRad = probe.angle * math.pi / 180
                local xMove = math.cos(angleRad) * maxTravel
                local yMove = math.sin(angleRad) * maxTravel
                
                -- Execute composite probe move
                local probeCmd = string.format("G31 X%.4f Y%.4f F%.1f", 
                    startState.workX + xMove, startState.workY + yMove, slowFeed)
                mc.mcCntlGcodeExecuteWait(inst, probeCmd)
                
                -- Get contact position
                local contactX = mc.mcAxisGetPos(inst, mc.X_AXIS)
                local contactY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
                
                table.insert(probePoints, {x = contactX, y = contactY, angle = probe.angle})
                
                -- Retract toward center
                mc.mcCntlSetLastError(inst, "Retracting...")
                local retractCmd = string.format("G0 X%.4f Y%.4f", startState.workX, startState.workY)
                mc.mcCntlGcodeExecuteWait(inst, retractCmd)
            else
                -- 4-point standard probing
                mc.mcCntlSetLastError(inst, string.format("Probing %s...", probe.name))
                local probeSuccess, edgeWork, edgeMachine = ProbeLib.Movement.ExecuteProbe(inst, probe.direction, probe.name)
                
                if not probeSuccess then
                    errorMsg = string.format("%s probe failed - no contact", probe.name)
                    success = false
                    break
                end
                
                -- Store point based on axis
                if probe.axis == "X" then
                    table.insert(probePoints, {
                        x = edgeWork,
                        y = startState.workY,
                        direction = probe.direction
                    })
                else
                    table.insert(probePoints, {
                        x = startState.workX,
                        y = edgeWork,
                        direction = probe.direction
                    })
                end
                
                -- Retract from wall
                mc.mcCntlSetLastError(inst, "Retracting...")
                local retractCmd = string.format("G91 G1 %s%.4f F%.1f", probe.axis, probe.retract, fastFeed)
                mc.mcCntlGcodeExecuteWait(inst, retractCmd)
                mc.mcCntlGcodeExecuteWait(inst, "G90")
                
                -- Return to center for next probe (except last)
                if i < #probeSequence then
                    local centerCmd = string.format("G0 X%.4f Y%.4f", startState.workX, startState.workY)
                    mc.mcCntlGcodeExecuteWait(inst, centerCmd)
                end
            end
        end
        
        -- Process results if successful
        if success then
            local centerX, centerY, diameter
            
            if #probePoints == 3 then
                -- Calculate center from 3 points (circle fit)
                -- Using circumcenter formula
                local p1, p2, p3 = probePoints[1], probePoints[2], probePoints[3]
                
                local d = 2 * (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y))
                
                centerX = ((p1.x^2 + p1.y^2) * (p2.y - p3.y) + 
                          (p2.x^2 + p2.y^2) * (p3.y - p1.y) + 
                          (p3.x^2 + p3.y^2) * (p1.y - p2.y)) / d
                          
                centerY = ((p1.x^2 + p1.y^2) * (p3.x - p2.x) + 
                          (p2.x^2 + p2.y^2) * (p1.x - p3.x) + 
                          (p3.x^2 + p3.y^2) * (p2.x - p1.x)) / d
                
                -- Calculate diameter from center to any point
                local dx = p1.x - centerX
                local dy = p1.y - centerY
                diameter = 2 * math.sqrt(dx^2 + dy^2)
            else
                -- 4-point measurement - simple center calculation
                local xPoints = {}
                local yPoints = {}
                
                for _, pt in ipairs(probePoints) do
                    if pt.direction == 1 or pt.direction == 2 then
                        table.insert(xPoints, pt.x)
                    else
                        table.insert(yPoints, pt.y)
                    end
                end
                
                centerX = ProbeLib.Calculations.GetCenter(xPoints[1], xPoints[2])
                centerY = ProbeLib.Calculations.GetCenter(yPoints[1], yPoints[2])
                
                local diameterX = ProbeLib.Calculations.GetWidth(xPoints[1], xPoints[2])
                local diameterY = ProbeLib.Calculations.GetWidth(yPoints[1], yPoints[2])
                diameter = (diameterX + diameterY) / 2  -- Average
                
                -- Check circularity
                if not ProbeLib.Calculations.CheckPerpendicularity(diameterX, diameterY, 0.98) then
                    UILib.Msg.Warning(
                        string.format("X and Y diameters differ:\nX: %.4f\"\nY: %.4f\"\n\n" ..
                                     "Bore may not be circular", diameterX, diameterY),
                        "Circularity Warning")
                end
            end
            
            -- Lift to safe height
            mc.mcCntlSetLastError(inst, "Lifting to safe height...")
            mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startState.workZ))
            
            -- Move to center
            mc.mcCntlSetLastError(inst, "Moving to bore center...")
            local moveCmd = string.format("G0 X%.4f Y%.4f", centerX, centerY)
            mc.mcCntlGcodeExecuteWait(inst, moveCmd)
            
            -- Execute action
            if actionSel == 1 then  -- Set Datum
                -- Get current machine position to set as zero
                local machX = mc.mcAxisGetMachinePos(inst, 0)
                local machY = mc.mcAxisGetMachinePos(inst, 1)
                ProbeLib.Core.ApplyOrPrint(inst, actionSel, {x = machX, y = machY}, 0)
                
                UILib.Msg.Info(
                    string.format("Work zero set at bore center:\nX=0, Y=0\n\n" ..
                                 "Bore diameter: %.4f\"\n" ..
                                 "Measurement: %d-point", 
                                 diameter, probePoints),
                    "Datum Set")
            else  -- Print Coords
                UILib.Msg.Info(
                    string.format("Bore Center:\nX: %.4f\nY: %.4f\n\n" ..
                                 "Bore diameter: %.4f\"\n" ..
                                 "Measurement: %d-point",
                                 centerX, centerY, diameter, probePoints),
                    "Bore Measurement")
            end
            
            -- Log the probe event
            ProbeLib.Logging.LogEvent(inst, "ProbeBore", 
                centerX, centerY, startState.workZ,
                string.format("Dia:%.4f Points:%d Action:%d", diameter, probePoints, actionSel))
        end
        
        -- Cleanup
        ProbeLib.Cleanup.Standard(inst, success, errorMsg)
        
        return success
    end
    
    -- Execute with error handling
    local ok, err = pcall(ExecuteProbeBore)
    if not ok then
        UILib.Msg.Error("Bore probe failed:\n" .. tostring(err), "Probe Error")
    end
else
    dlg:Destroy()
end