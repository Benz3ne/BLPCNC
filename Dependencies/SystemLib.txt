-- SystemLib.lua v2.0
-- Core system utilities for all Mach4 scripts
-- Provides machine state, signals, safety, settings, logging, and validation

local SystemLib = {}

-- Module initialization
local initialized = false
local signalCache = {}
local debugMode = false
local logBuffer = {}

--[[ SystemLib.Init
Initialize SystemLib and detect debug mode
Params:
  inst: Mach4 instance
Returns:
  success: true if initialized
--]]
function SystemLib.Init(inst)
    if initialized then return true end
    
    -- Check debug mode from pound var #4990
    local debugPV = mc.mcCntlGetPoundVar(inst, 4990)
    debugMode = (debugPV == 1)
    
    initialized = true
    if debugMode then
        mc.mcCntlSetLastError(inst, "SystemLib initialized (DEBUG MODE)")
    end
    return true
end

--[[ SystemLib.FormatSeconds
Converts a duration in seconds into a human-readable HH:MM:SS.s format.
Ideal for displaying cycle timers or estimated run times.

Params:
  seconds (number) - The total number of seconds.
Returns:
  (string) - The formatted time string, e.g., "01:23:45.6".
--]]
function SystemLib.FormatSeconds(seconds)
    local s = tonumber(seconds)
    if not s or s < 0 then
        return "00:00:00.0"
    end
    
    local hours = string.format("%02.f", math.floor(s / 3600))
    local mins = string.format("%02.f", math.floor(s / 60) - (hours * 60))
    -- Format seconds with one decimal place for precision without clutter
    local secs = string.format("%04.1f", s - (hours * 3600) - (mins * 60))
    
    return hours .. ":" .. mins .. ":" .. secs
end

--[[ SystemLib.MachineState
Get current machine state code
Params:
  inst: Mach4 instance
Returns:
  state: Machine state code
  name: Human readable state name
--]]
function SystemLib.MachineState(inst)
    local state = mc.mcCntlGetState(inst)
    local names = {
        [0] = "Idle",
        [100] = "Feed Run",
        [101] = "Feed Hold", 
        [102] = "Probe Hold",
        [103] = "M Hold",
        [109] = "Stop",
        [200] = "MDI/Macro Run",
        [201] = "MDI Feed Hold"
    }
    return state, names[state] or "Unknown"
end

--[[ SystemLib.MachineEnabled
Check if machine is enabled
Params:
  inst: Mach4 instance
Returns:
  enabled: true if machine enabled
--]]
function SystemLib.MachineEnabled(inst)
    local handle = SystemLib.SignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
    if not handle then return false end
    return mc.mcSignalGetState(handle) == 1
end

--[[ SystemLib.InCycle
Check if program is running
Params:
  inst: Mach4 instance
Returns:
  inCycle: true if in cycle
--]]
function SystemLib.InCycle(inst)
    return mc.mcCntlIsInCycle(inst) == 1
end

--[[ SystemLib.CapturePosition
Capture complete machine position state
Params:
  inst: Mach4 instance
Returns:
  table: {machine={x,y,z,a,b,c}, work={x,y,z,a,b,c}, workOffset=54-59}
--]]
function SystemLib.CapturePosition(inst)
    local state = {
        machine = {},
        work = {},
        workOffset = mc.mcCntlGetPoundVar(inst, 4014) or 54
    }
    
    for axis = 0, 5 do
        local axisNames = {[0]="x", [1]="y", [2]="z", [3]="a", [4]="b", [5]="c"}
        state.machine[axisNames[axis]] = mc.mcAxisGetMachinePos(inst, axis)
        state.work[axisNames[axis]] = mc.mcAxisGetPos(inst, axis)
    end
    
    return state
end

--[[ SystemLib.PoundVarGet
Get pound variable with error handling
Params:
  inst: Mach4 instance
  var: Variable number
Returns:
  value: Variable value or nil if uninitialized
--]]
function SystemLib.PoundVarGet(inst, var)
    local v = mc.mcCntlGetPoundVar(inst, var)
    if v == nil or v < -1e300 then
        mc.mcCntlSetLastError(inst, string.format("ERROR: Pound var #%d not initialized", var))
        return nil
    end
    return v
end

--[[ SystemLib.PoundVarSet
Set pound variable
Params:
  inst: Mach4 instance
  var: Variable number
  value: Value to set
Returns:
  success: true if successful
--]]
function SystemLib.PoundVarSet(inst, var, value)
    local rc = mc.mcCntlSetPoundVar(inst, var, value)
    if rc ~= mc.MERROR_NOERROR then
        mc.mcCntlSetLastError(inst, string.format("ERROR: Failed to set #%d", var))
        return false
    end
    return true
end

--[[ SystemLib.SignalGetHandle
Get signal handle with caching
Params:
  inst: Mach4 instance
  signal: Signal constant (e.g. mc.OSIG_OUTPUT1)
Returns:
  handle: Signal handle or nil
--]]
function SystemLib.SignalGetHandle(inst, signal)
    -- Check cache first
    if signalCache[signal] then
        return signalCache[signal]
    end
    
    -- Get and cache handle
    local handle = mc.mcSignalGetHandle(inst, signal)
    if handle and handle > 0 then
        signalCache[signal] = handle
        return handle
    end
    
    return nil
end

--[[ SystemLib.SignalGetState
Get signal state with error handling
Params:
  inst: Mach4 instance
  signal: Signal constant or handle
Returns:
  state: 0/1 or nil on error
--]]
function SystemLib.SignalGetState(inst, signal)
  local handle = signal
  if type(signal) == "number" then
    local h = SystemLib.SignalGetHandle(inst, signal)
    if h and h > 0 then handle = h end
  end
  if not handle or handle == 0 then return nil end
  return mc.mcSignalGetState(handle)
end

--[[ SystemLib.SignalSetState
Set signal state with error handling
Params:
  inst: Mach4 instance
  signal: Signal constant or handle
  state: 0/1 or boolean
Returns:
  success: true if successful
--]]
function SystemLib.SignalSetState(inst, signal, state)
  local handle = signal
  local id = nil
  if type(signal) == "number" then
    id = signal
    local h = SystemLib.SignalGetHandle(inst, signal)
    if h and h > 0 then handle = h end
  end
  if not handle or handle == 0 then return false end

  local function _isTracked(i)
    return i == mc.OSIG_OUTPUT3 or i == mc.OSIG_OUTPUT4 or i == mc.OSIG_OUTPUT5 or i == mc.OSIG_OUTPUT6
  end
  if not id then
    for _, outId in ipairs({ mc.OSIG_OUTPUT3, mc.OSIG_OUTPUT4, mc.OSIG_OUTPUT5, mc.OSIG_OUTPUT6 }) do
      local h = SystemLib.SignalGetHandle(inst, outId)
      if h and h == handle then id = outId; break end
    end
  end

  local debugOn = (SystemLib.IsDebugMode and SystemLib.IsDebugMode()) and true or false
  local traceOn = false
  if debugOn then
    local ok, v = pcall(mc.mcCntlGetPoundVar, inst, 4992) -- #4992 enables signal write tracing
    traceOn = ok and (tonumber(v) == 1) or false
  end

  -- Optional guard: #4991 blocks ON writes to O3..O6
  if id and _isTracked(id) then
    local ok, guard = pcall(mc.mcCntlGetPoundVar, inst, 4991)
    -- NOTE: do NOT use (state and 1 or 0) here (0 is truthy in Lua). Use normalized v.
    if ok and tonumber(guard) == 1 and v == 1 then
      mc.mcCntlSetLastError(inst, string.format("[SYSDBG][GUARD] Block ON write id=%s", tostring(id)))
      return true
    end
  end

  local v = (state == true or state == 1 or state == "1" or state == "HIGH" or state == "high") and 1 or 0
  mc.mcSignalSetState(handle, v)

  if debugOn and traceOn and id and _isTracked(id) then
    local imm = mc.mcSignalGetState(handle)
    local t = os.clock(); while os.clock() - t < 0.15 do end
    local aft = mc.mcSignalGetState(handle)
    local enH = SystemLib.SignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
    local en = (enH and mc.mcSignalGetState(enH) == 1) and 1 or 0
    -- NOTE: log normalized value actually written (avoid (state and 1 or 0) truthy bug)
    mc.mcCntlSetLastError(inst, string.format("[SYSDBG] SetState id=%s want=%d imm=%s aft=%s en=%d", tostring(id), v, tostring(imm), tostring(aft), en))
  end
  return true
end

--[[ SystemLib.CheckHoming
Check if axes are homed
Params:
  inst: Mach4 instance
  showMessage: Show warning dialog if not homed
Returns:
  allHomed: true if all enabled axes homed
  unhomedAxes: Array of unhomed axis names
--]]
function SystemLib.CheckHoming(inst, showMessage)
    local allHomed = true
    local unhomedAxes = {}
    
    for axis = 0, 5 do
        local enabled = mc.mcAxisIsEnabled(inst, axis)
        local homed = mc.mcAxisIsHomed(inst, axis)
        
        if enabled == 1 and homed ~= 1 then
            allHomed = false
            local names = {[0]="X", [1]="Y", [2]="Z", [3]="A", [4]="B", [5]="C"}
            table.insert(unhomedAxes, names[axis])
        end
    end
    
    if not allHomed and showMessage then
        local msg = "Axes not homed: " .. table.concat(unhomedAxes, ", ")
        wx.wxMessageBox(msg, "Homing Required", wx.wxOK + wx.wxICON_WARNING)
    end
    
    return allHomed, unhomedAxes
end

--[[ SystemLib.CheckSoftLimits
Check if position is within soft limits
Params:
  inst: Mach4 instance
  axis: Axis number (0=X, 1=Y, 2=Z)
  position: Machine coordinate position
Returns:
  valid: true if within limits
  error: Error message if outside
--]]
function SystemLib.CheckSoftLimits(inst, axis, position)
    if mc.mcSoftLimitGetState(inst, axis) ~= 1 then
        return true  -- Soft limits disabled
    end
    
    local min = mc.mcAxisGetSoftlimitMin(inst, axis)
    local max = mc.mcAxisGetSoftlimitMax(inst, axis)
    
    if position < min or position > max then
        local names = {[0]="X", [1]="Y", [2]="Z", [3]="A", [4]="B", [5]="C"}
        return false, string.format("%s position %.4f outside limits [%.4f, %.4f]",
                                   names[axis], position, min, max)
    end
    
    return true
end

--[[ SystemLib.GetMaxTravel
Get maximum safe travel distance for axis
Params:
  inst: Mach4 instance
  axis: Axis number (0=X, 1=Y, 2=Z)
  direction: 1 for positive, -1 for negative
  buffer: Safety buffer from limit (default 0.01)
Returns:
  distance: Maximum safe travel distance
--]]
function SystemLib.GetMaxTravel(inst, axis, direction, buffer)
    buffer = buffer or 0.01
    
    if mc.mcSoftLimitGetState(inst, axis) ~= 1 then
        return 999999  -- No limit
    end
    
    local current = mc.mcAxisGetMachinePos(inst, axis)
    
    if direction > 0 then
        local max = mc.mcAxisGetSoftlimitMax(inst, axis)
        return math.max(0, (max - buffer) - current)
    else
        local min = mc.mcAxisGetSoftlimitMin(inst, axis)
        return math.max(0, current - (min + buffer))
    end
end

--[[ SystemLib.G68Active
Check if G68 rotation is active
Params:
  inst: Mach4 instance
Returns:
  active: true if G68 active
  angle: Current rotation angle
--]]
function SystemLib.G68Active(inst)
    local modal = mc.mcCntlGetPoundVar(inst, 4016)
    local angle = mc.mcCntlGetPoundVar(inst, 1247)
    return (modal == 68), angle
end

SystemLib.G68 = SystemLib.G68 or {}

--[[ G68.SaveState
Store current G68 state to pound variables for later restoration.
This function is idempotent. If a state is already saved (#443=1),
it will not be overwritten, preserving the original state for a full cycle.
Params:
  inst (number)
Returns:
  wasActive (bool) - true if G68 was active and state was saved.
]]
function SystemLib.G68.SaveState(inst)
    -- M2 Fix: Do not overwrite an existing saved state.
    if (SystemLib.PoundVarGet(inst, 443) or 0) == 1 then
        return true -- A state is already saved, respect it.
    end

    local active = SystemLib.G68.IsActive(inst)
    if not active then
        SystemLib.G68.ClearState(inst) -- Ensure restore flag is clear
        return false
    end
    
    -- Read current G68 parameters from Mach4's internal variables
    local x = mc.mcCntlGetPoundVar(inst, 1245) -- G68 X center
    local y = mc.mcCntlGetPoundVar(inst, 1246) -- G68 Y center
    local r = mc.mcCntlGetPoundVar(inst, 1247) -- G68 R angle
    
    -- Store them in our designated pound variables
    SystemLib.PoundVarSet(inst, 440, x)
    SystemLib.PoundVarSet(inst, 441, y)
    SystemLib.PoundVarSet(inst, 442, r)
    SystemLib.PoundVarSet(inst, 443, 1)  -- Set restore flag
    
    return true
end

--[[ G68.RestoreState
Restore a previously saved G68 state, with optional center adjustment.
Clears the restore flag upon successful execution.
Params:
  inst (number)
  delta (table|nil): {dx=number, dy=number} to adjust the stored center point.
    - The new center will be (storedX + dx, storedY + dy).
Returns:
  restored (bool) - true if a state was pending and successfully restored.
]]
function SystemLib.G68.RestoreState(inst, delta)
    local state = SystemLib.G68.GetState(inst)
    if not state.active then
        return false
    end

    local dx = (delta and delta.dx) or 0
    local dy = (delta and delta.dy) or 0
    
    local newX = state.x + dx
    local newY = state.y + dy

    local gcode = string.format("G68 X%.4f Y%.4f R%.4f", newX, newY, state.angle)
    local ok, err = SystemLib.MDIExec(inst, gcode, { wait_idle = true })
    
    if ok then
        SystemLib.G68.ClearState(inst) -- Clear the restore flag
        return true
    else
        SystemLib.Log(inst, "Failed to restore G68 state: " .. tostring(err), "ERROR")
        return false
    end
end

--[[ SystemLib.SettingsCreate
Create a cached settings manager for a profile section
Params:
  inst: Mach4 instance
  section: Profile section name
Returns:
  manager: Settings manager object with get/set methods
--]]
function SystemLib.SettingsCreate(inst, section)
    local manager = {
        inst = inst,
        section = section,
        cache = {},
        dirty = false
    }
    
    function manager:get(key, default)
        if self.cache[key] ~= nil then
            return self.cache[key]
        end
        
        local value = mc.mcProfileGetString(self.inst, self.section, key, "")
        if value == "" then
            self.cache[key] = default
            return default
        end
        
        -- Auto type conversion
        if value == "true" then value = true
        elseif value == "false" then value = false
        elseif tonumber(value) then value = tonumber(value)
        end
        
        self.cache[key] = value
        return value
    end
    
    function manager:getInt(key, default)
        local val = self:get(key, default)
        return math.floor(tonumber(val) or default or 0)
    end
    
    function manager:getFloat(key, default)
        local val = self:get(key, default)
        return tonumber(val) or default or 0.0
    end
    
    function manager:getBool(key, default)
        local val = self:get(key, default)
        return val == true or val == 1 or val == "true" or val == "1"
    end
    
    function manager:set(key, value)
        self.cache[key] = value
        self.dirty = true
        
        local strVal = tostring(value)
        if type(value) == "boolean" then
            strVal = value and "true" or "false"
        end
        
        mc.mcProfileWriteString(self.inst, self.section, key, strVal)
        return true
    end
    
    function manager:flush()
        if self.dirty then
            mc.mcProfileFlush(self.inst)
            self.dirty = false
        end
    end
    
    return manager
end

--[[ SystemLib.ProfileRead
Read value from profile
Params:
  inst: Mach4 instance
  section: Profile section
  key: Setting key
  default: Default value if not found
Returns:
  value: Retrieved value or default
--]]
function SystemLib.ProfileRead(inst, section, key, default)
    return mc.mcProfileGetString(inst, section, key, default or "")
end

--[[ SystemLib.ProfileWrite
Write value to profile
Params:
  inst: Mach4 instance
  section: Profile section
  key: Setting key
  value: Value to write
Returns:
  success: true if written
--]]
function SystemLib.ProfileWrite(inst, section, key, value)
    local rc = mc.mcProfileWriteString(inst, section, key, tostring(value))
    return rc == mc.MERROR_NOERROR
end

--[[ SystemLib.Log
Log message with optional debug mode
Params:
  inst: Mach4 instance
  message: Message to log
  level: "ERROR", "WARNING", "INFO", "DEBUG"
Returns:
  none
--]]
function SystemLib.Log(inst, message, level)
    level = level or "INFO"
    
    -- Always show errors and warnings
    if level == "ERROR" or level == "WARNING" then
        mc.mcCntlSetLastError(inst, string.format("[%s] %s", level, message))
        table.insert(logBuffer, {time=os.clock(), level=level, msg=message})
        return
    end
    
    -- Only show info/debug in debug mode
    if debugMode then
        mc.mcCntlSetLastError(inst, string.format("[%s] %s", level, message))
    end
    
    -- Always buffer for diagnostics
    table.insert(logBuffer, {time=os.clock(), level=level, msg=message})
    if #logBuffer > 100 then
        table.remove(logBuffer, 1)
    end
end

--[[ SystemLib.GetLogBuffer
Get recent log entries for diagnostics
Params:
  count: Number of entries to return (default all)
Returns:
  array: Log entries
--]]
function SystemLib.GetLogBuffer(count)
    count = count or #logBuffer
    local start = math.max(1, #logBuffer - count + 1)
    local result = {}
    
    for i = start, #logBuffer do
        table.insert(result, logBuffer[i])
    end
    
    return result
end

--[[ SystemLib.MsgError
Show error message dialog
Params:
  message: Error message
  title: Dialog title (optional)
Returns:
  none
--]]
function SystemLib.MsgError(message, title)
    title = title or "Error"
    wx.wxMessageBox(message, title, wx.wxOK + wx.wxICON_ERROR)
    SystemLib.Log(mc.mcGetInstance(), message, "ERROR")
end

--[[ SystemLib.MsgWarning
Show warning message dialog
Params:
  message: Warning message
  title: Dialog title (optional)
Returns:
  none
--]]
function SystemLib.MsgWarning(message, title)
    title = title or "Warning"
    wx.wxMessageBox(message, title, wx.wxOK + wx.wxICON_WARNING)
    SystemLib.Log(mc.mcGetInstance(), message, "WARNING")
end

--[[ SystemLib.MsgInfo
Show information message dialog
Params:
  message: Info message
  title: Dialog title (optional)
Returns:
  none
--]]
function SystemLib.MsgInfo(message, title)
    title = title or "Information"
    wx.wxMessageBox(message, title, wx.wxOK + wx.wxICON_INFORMATION)
end

--[[ SystemLib.MsgConfirm
Show confirmation dialog
Params:
  message: Question to confirm
  title: Dialog title (optional)
Returns:
  confirmed: true if user clicked Yes
--]]
function SystemLib.MsgConfirm(message, title)
    title = title or "Confirm"
    local result = wx.wxMessageBox(message, title, wx.wxYES_NO + wx.wxICON_QUESTION)
    return result == wx.wxYES
end

--[[ SystemLib.ValidateNumber
Validate numeric value with range
Params:
  value: Value to validate
  min: Minimum allowed (optional)
  max: Maximum allowed (optional)
  name: Value name for error message
Returns:
  valid: true if valid
  value: Converted number or nil
  error: Error message if invalid
--]]
function SystemLib.ValidateNumber(value, min, max, name)
    name = name or "Value"
    local num = tonumber(value)
    
    if not num then
        return false, nil, name .. " must be a number"
    end
    
    if min and num < min then
        return false, nil, string.format("%s must be >= %g", name, min)
    end
    
    if max and num > max then
        return false, nil, string.format("%s must be <= %g", name, max)
    end
    
    return true, num, nil
end

--[[ SystemLib.ValidateFeedRate
Validate feed rate is within reasonable range
Params:
  rate: Feed rate to validate
Returns:
  valid: true if valid
  rate: Validated rate or nil
--]]
function SystemLib.ValidateFeedRate(rate)
    local ok, val, err = SystemLib.ValidateNumber(rate, 0.1, 500, "Feed rate")
    if not ok then
        mc.mcCntlSetLastError(mc.mcGetInstance(), err)
        return false, nil
    end
    return true, val
end

--[[ SystemLib.SetDebugMode
Enable or disable debug mode
Params:
  inst: Mach4 instance
  enabled: true to enable debug
Returns:
  none
--]]
function SystemLib.SetDebugMode(inst, enabled)
    debugMode = enabled
    -- Avoid (enabled and 1 or 0) truthy bug if callers pass 0/1 numerics
    local v = (enabled == true or enabled == 1 or enabled == "1") and 1 or 0
    mc.mcCntlSetPoundVar(inst, 4990, v)
    mc.mcCntlSetLastError(inst, "Debug mode: " .. (enabled and "ON" or "OFF"))
end

--[[ SystemLib.IsDebugMode
Check if debug mode is active
Params:
  none
Returns:
  enabled: true if debug mode on
--]]
function SystemLib.IsDebugMode()
    return debugMode
end

--[[ SystemLib.GenerateDiagnostics
Generate comprehensive diagnostic report
Params:
  inst: Mach4 instance
Returns:
  report: Diagnostic string
--]]
function SystemLib.GenerateDiagnostics(inst)
    local lines = {
        "=== System Diagnostics ===",
        string.format("Generated: %s", os.date("%Y-%m-%d %H:%M:%S")),
        "",
        "-- Machine State --"
    }
    
    -- Machine state
    local state, name = SystemLib.MachineState(inst)
    table.insert(lines, string.format("State: %s (%d)", name, state))
    table.insert(lines, string.format("Enabled: %s", SystemLib.MachineEnabled(inst) and "Yes" or "No"))
    table.insert(lines, string.format("In Cycle: %s", SystemLib.InCycle(inst) and "Yes" or "No"))
    
    -- Position
    local pos = SystemLib.CapturePosition(inst)
    table.insert(lines, "")
    table.insert(lines, "-- Position --")
    table.insert(lines, string.format("Machine: X%.4f Y%.4f Z%.4f", 
                                     pos.machine.x, pos.machine.y, pos.machine.z))
    table.insert(lines, string.format("Work: X%.4f Y%.4f Z%.4f",
                                     pos.work.x, pos.work.y, pos.work.z))
    table.insert(lines, string.format("Work Offset: G%d", pos.workOffset))
    
    -- Homing
    local homed, axes = SystemLib.CheckHoming(inst, false)
    table.insert(lines, "")
    table.insert(lines, "-- Homing --")
    if homed then
        table.insert(lines, "All axes homed")
    else
        table.insert(lines, "Unhomed: " .. table.concat(axes, ", "))
    end
    
    -- G68
    local g68Active, angle = SystemLib.G68Active(inst)
    if g68Active then
        table.insert(lines, "")
        table.insert(lines, string.format("G68 Active: %.3f degrees", angle))
    end
    
    -- Recent log entries
    table.insert(lines, "")
    table.insert(lines, "-- Recent Log --")
    local logs = SystemLib.GetLogBuffer(10)
    for _, entry in ipairs(logs) do
        table.insert(lines, string.format("[%.1f] %s: %s", 
                                         entry.time, entry.level, entry.msg))
    end
    
    return table.concat(lines, "\n")
end

--[[ RequireReady
Quick gate: machine enabled, idle, and selected axes homed.
Params:
  inst (number) - Mach4 instance
  opts (table|nil):
    axes       -> {0,1,2} axes to require homed (default {0,1,2})
    showMsg    -> boolean, message box on failure (default true)
    title      -> string, message box title (default "Safety Check")
Returns:
  ok (bool), err (string|nil)
]]
function SystemLib.RequireReady(inst, opts)
    opts = opts or {}
    local axes    = opts.axes or {0,1,2}  -- X,Y,Z by default
    local showMsg = (opts.showMsg ~= false)
    local title   = opts.title or "Safety Check"

    -- Machine enabled?
    if not SystemLib.MachineEnabled(inst) then
        local err = "Machine is disabled."
        if showMsg then pcall(wx.wxMessageBox, err, title, wx.wxOK + wx.wxICON_WARNING) end
        SystemLib.Log(inst, err, "WARNING")
        return false, err
    end

    -- Idle?
    local state = mc.mcCntlGetState(inst)
    if state ~= mc.MC_STATE_IDLE then
        local err = "Controller not idle."
        if showMsg then pcall(wx.wxMessageBox, err, title, wx.wxOK + wx.wxICON_WARNING) end
        SystemLib.Log(inst, err, "WARNING")
        return false, err
    end

    -- Selected axes homed?
    local names = {[0]="X",[1]="Y",[2]="Z",[3]="A",[4]="B",[5]="C"}
    local unhomed = {}
    for _, ax in ipairs(axes) do
        local en  = mc.mcAxisIsEnabled(inst, ax) == 1
        local hom = mc.mcAxisIsHomed(inst, ax) == 1
        if en and not hom then table.insert(unhomed, names[ax] or tostring(ax)) end
    end
    if #unhomed > 0 then
        local err = "Axes not homed: " .. table.concat(unhomed, ", ")
        if showMsg then pcall(wx.wxMessageBox, err, title, wx.wxOK + wx.wxICON_WARNING) end
        SystemLib.Log(inst, err, "WARNING")
        return false, err
    end

    return true, nil
end

--[[ BuildMove
Return a modal-safe G-code string for a single move or Z-first sequence.
Params:
  params (table):
    coordMode -> "work"|"machine"|"relative"  (default "work")
    type      -> "rapid"|"feed"               (default "rapid")
    feed      -> number feedrate if type="feed"
    x,y,z     -> numbers (nil means omit axis)
    zFirst    -> boolean, if true emits Z then XY in two lines when both present
Returns:
  gcode (string) - Contains one or two lines, ends with newline
Notes:
  - Pure builder: no execution, no mode restoration.
  - For coordMode="machine", caller must pass absolute machine positions.
]]
function SystemLib.BuildMove(params)
    local p = params or {}
    local coordMode = (p.coordMode or "work"):lower()
    local mtype     = (p.type or "rapid"):lower()
    local zFirst    = p.zFirst and true or false
    local hasX, hasY, hasZ = (p.x ~= nil), (p.y ~= nil), (p.z ~= nil)

    local prefix
    if coordMode == "relative" then
        prefix = "G91 "
    elseif coordMode == "machine" then
        -- G53 only acts in absolute (G90) and with the same block
        prefix = "G90 G53 "
    else
        prefix = "G90 "
    end

    local mot
    if mtype == "feed" then mot = "G1 " else mot = "G0 " end

    local function axisWords(x, y, z)
        local w = {}
        if x ~= nil then table.insert(w, string.format("X%.4f", x)) end
        if y ~= nil then table.insert(w, string.format("Y%.4f", y)) end
        if z ~= nil then table.insert(w, string.format("Z%.4f", z)) end
        return table.concat(w, " ")
    end

    local lines = {}

    if zFirst and hasZ and (hasX or hasY) then
        table.insert(lines, string.format("%s%s%s%s\n",
            prefix, mot, axisWords(nil, nil, p.z), (mtype=="feed" and p.feed and (" F"..tostring(p.feed)) or "")))
        table.insert(lines, string.format("%s%s%s\n",
            prefix, mot, axisWords(p.x, p.y, nil)))
    else
        table.insert(lines, string.format("%s%s%s%s\n",
            prefix, mot, axisWords(p.x, p.y, p.z), (mtype=="feed" and p.feed and (" F"..tostring(p.feed)) or "")))
    end

    return table.concat(lines)
end

-- Ensure subtable exists for file helpers
SystemLib.Files = SystemLib.Files or {}
local lfs_ok, lfs = pcall(require, "lfs")

--[[ WriteTemp
Write contents to a unique file under a profile-scoped temp subfolder.
Params:
  inst (number)      - Mach4 instance
  subdir (string)    - e.g. "LaserTemp" (folder will be created if missing)
  basename (string)  - logical base (e.g. "outline")
  contents (string)  - file content
  opts (table|nil):
    ext  -> file extension including dot (default ".tmp")
Returns:
  fullpath (string|nil), err (string|nil)
Notes:
  - Uses %TEMP% on Windows as base; appends \Mach4Temp\<Profile>\<subdir>\
  - Keep/prune logic intentionally omitted (no lfs); simple and reliable.
]]
function SystemLib.Files.WriteTemp(inst, subdir, basename, contents, opts)
    opts = opts or {}
    local ext = opts.ext or ".tmp"

    -- Build base: %TEMP%\Mach4Temp\<Profile>\<subdir>\
    local tempBase = os.getenv("TEMP") or os.getenv("TMP") or "C:\\Temp"
    local profName = mc.mcProfileGetName and mc.mcProfileGetName(inst) or "Default"
    local dir = string.format("%s\\Mach4Temp\\%s\\%s\\", tempBase, profName, subdir or "Temp")

    -- Ensure directory (best-effort, idempotent) without spawning a shell
    do
        local ok = false
        -- Prefer LuaFileSystem if available
        if lfs_ok and lfs then
            local function ensure(path)
                local norm = tostring(path or ""):gsub("[\\/]+$", "")
                local acc = ""
                for part in norm:gmatch("[^\\/]+") do
                    acc = (acc == "") and part or (acc .. "\\" .. part)
                    pcall(lfs.mkdir, acc)
                end
            end
            ok = pcall(ensure, dir)
        end
        -- Fallback to wx if available
        if (not ok) and wx and wx.wxFileName then
            local fn = wx.wxFileName(dir)
            pcall(function() fn:Mkdir(511, wx.wxPATH_MKDIR_FULL) end)
        end
    end

    -- Unique filename
    local stamp = os.date("%Y%m%d_%H%M%S")
    local rnd   = math.random(1000,9999)
    local file  = string.format("%s%s_%s_%d%s", dir, basename or "file", stamp, rnd, ext)

    local fh, ferr = io.open(file, "wb")
    if not fh then
        local err = "Unable to open file: " .. tostring(ferr)
        SystemLib.Log(inst, err, "ERROR")
        return nil, err
    end
    fh:write(contents or "")
    fh:close()

    SystemLib.Log(inst, "Temp file written: " .. file, "INFO")
    return file, nil
end

-- Robust path split using wxFileName (handles / and \ properly)
function SystemLib.Files.GetDirAndName(path)
  local f = wx.wxFileName(tostring(path or ""))
  return f:GetPathWithSep(), f:GetName(), f:GetExt()
end

-- Convert glob (*.tap) to Lua pattern (^.*%.tap$)
function SystemLib.Files.GlobToPattern(glob)
  local g = tostring(glob or "*")
  local p = "^" .. g:gsub("([%^%$%(%)%%%.%[%]%+%-%?])", "%%%1")
                   :gsub("%*%*", "\001")   -- temp for **
                   :gsub("%*", ".*")
                   :gsub("\001", ".+")
                   :gsub("%?", ".") .. "$"
  return p
end

-- Find files matching a glob (default) or Lua pattern
-- Params: dir (string), mask (string, e.g., \"*.tap\"), opts {use_glob=true}
-- Returns: iterator of full paths
function SystemLib.Files.Find(dir, mask, opts)
  opts = opts or {}
  if not lfs_ok then
    return function() return nil end
  end
  if type(dir) ~= "string" or dir == "" then
    return function() return nil end
  end
  local patt = (opts.use_glob ~= false) and SystemLib.Files.GlobToPattern(mask or "*") or (mask or ".*")
  local function iter()
    for name in lfs.dir(dir) do
      if name ~= "." and name ~= ".." then
        if name:match(patt) then
          local sep = dir:match("[/\\]$") and "" or "\\"
          coroutine.yield(dir .. sep .. name)
        end
      end
    end
  end
  return coroutine.wrap(iter)
end

SystemLib.Errors = SystemLib.Errors or {}

-- Minimal map; extend as needed.
SystemLib.Errors.Names = {
  [mc.MERROR_NOERROR]         = "MERROR_NOERROR",
  [mc.MERROR_NOT_IMPLEMENTED] = "MERROR_NOT_IMPLEMENTED",
  [-17] = "MERROR_API_INIT",       -- example from Mach docs/snippets
  [-18] = "MERROR_INVALID_ARG",
}

function SystemLib.Errors.Name(rc)
  return SystemLib.Errors.Names[rc] or ("RC_"..tostring(rc))
end

--[[ Errors.Check
If rc != NOERROR, logs a readable message and returns false, name.
Usage:
  local rc = mc.mcProfileWriteString(inst, "Sec","Key","Val")
  local ok = SystemLib.Errors.Check(rc, "ProfileWrite")
]]
function SystemLib.Errors.Check(rc, where)
  if rc == mc.MERROR_NOERROR then return true end
  local name = SystemLib.Errors.Name(rc)
  local msg = string.format("%s failed: %s (%d)", tostring(where or "Call"), name, rc)
  if SystemLib.Log then
    SystemLib.Log(mc.mcGetInstance(), msg, "ERROR")
  else
    mc.mcCntlSetLastError(mc.mcGetInstance(), msg)
  end
  return false, name
end

--[[ SafeZ
Return a single G-code line for a safe Z retract/approach.
Params (table):
  mode  -> "machine"|"relative"  (default "machine")
  z     -> number; if mode="machine": absolute machine Z; if "relative": delta Z
  type  -> "rapid"|"feed"        (default "rapid")
  feed  -> number feedrate if type="feed" (optional)
Returns:
  line (string) -- ends with newline
Notes:
  - Pure builder: does not execute or restore modes.
  - machine: emits "G90 G53 G0/G1 Z..."
  - relative: emits "G91 G0/G1 Z..."
]]
function SystemLib.SafeZ(params)
    local p = params or {}
    local mode = (p.mode or "machine"):lower()
    local mtype = (p.type or "rapid"):lower()
    local z = p.z
    if z == nil then return "" end

    local mot = (mtype == "feed") and "G1 " or "G0 "
    local feed = (mtype == "feed" and p.feed) and (" F" .. tostring(p.feed)) or ""

    if mode == "relative" then
        return string.format("G91 %sZ%.4f%s\n", mot, z, feed)
    else
        -- default to machine retract
        return string.format("G90 G53 %sZ%.4f%s\n", mot, z, feed)
    end
end

--[[ Edge
Rising/falling edge detector with keyed memory.
Params:
  key (string)   -- unique id for the signal/PV you're tracking
  current (bool) -- current boolean value
Returns:
  rise (bool), fall (bool)
]]
SystemLib.__edge = SystemLib.__edge or {}
function SystemLib.Edge(key, current)
    local prev = SystemLib.__edge[key]
    SystemLib.__edge[key] = current and true or false
    if prev == nil then return false, false end
    local c = current and true or false
    local p = prev and true or false
    return (c and not p), (p and not c)
end

-- Ensure subtable
SystemLib.Signals = SystemLib.Signals or {}

--[[ Signals
Batch handle cache + read/write helpers.
GetHandles(inst, names[]) -> {name=handle}
Read(inst, src) -> if src is array of names returns {name=0/1}; if map {k=name} returns {k=0/1}
Write(inst, values, opts?) -> values {name=0/1} or {k=0/1} with opts.map {k=name}
]]
function SystemLib.Signals.GetHandles(inst, names)
    local out = {}
    for _, n in ipairs(names or {}) do
        out[n] = SystemLib.SignalGetHandle(inst, mc[n] or n)
    end
    return out
end

function SystemLib.Signals.Read(inst, src)
    local res = {}
    if #src > 0 then
        for _, name in ipairs(src) do
            local h = SystemLib.SignalGetHandle(inst, mc[name] or name)
            res[name] = (h and mc.mcSignalGetState(h) or 0)
        end
    else
        for k, name in pairs(src) do
            local h = SystemLib.SignalGetHandle(inst, mc[name] or name)
            res[k] = (h and mc.mcSignalGetState(h) or 0)
        end
    end
    return res
end

function SystemLib.Signals.Write(inst, values, opts)
  opts = opts or {}
  local map = opts.map or {}
  local debugOn = (SystemLib.IsDebugMode and SystemLib.IsDebugMode()) and true or false
  local traceOn = false
  if debugOn then
    local ok, vTrace = pcall(mc.mcCntlGetPoundVar, inst, 4992)
    traceOn = ok and (tonumber(vTrace) == 1) or false
  end
  for k, v in pairs(values or {}) do
    local name = map[k] or k
    local id = mc[name] or name
    if traceOn and (id == mc.OSIG_OUTPUT3 or id == mc.OSIG_OUTPUT4 or id == mc.OSIG_OUTPUT5 or id == mc.OSIG_OUTPUT6) then
      local want = (v == true or v == 1 or v == "1" or v == "HIGH" or v == "high") and 1 or 0
      local h = SystemLib.SignalGetHandle(inst, id)
      local okGuard, guard = pcall(mc.mcCntlGetPoundVar, inst, 4991)
      if okGuard and tonumber(guard) == 1 and want == 1 then
        mc.mcCntlSetLastError(inst, string.format("[SYSDBG][GUARD] Block ON via Signals.Write id=%s", tostring(id)))
      else
        SystemLib.SignalSetState(inst, id, want)
        -- SignalSetState handles debug readback
      end
    else
      local want = (v == true or v == 1 or v == "1" or v == "HIGH" or v == "high") and 1 or 0
      SystemLib.SignalSetState(inst, id, want)
    end
  end
end

-- Ensure subtable
SystemLib.Pound = SystemLib.Pound or {}

--[[ Signals.Apply
Populate a SigLib-style dispatch table with normalized keys.
Usage (in Signal Script):
  local map = {
    ISIG_INPUT17 = function(state) ToolLib.OnToolPresent(state) end,
    OSIG_SPINDLEON = function(state) AuxLib.OnSpindle(state) end,
  }
  SystemLib.Signals.Apply(SigLib, map, {inst = mc.mcGetInstance()})
Params:
  dest  (table)  -- the dispatch table Mach calls: usually SigLib
  map   (table)  -- keys: "ISIG_*"/"OSIG_*" string or numeric id; value: function(state)
  opts  (table?) -- {inst=<instance>|nil}
]]
function SystemLib.Signals.Apply(dest, map, opts)
  dest = dest or {}
  opts = opts or {}
  local inst = opts.inst or mc.mcGetInstance()
  local function norm(k) return (type(k)=="string" and mc[k]) or k end

  for k, fn in pairs(map or {}) do
    local id = norm(k)
    dest[id] = function(state)
      local ok, err = pcall(fn, (state ~= 0) and 1 or 0)
      if not ok then
        mc.mcCntlSetLastError(inst, "Signal handler error ["..tostring(k).."]: "..tostring(err))
      end
    end
  end
  return dest
end

--[[ Signals.Wait
Wait until a signal reaches target state or timeout (non-blocking friendly: sleeps in small steps).
Params:
  inst (number), sig ("ISIG_*"/"OSIG_*"/id), target (0|1), opts {timeout_ms=3000, poll_ms=25}
Returns:
  ok (bool), err (string|nil)
]]
function SystemLib.Signals.Wait(inst, sig, target, opts)
  opts = opts or {}
  local id = (type(sig)=="string" and mc[sig]) or sig
  local h  = SystemLib.SignalGetHandle(inst, id)
  if not h or h == 0 then return false, "Invalid signal handle: "..tostring(sig) end
  local t0 = wx.wxGetUTCTimeMillis()
  local tmo = opts.timeout_ms or 3000
  local step = opts.poll_ms or 25
  while true do
    -- NOTE: avoid (target and 1 or 0) truthy bug; normalize explicitly
    local want = (target == true or target == 1 or target == "1" or target == "HIGH" or target == "high") and 1 or 0
    if (mc.mcSignalGetState(h) or 0) == want then return true end
    if (wx.wxGetUTCTimeMillis() - t0):ToNumber() > tmo then
      return false, "Timeout waiting for signal "..tostring(sig).." == "..tostring(target)
    end
    wx.wxMilliSleep(step)
  end
end

--[[ Pound
Batch pound-var helpers.
Get(inst, src) -> if array {n} returns {n=val}; if map {k=n} returns {k=val}
Set(inst, kv)  -> kv {n=val}
]]
function SystemLib.Pound.Get(inst, src)
    local res = {}
    if #src > 0 then
        for _, n in ipairs(src) do
            res[n] = SystemLib.PoundVarGet(inst, n)
        end
    else
        for k, n in pairs(src) do
            res[k] = SystemLib.PoundVarGet(inst, n)
        end
    end
    return res
end

function SystemLib.Pound.Set(inst, kv)
    for n, val in pairs(kv or {}) do
        SystemLib.PoundVarSet(inst, tonumber(n), tonumber(val))
    end
end

--[[ WaitIdleOr
Poll until controller is IDLE or predicate returns true.
Params:
  inst (number)
  opts (table):
    timeout_ms (number, default 8000)
    poll_ms    (number, default 25)
    until      (function|nil) -> bool
Returns:
  ok (bool), err (string|nil)
]]
function SystemLib.WaitIdleOr(inst, opts)
    opts = opts or {}
    local tmo   = opts.timeout_ms or 8000
    local step  = opts.poll_ms or 20
    local pred  = opts["until"]

    -- Preserve original semantics: IDLE OR predicate()
    local function idle_or_pred()
        if mc.mcCntlGetState(inst) == mc.MC_STATE_IDLE then return true end
        if pred then
            local ok, r = pcall(pred)
            if ok and r then return true end
        end
        return false
    end

    local ok, why = SystemLib.Await(inst, { predicate = idle_or_pred }, { timeout_ms = tmo, poll_ms = step, mode = "block" })
    if ok then return true end
    return false, (why == "timeout" and "Timeout waiting for IDLE" or tostring(why))
end

--[[ MDIExec
Execute MDI command(s) with optional modal state management.
Params:
  inst (number)
  gcode (string|table) - A single G-code string or an array of strings.
  opts (table|nil):
    wait_idle     -> boolean (default true)
    timeout_ms    -> number (default 8000)
    restoreModals -> boolean (default false); if true, captures/restores all key G-code modals.
Returns:
  ok (bool), err (string|nil)
]]
function SystemLib.MDIExec(inst, gcode, opts)
    opts = opts or {}
    local program
    if type(gcode) == "table" then
        program = table.concat(gcode, "\n")
    else
        program = tostring(gcode or "")
    end

    if program:match("^%s*$") then return true, nil end -- Nothing to do

    local snap = nil
    if opts.restoreModals then
        snap = SystemLib.Modals.Capture(inst)
    end

    mc.mcCntlMdiExecute(inst, program)

    if opts.wait_idle ~= false then
        local tmo  = opts.timeout_ms or 8000
        local step = opts.poll_ms or 20
        local ok, why = SystemLib.Await(inst, { idle = true }, { timeout_ms = tmo, poll_ms = step, mode = "block" })
        if not ok then
            local err = (why == "timeout" and "Timeout waiting for IDLE after MDI" or tostring(why))
            if snap then pcall(SystemLib.Modals.Restore, inst, snap) end
            return false, err
        end
    end

    if snap then
        pcall(SystemLib.Modals.Restore, inst, snap)
    end

    return true
end

-- Ensure subtable
SystemLib.G68 = SystemLib.G68 or {}

--[[ G68Active
Rotation helpers.
IsActive(inst) -> active(bool), angle(number|nil)
Clear(inst, opts?) -> ok, err   -- sends G69 if active (optional prompt handled by caller)
]]
function SystemLib.G68.IsActive(inst)
    -- Delegate to existing G68Active if available
    if SystemLib.G68Active then
        local a, ang = SystemLib.G68Active(inst)   -- note: original returns (active, angle)
        return a and true or false, ang
    end
    -- Fallback: assume not active if API missing
    return false, nil
end

function SystemLib.G68.Clear(inst, opts)
    local active = SystemLib.G68.IsActive(inst)
    if not active then return true end
    return SystemLib.MDIExec(inst, "G69", {wait_idle=true, timeout_ms=(opts and opts.timeout_ms) or 8000})
end

-- Ensure subtable
SystemLib.CNC = SystemLib.CNC or {}

--[[ ModalWrap
Wrap a snippet with modal enter/exit blocks.
Params:
  spec = { enter={"G90","G17"}, body=string|{lines}, exit={"G90"} }
Returns:
  text (string)
]]
function SystemLib.CNC.ModalWrap(spec)
    local function join(lines)
        if type(lines) == "string" then return lines .. (lines:sub(-1) == "\n" and "" or "\n") end
        if type(lines) == "table" then return table.concat(lines, "\n") .. "\n" end
        return ""
    end
    local s = {}
    if spec.enter then table.insert(s, join(spec.enter)) end
    if spec.body  then table.insert(s, join(spec.body))  end
    if spec.exit  then table.insert(s, join(spec.exit))  end
    return table.concat(s)
end

-- Ensure subtable
SystemLib = SystemLib or {}
SystemLib.Coroutine = SystemLib.Coroutine or {}

--[[ Coroutine
Tiny co-runner. Start(fn) -> id; Step() resumes once per call.
]]
SystemLib.Coroutine.__list = SystemLib.Coroutine.__list or {}
function SystemLib.Coroutine.Start(fn)
    local co = coroutine.create(fn)
    table.insert(SystemLib.Coroutine.__list, co)
    return #SystemLib.Coroutine.__list
end
function SystemLib.Coroutine.Step()
    local alive = {}
    for _, co in ipairs(SystemLib.Coroutine.__list) do
        if coroutine.status(co) ~= "dead" then
            local ok, err = coroutine.resume(co)
            if not ok then
                mc.mcCntlSetLastError(mc.mcGetInstance(), "Coroutine error: " .. tostring(err))
            end
            table.insert(alive, co)
        end
    end
    SystemLib.Coroutine.__list = alive
end

--[[ Coroutine.WaitFor
Yielding wait until predicate() returns true or timeout.
Usage inside a coroutine:
  SystemLib.Coroutine.WaitFor(function() return mc.mcCntlGetState(inst)==mc.MC_STATE_IDLE end, {timeout_ms=8000})
On timeout it raises an error (caught by your runner) to avoid dangling coroutines.
]]
function SystemLib.Coroutine.WaitFor(pred, opts)
  opts = opts or {}
  local t0 = wx.wxGetUTCTimeMillis()
  local tmo  = opts.timeout_ms or 8000
  local step = opts.poll_ms or 25
  while true do
    local ok, done = pcall(pred)
    if ok and done then return true end
    if (wx.wxGetUTCTimeMillis() - t0):ToNumber() > tmo then error("Coroutine wait timeout") end
    coroutine.yield()
    wx.wxMilliSleep(step)
  end
end

-- Convenience: wait specifically for controller IDLE
function SystemLib.Coroutine.WaitForIdle(inst, opts)
  return SystemLib.Coroutine.WaitFor(function()
    return mc.mcCntlGetState(inst) == mc.MC_STATE_IDLE
  end, opts)
end

--[[ Coroutine.RunSafe
Start a coroutine with error capture; returns an id (number) for your scheduler.
Caller should resume in PLC via SystemLib.Coroutine.Step() (which you already use).
]]
function SystemLib.Coroutine.RunSafe(fn)
  local function wrapper()
    local ok, err = pcall(fn)
    if not ok then
      mc.mcCntlSetLastError(mc.mcGetInstance(), "Coroutine error: "..tostring(err))
    end
  end
  return SystemLib.Coroutine.Start(wrapper)
end

-- Ensure subtables exist
SystemLib.Dialogs = SystemLib.Dialogs or {}
SystemLib.G68     = SystemLib.G68     or {}
SystemLib.Spindle = SystemLib.Spindle or {}
SystemLib.WorkOffset = SystemLib.WorkOffset or {}
SystemLib.Modals  = SystemLib.Modals  or {}

--[[ Capture
Capture a comprehensive modal snapshot.
Params:
  inst (number)
Returns:
  snap (table) - Contains keys for distance, plane, wcs, units, ijMode, feedMode.
]]
function SystemLib.Modals.Capture(inst)
    local snap = {}
    local function getPV(id)
        local ok, val = pcall(mc.mcCntlGetPoundVar, inst, id)
        return ok and val or nil
    end

    -- Core Modals
    snap.distance = getPV(mc.SV_GCODE_DISTANCE_MODE) -- G90/G91
    snap.plane    = getPV(mc.SV_GCODE_PLANE)         -- G17/18/19
    snap.units    = getPV(mc.SV_GCODE_UNITS)         -- G20/G21
    snap.ijMode   = getPV(mc.SV_GCODE_IJ_MODE)       -- G90.1/G91.1
    snap.feedMode = getPV(mc.SV_GCODE_FEED_MODE)     -- G93/94/95

    -- Work Coordinate System (WCS)
    local fixCode = getPV(mc.SV_MOD_GROUP_14)
    if fixCode then
        if fixCode ~= 54.1 then
            snap.wcs = string.format("G%d", math.floor(fixCode + 0.0001))
        else
            local pval = getPV(mc.SV_BUFP)
            if pval then snap.wcs = string.format("G54.1 P%d", pval) end
        end
    end
    return snap
end

--[[ Restore
Restore a modal snapshot created by Modals.Capture.
Params:
  inst (number), snap (table)
]]
function SystemLib.Modals.Restore(inst, snap)
    if not snap then return end
    local cmds = {}
    -- Build command string in a safe order
    if snap.units    then table.insert(cmds, string.format("G%d", snap.units)) end
    if snap.distance then table.insert(cmds, string.format("G%d", snap.distance)) end
    if snap.plane    then table.insert(cmds, string.format("G%d", snap.plane)) end
    if snap.ijMode   then table.insert(cmds, string.format("G%.1f", snap.ijMode)) end
    if snap.feedMode then table.insert(cmds, string.format("G%d", snap.feedMode)) end
    if snap.wcs      then table.insert(cmds, snap.wcs) end

    if #cmds > 0 then
        -- Use a non-modal-restoring MDIExec to prevent recursion
        SystemLib.MDIExec(inst, table.concat(cmds, " "), { restoreModals = false })
    end
end

--[[ Push
Dialog suppression push (nestable); sets #498 while depth>0.
Params:
  inst (number)
  opts (table|nil): { pv=498 }
Returns:
  depth (number)
]]
SystemLib.__dlgDepth = SystemLib.__dlgDepth or 0
function SystemLib.Dialogs.Push(inst, opts)
    local pv = (opts and opts.pv) or 498
    local prev = SystemLib.__dlgDepth or 0
    SystemLib.__dlgDepth = prev + 1
    if prev == 0 then SystemLib.PoundVarSet(inst, pv, 1) end
    return SystemLib.__dlgDepth
end

--[[ Pop
Dialog suppression pop; clears #498 when depth==0.
Params:
  inst (number)
  opts (table|nil): { pv=498 }
Returns:
  depth (number)
]]
function SystemLib.Dialogs.Pop(inst, opts)
    local pv = (opts and opts.pv) or 498
    local prev = SystemLib.__dlgDepth or 0
    SystemLib.__dlgDepth = math.max(0, prev - 1)
    if prev > 0 and SystemLib.__dlgDepth == 0 then SystemLib.PoundVarSet(inst, pv, 0) end
    return SystemLib.__dlgDepth
end

--[[ G68GetState
Return stored G68 state from #440-#443.
Returns:
  state (table): {active=bool, x=number|nil, y=number|nil, angle=number|nil}
]]
function SystemLib.G68.GetState(inst)
    local flag = SystemLib.PoundVarGet(inst, 443) or 0
    if flag ~= 1 then return {active=false} end
    return {
        active = true,
        x = SystemLib.PoundVarGet(inst, 440) or 0,
        y = SystemLib.PoundVarGet(inst, 441) or 0,
        angle = SystemLib.PoundVarGet(inst, 442) or 0
    }
end

--[[ G68ClearState
Clear stored G68 state (#440-#443).
]]
function SystemLib.G68.ClearState(inst)
    SystemLib.PoundVarSet(inst, 440, 0)
    SystemLib.PoundVarSet(inst, 441, 0)
    SystemLib.PoundVarSet(inst, 442, 0)
    SystemLib.PoundVarSet(inst, 443, 0)
end

--[[ AddDelta
Add {dx,dy,dz} to work offset(s).
Params:
  inst (number)
  delta (table): {dx=0|nil, dy=0|nil, dz=0|nil}
  opts (table|nil):
    scope -> "current"|"basic_all"|"expanded_all"|"all" (default "current")
Returns:
  count (number) -- number of fixtures updated
Notes:
  - basic_all updates G54..G59 (#5221.. increments of 20)
  - expanded_all updates G54.1 P1..P100 using SV_FIXTURE_EXPAND* bases
  - current uses SV_MOD_GROUP_14 and SV_BUFP
]]
function SystemLib.WorkOffset.AddDelta(inst, delta, opts)
    opts = opts or {}
    local dx = tonumber(delta.dx or 0)
    local dy = tonumber(delta.dy or 0)
    local dz = tonumber(delta.dz or 0)
    local scope = opts.scope or "current"
    local n = 0

    local function applyBase(baseX)
        if baseX == nil then return end
        local x = mc.mcCntlGetPoundVar(inst, baseX) or 0
        local y = mc.mcCntlGetPoundVar(inst, baseX + 1) or 0
        local z = mc.mcCntlGetPoundVar(inst, baseX + 2) or 0
        mc.mcCntlSetPoundVar(inst, baseX,     x + dx)
        mc.mcCntlSetPoundVar(inst, baseX + 1, y + dy)
        mc.mcCntlSetPoundVar(inst, baseX + 2, z + dz)
        n = n + 1
    end

    local function baseForCurrent()
        -- Determine active fixture
        local fixCode = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14)
        if fixCode ~= 54.1 then
            local whole = math.floor(fixCode + 0.0001)
            local fixNum = (whole - 53) -- 1..6 => G54..G59
            return ((mc.SV_FIXTURES_START - mc.SV_FIXTURES_INC) + (fixNum * mc.SV_FIXTURES_INC))
        else
            local Pval = mc.mcCntlGetPoundVar(inst, mc.SV_BUFP)
            if Pval > 0 and Pval < 51 then
                return ((mc.SV_FIXTURE_EXPAND - mc.SV_FIXTURES_INC) + (Pval * mc.SV_FIXTURES_INC))
            elseif Pval > 50 and Pval < 101 then
                return ((mc.SV_FIXTURE_EXPAND2 - mc.SV_FIXTURES_INC) + (Pval * mc.SV_FIXTURES_INC))
            end
        end
        return nil
    end

    if scope == "current" then
        applyBase(baseForCurrent())
    end
    if scope == "basic_all" or scope == "all" then
        for i = 0, 5 do
            applyBase(5221 + (i * 20))
        end
    end
    if scope == "expanded_all" or scope == "all" then
        -- G54.1 P1..P50
        for p = 1, 50 do
            local base = ((mc.SV_FIXTURE_EXPAND - mc.SV_FIXTURES_INC) + (p * mc.SV_FIXTURES_INC))
            applyBase(base)
        end
        -- G54.1 P51..P100
        for p = 51, 100 do
            local base = ((mc.SV_FIXTURE_EXPAND2 - mc.SV_FIXTURES_INC) + (p * mc.SV_FIXTURES_INC))
            applyBase(base)
        end
    end

    return n
end

-- ============================================================================
-- Unified Wait Engine
-- SystemLib.Await(inst, spec, opts) -> ok:boolean, why:"ok"|"timeout"
-- spec: exactly one of
--   { idle = true }
--   { signal = <mc.ISIG_* or mc.OSIG_* or id>, state = 0|1 }
--   { predicate = function() return boolean end }
-- opts:
--   timeout_ms (default 8000), poll_ms (default 20)
--   mode = "coop" | "block"   -- explicit
-- ============================================================================
function SystemLib.Await(inst, spec, opts)
    opts = opts or {}
    local timeout_ms = opts.timeout_ms or 8000
    local poll_ms    = opts.poll_ms or 20
    local mode       = opts.mode or "block"  -- shims set explicitly; fallback is block

    -- Build a single evaluator and cache invariants (no per-iteration branching)
    local eval

    if spec.idle then
        eval = function()
            return mc.mcCntlGetState(inst) == mc.MC_STATE_IDLE
        end

    elseif spec.signal then
        local id = (type(spec.signal) == "string" and mc[spec.signal]) or spec.signal
        local h  = (SystemLib.SignalGetHandle and SystemLib.SignalGetHandle(inst, id)) or mc.mcSignalGetHandle(inst, id)
        -- Normalize target state explicitly; avoid (spec.state and 1 or 0)
        local want = (spec.state == true or spec.state == 1 or spec.state == "1" or spec.state == "HIGH" or spec.state == "high") and 1 or 0
        if not h or h == 0 then
            -- Invalid handle: immediate timeout for lean v1
            return false, "timeout"
        end
        eval = function()
            return (mc.mcSignalGetState(h) or 0) == want
        end

    elseif spec.predicate then
        local pred = spec.predicate
        eval = function()
            local ok, r = pcall(pred)
            return ok and r and true or false
        end

    else
        -- No valid spec; immediate timeout in lean v1
        return false, "timeout"
    end

    local start    = wx.wxGetUTCTimeMillis():ToNumber()
    local deadline = start + timeout_ms

    while true do
        if eval() then return true, "ok" end
        if wx.wxGetUTCTimeMillis():ToNumber() >= deadline then
            return false, "timeout"
        end
        if mode == "coop" then
            coroutine.yield()
        else
            wx.wxMilliSleep(poll_ms)
        end
    end
end

--[[SystemLib.RunProfileScript
Run a Lua script from the current Mach4 profile by file *name* or absolute path.

Usage:
  local ok, pathOrErr = SystemLib.RunProfileScript(inst, "TargetMove.txt")
  -- or:
  local ok, pathOrErr = SystemLib.RunProfileScript(inst, "C:\\...\\TargetMove.txt")

Guarantees (single-method policy):
  - Search uses exactly one method: Windows 'dir /B /S' under the current profile.
  - Execution uses exactly one method: loadfile() + pcall().
]]
function SystemLib.RunProfileScript(inst, filename)
  inst = inst or mc.mcGetInstance()
  if type(filename) ~= "string" or filename == "" then
    local msg = "RunProfileScript: invalid filename"
    mc.mcCntlSetLastError(inst, msg)
    return false, msg
  end

  local function isAbs(p) return p:match("^%a:[/\\]") or p:match("^\\\\") end

  -- Profile root + canonical hint (expected default location)
  local machDir = mc.mcCntlGetMachDir(inst) or ""
  local prof    = (mc.mcProfileGetName and mc.mcProfileGetName(inst)) or "Default"
  local root    = machDir .. "\\Profiles\\" .. prof
  local canonical = root .. "\\Scripts\\ButtonScripts\\" .. filename

  local function runFile(path)
    local chunk, loadErr = loadfile(path)
    if not chunk then
      local msg = "RunProfileScript load error: " .. tostring(loadErr)
      mc.mcCntlSetLastError(inst, msg)
      return false, msg
    end
    local ok, execErr = pcall(chunk)
    if not ok then
      local msg = "RunProfileScript runtime error: " .. tostring(execErr)
      mc.mcCntlSetLastError(inst, msg)
      return false, msg
    end
    -- Quiet success in normal mode; log only when debug is enabled
    if SystemLib and SystemLib.IsDebugMode and SystemLib.IsDebugMode() then
      if SystemLib.Log then SystemLib.Log(inst, "Executed script: " .. path, "DEBUG") end
    end
    return true, path
  end

  -- Absolute path: verify + run (no search)
  if isAbs(filename) then
    local f = io.open(filename, "r")
    if not f then
      local msg = "File Not Found at " .. filename
      mc.mcCntlSetLastError(inst, msg)
      return false, msg
    end
    f:close()
    return runFile(filename)
  end

  -- Name only  single search method: recursive DIR under current profile
  -- Try canonical location first to avoid a recursive search
  do
    local f = io.open(canonical, "r")
    if f then f:close(); return runFile(canonical) end
  end

  -- Name only  search under ButtonScripts without spawning a shell
  local matches = {}
  local searchRoot = root .. "\\Scripts\\ButtonScripts"
  do
    if lfs_ok and lfs then
      local function scan(dir)
        for entry in lfs.dir(dir) do
          if entry ~= "." and entry ~= ".." then
            local p = dir .. "\\" .. entry
            local attr = lfs.attributes(p)
            if attr and attr.mode == "file" and entry == filename then
              table.insert(matches, p)
            elseif attr and attr.mode == "directory" then
              scan(p)
            end
          end
        end
      end
      pcall(scan, searchRoot)
    elseif wx and wx.wxDir then
      local function scan(dir)
        local d = wx.wxDir(dir)
        if not d:IsOpened() then return end
        local name = wx.wxString()
        local cont = d:GetFirst(name, "", wx.wxDIR_FILES)
        while cont do
          local fname = name:ToStdString()
          if fname == filename then table.insert(matches, dir .. "\\" .. fname) end
          cont = d:GetNext(name)
        end
        cont = d:GetFirst(name, "", wx.wxDIR_DIRS)
        while cont do
          local sub = dir .. "\\" .. name:ToStdString()
          scan(sub)
          cont = d:GetNext(name)
        end
      end
      pcall(scan, searchRoot)
    end
  end

  if #matches == 0 then
    local msg = "File Not Found at " .. canonical
    mc.mcCntlSetLastError(inst, msg)
    return false, msg
  end

  if #matches > 1 then
    local parts = { 'Multiple files named "' .. filename .. '" found:' }
    for i, path in ipairs(matches) do parts[#parts+1] = ("  %d) %s"):format(i, path) end
    local msg = table.concat(parts, "\n")
    mc.mcCntlSetLastError(inst, msg)
    return false, msg
  end

  return runFile(matches[1])
end

SystemLib.Presets = SystemLib.Presets or {}
SystemLib.History = SystemLib.History or {}
SystemLib.Units   = SystemLib.Units   or {}
SystemLib.Gcode   = SystemLib.Gcode   or {}

--[[ SystemLib.Presets.List
List saved presets in a section.
Params:
  inst: Mach4 instance
  section: Profile section (default "Presets.Generic")
Returns:
  presets: Array of { name=string, data=table }
Notes:
  Keys: __order="Name1|Name2|"; P:Name=encoded (coords|units|x|y|z|move|feed|zfirst)
--]]
function SystemLib.Presets.List(inst, section)
    local sec = tostring(section or "Presets.Generic")
    local S = SystemLib.SettingsCreate(inst, sec)
    local order = tostring(S:get("__order", ""))
    local names = {}
    for n in order:gmatch("([^|]+)") do names[#names+1] = n end
    local out = {}
    for _, name in ipairs(names) do
        local raw = S:get("P:"..name, "")
        if raw ~= "" then
            local parts = {}; for v in tostring(raw):gmatch("([^|]+)") do parts[#parts+1]=v end
            local function num(i) return tonumber(parts[i] or 0) or 0 end
            local function tf(i)  return (parts[i] == "1") end
            out[#out+1] = {
                name = name,
                data = {
                    coords = parts[1] or "work",
                    units  = parts[2] or "in",
                    x = num(3), y = num(4), z = num(5),
                    move = parts[6] or "rapid",
                    feed = num(7),
                    zfirst = tf(8),
                }
            }
        end
    end
    return out
end

--[[ SystemLib.Presets.Get
Retrieve a preset by name.
Params:
  inst: Mach4 instance
  section: Profile section (default "Presets.Generic")
  name: Preset name
Returns:
  table: {coords,units,x,y,z,move,feed,zfirst} or nil if not found
--]]
function SystemLib.Presets.Get(inst, section, name)
    local sec = tostring(section or "Presets.Generic")
    local S   = SystemLib.SettingsCreate(inst, sec)
    local raw = S:get("P:"..tostring(name or ""), "")
    if raw == "" then return nil end
    local parts = {}; for v in tostring(raw):gmatch("([^|]+)") do parts[#parts+1]=v end
    local function num(i) return tonumber(parts[i] or 0) or 0 end
    local function tf(i)  return (parts[i] == "1") end
    return {
        coords = parts[1] or "work",
        units  = parts[2] or "in",
        x = num(3), y = num(4), z = num(5),
        move = parts[6] or "rapid",
        feed = num(7),
        zfirst = tf(8),
    }
end

--[[ SystemLib.Presets.Save
Create or update a preset.
Params:
  inst: Mach4 instance
  section: Profile section (default "Presets.Generic")
  name: Preset name
  record: Table {coords,units,x,y,z,move,feed,zfirst}
Returns:
  ok, err: true on success; false, message on failure
--]]
function SystemLib.Presets.Save(inst, section, name, record)
    local sec = tostring(section or "Presets.Generic")
    name = tostring(name or ""):gsub("[|%c]", "")
    if name == "" then return false, "Invalid name" end
    local S = SystemLib.SettingsCreate(inst, sec)
    local function b(x) return (x and x~=0) and "1" or "0" end
    local enc = table.concat({
        record.coords or "work",
        record.units  or "in",
        tostring(record.x or 0), tostring(record.y or 0), tostring(record.z or 0),
        record.move   or "rapid",
        tostring(record.feed or 0),
        b(record.zfirst ~= false)
    }, "|")
    S:set("P:"..name, enc)
    local order = tostring(S:get("__order", ""))
    local seen = {}; for n in order:gmatch("([^|]+)") do seen[n] = true end
    seen[name] = true
    local names = {}; for n,_ in pairs(seen) do names[#names+1] = n end
    table.sort(names, function(a,b) return a:lower() < b:lower() end)
    S:set("__order", table.concat(names, "|"))
    S:flush()
    return true
end

--[[ SystemLib.Presets.Delete
Delete a preset by name.
Params:
  inst: Mach4 instance
  section: Profile section (default "Presets.Generic")
  name: Preset name
Returns:
  ok: true (idempotent)
--]]
function SystemLib.Presets.Delete(inst, section, name)
    local sec = tostring(section or "Presets.Generic")
    local S   = SystemLib.SettingsCreate(inst, sec)
    local nm  = tostring(name or "")
    S:set("P:"..nm, "")
    local order = tostring(S:get("__order", ""))
    local keep = {}
    for n in order:gmatch("([^|]+)") do if n ~= nm then keep[#keep+1] = n end end
    S:set("__order", table.concat(keep, "|"))
    S:flush()
    return true
end

--[[ SystemLib.History.Read
Read records from a history section (newest first).
Params:
  inst: Mach4 instance
  section: Profile section (default "History.Generic")
Returns:
  history: Array of records {coords,units,x,y,z,move,feed,zfirst}
--]]
function SystemLib.History.Read(inst, section)
    local sec = tostring(section or "History.Generic")
    local S   = SystemLib.SettingsCreate(inst, sec)
    local out, i = {}, 1
    while true do
        local raw = S:get(tostring(i), "")
        if raw == "" then break end
        local parts = {}; for v in tostring(raw):gmatch("([^|]+)") do parts[#parts+1]=v end
        local function num(j) return tonumber(parts[j] or 0) or 0 end
        local function tf(j)  return (parts[j] == "1") end
        out[#out+1] = {
            coords = parts[1] or "work",
            units  = parts[2] or "in",
            x = num(3), y = num(4), z = num(5),
            move = parts[6] or "rapid",
            feed = num(7),
            zfirst = tf(8),
        }
        i = i + 1
    end
    return out
end

--[[ SystemLib.History.Push
Push a record into a history section, keeping a maximum size.
Params:
  inst: Mach4 instance
  section: Profile section (default "History.Generic")
  record: Record table {coords,units,x,y,z,move,feed,zfirst}
  limit: Optional maximum length (default 10)
Returns:
  ok: true when written
--]]
function SystemLib.History.Push(inst, section, record, limit)
    local sec = tostring(section or "History.Generic")
    local S   = SystemLib.SettingsCreate(inst, sec)
    limit = tonumber(limit or 10) or 10; if limit < 1 then limit = 1 end
    local current, i = {}, 1
    while true do
        local raw = S:get(tostring(i), "")
        if raw == "" then break end
        current[#current+1] = raw
        i = i + 1
    end
    local function b(x) return (x and x~=0) and "1" or "0" end
    local enc = table.concat({
        record.coords or "work",
        record.units  or "in",
        tostring(record.x or 0), tostring(record.y or 0), tostring(record.z or 0),
        record.move   or "rapid",
        tostring(record.feed or 0),
        b(record.zfirst ~= false)
    }, "|")
    table.insert(current, 1, enc)
    while #current > limit do table.remove(current) end
    for idx, v in ipairs(current) do S:set(tostring(idx), v) end
    S:set(tostring(#current + 1), "")
    S:flush()
    return true
end

--[[ SystemLib.Units.ConvertXYZF
Convert x,y,z and feed between inches and millimeters.
Params:
  record: {units="in"|"mm", x,y,z,feed, coords?, move?, zfirst?}
  toUnits: "in" or "mm"
Returns:
  record: New table in target units (original is not modified)
--]]
function SystemLib.Units.ConvertXYZF(record, toUnits)
    local r  = record or {}
    local from = r.units or "in"
    local to   = toUnits or from
    local function num(v) return tonumber(v or 0) or 0 end
    if from == to then
        return { coords = r.coords or "work", units = from,
                 x = num(r.x), y = num(r.y), z = num(r.z),
                 move = r.move or "rapid", feed = num(r.feed), zfirst = (r.zfirst ~= false) }
    end
    local factor = (from == "in" and to == "mm") and 25.4 or ((from == "mm" and to == "in") and (1/25.4) or 1)
    return { coords = r.coords or "work", units = to,
             x = num(r.x) * factor, y = num(r.y) * factor, z = num(r.z) * factor,
             move = r.move or "rapid", feed = num(r.feed) * factor, zfirst = (r.zfirst ~= false) }
end

--[[ SystemLib.Gcode.BuildLinearMove
Build a simple linear move (G0/G1) in absolute work/machine or relative.
Params:
  inst: Mach4 instance (unused)
  record: {coords,units,x,y,z,move,feed,zfirst}
  opts: {units?="in"|"mm"} Optional conversion before build
Returns:
  gcode: String
--]]
function SystemLib.Gcode.BuildLinearMove(inst, record, opts)
    opts = opts or {}
    local m = record or {}
    if opts.units and m.units and opts.units ~= m.units then
        local factor = (m.units == "in" and opts.units == "mm") and 25.4 or ((m.units == "mm" and opts.units == "in") and (1/25.4) or 1)
        m = { coords = m.coords or "work", units = opts.units,
              x = (tonumber(m.x or 0) or 0) * factor,
              y = (tonumber(m.y or 0) or 0) * factor,
              z = (tonumber(m.z or 0) or 0) * factor,
              move = m.move or "rapid", feed = (tonumber(m.feed or 0) or 0) * factor,
              zfirst = (m.zfirst ~= false) }
    else
        m = { coords = m.coords or "work", units = m.units or "in",
              x = tonumber(m.x or 0) or 0, y = tonumber(m.y or 0) or 0, z = tonumber(m.z or 0) or 0,
              move = m.move or "rapid", feed = tonumber(m.feed or 0) or 0, zfirst = (m.zfirst ~= false) }
    end

    local lines = {}
    local setF = (m.move ~= "rapid") and string.format("F%.3f", m.feed or 0) or nil

    if m.coords == "relative" then
        table.insert(lines, "G91")
        if setF then table.insert(lines, setF) end
        if m.zfirst then
            if (m.z or 0) ~= 0 then table.insert(lines, (m.move=="rapid" and "G0" or "G1") .. string.format(" Z%.4f", m.z)) end
            if (m.x or 0) ~= 0 or (m.y or 0) ~= 0 then
                table.insert(lines, (m.move=="rapid" and "G0" or "G1") .. string.format(" X%.4f Y%.4f", m.x or 0, m.y or 0))
            end
        else
            if (m.x or 0) ~= 0 or (m.y or 0) ~= 0 then
                table.insert(lines, (m.move=="rapid" and "G0" or "G1") .. string.format(" X%.4f Y%.4f", m.x or 0, m.y or 0))
            end
            if (m.z or 0) ~= 0 then table.insert(lines, (m.move=="rapid" and "G0" or "G1") .. string.format(" Z%.4f", m.z)) end
        end
        table.insert(lines, "G90")
    else
        local prefix = (m.coords == "machine") and "G53 " or ""
        if setF then table.insert(lines, setF) end
        local lin = (m.move == "rapid" and "G0 " or "G1 ")
        table.insert(lines, prefix .. lin .. string.format("X%.4f Y%.4f Z%.4f", m.x or 0, m.y or 0, m.z or 0))
    end

    return table.concat(lines, "\r\n")
end

return SystemLib
