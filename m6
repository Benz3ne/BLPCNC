--[[ Tool Change M6 - v8.0 with Offset Recovery System
WORK SURFACE: Z-7.8 machine coords is ZERO reference
Virtual Tools: T90=Probe (Output#7), T91=Laser (Output#1) 
Physical Tools: T1=No auto-measurement, T2-T89 with auto-measurement
#300-#302 = Probe params
#308-#313 = Tool change params  
#314-#317 = Height measurement params
#318-#319 = Laser X,Y offsets
#350 = Virtual tool active flag
#351 = Last physical tool (for virtual tool return)
#353 = Work surface Z reference
#389 = Probe contact Z
#410 = Original offsets saved flag
#411-422 = Storage for original G54-G59 X,Y values
#498 = Dialog suppression
#499 = M6 running flag (not used - would get stuck if interrupted)
]]--

function m6()
    local inst = mc.mcGetInstance()
    
    -- Initialize flags
    mc.mcCntlSetPoundVar(inst, 498, 0)  -- Dialog suppression off
    
    local WORK_SURFACE_Z = -7.8
    mc.mcCntlSetPoundVar(inst, 353, WORK_SURFACE_Z)
    
    -- ============================================
    -- CORE OFFSET MANAGEMENT FUNCTIONS
    -- ============================================
    
    -- Save original work offsets (only if not already saved)
    local function saveOriginalOffsets(inst)
        -- Check if already saved
        if mc.mcCntlGetPoundVar(inst, 410) == 1 then
            return  -- Already saved, don't overwrite
        end
        
        -- Save all work offset X,Y values
        for i = 0, 5 do
            local baseVar = 5221 + (i * 20)
            local storageBase = 411 + (i * 2)
            
            mc.mcCntlSetPoundVar(inst, storageBase, mc.mcCntlGetPoundVar(inst, baseVar))
            mc.mcCntlSetPoundVar(inst, storageBase + 1, mc.mcCntlGetPoundVar(inst, baseVar + 1))
        end
        
        -- Set flag
        mc.mcCntlSetPoundVar(inst, 410, 1)
    end
    
    -- Apply offset to all work coordinates
    local function applyOffset(inst, xOffset, yOffset)
        for i = 0, 5 do
            local baseVar = 5221 + (i * 20)
            local currentX = mc.mcCntlGetPoundVar(inst, baseVar)
            local currentY = mc.mcCntlGetPoundVar(inst, baseVar + 1)
            
            mc.mcCntlSetPoundVar(inst, baseVar, currentX - xOffset)
            mc.mcCntlSetPoundVar(inst, baseVar + 1, currentY - yOffset)
        end
    end
    
    -- Restore original work offsets from saved values
    local function restoreOriginalOffsets(inst)
        -- Only restore if we have saved values
        if mc.mcCntlGetPoundVar(inst, 410) ~= 1 then
            return  -- Nothing to restore
        end
        
        -- Restore from saved values
        for i = 0, 5 do
            local baseVar = 5221 + (i * 20)
            local storageBase = 411 + (i * 2)
            
            mc.mcCntlSetPoundVar(inst, baseVar, mc.mcCntlGetPoundVar(inst, storageBase))
            mc.mcCntlSetPoundVar(inst, baseVar + 1, mc.mcCntlGetPoundVar(inst, storageBase + 1))
        end
        
        -- Clear flag
        mc.mcCntlSetPoundVar(inst, 410, 0)
    end
    
    -- ============================================
    -- VIRTUAL TOOL DEPLOYMENT FUNCTIONS
    -- ============================================
    
    local function deployProbe()
        local probeDownHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
        
        -- CRITICAL: Check if another virtual tool is active
        local currentTool = mc.mcToolGetCurrent(inst)
        if currentTool >= 90 and currentTool <= 99 and currentTool ~= 90 then
            mc.mcCntlSetLastError(inst, "ERROR: Must retract T" .. currentTool .. " before deploying probe")
            return false
        end
        
        -- Stop spindle if running
        if mc.mcSpindleGetCommandRPM(inst) > 0 then
            mc.mcSpindleSetDirection(inst, 0)
        end
        
        -- Move to safe Z and deploy probe
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z0")
        mc.mcSignalSetState(probeDownHandle, 1)
        
        -- Set tool
        mc.mcToolSetCurrent(inst, 90)
        mc.mcCntlSetPoundVar(inst, 350, 1)  -- Virtual tool active
        
        -- Apply probe offsets with recovery protection
        local xOffset = mc.mcCntlGetPoundVar(inst, 301)
        local yOffset = mc.mcCntlGetPoundVar(inst, 302)
        
        -- If offsets were previously saved/shifted, restore first
        if mc.mcCntlGetPoundVar(inst, 410) == 1 then
            restoreOriginalOffsets(inst)
        end
        
        saveOriginalOffsets(inst)  -- Save before modifying
        applyOffset(inst, xOffset, yOffset)
        
        -- Check if probe has been measured
        local probeHeight = mc.mcToolGetData(inst, mc.MTOOL_MILL_HEIGHT, 90)
        if type(probeHeight) ~= "number" or probeHeight < -1e300 then
            mc.mcCntlSetLastError(inst, "T90 Probe deployed - use 'Measure Tool' button if needed")
        end
        
        -- Apply height offset
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        mc.mcCntlGcodeExecuteWait(inst, "G43 H90")
        
        return true
    end
    
    local function deployLaser()
        local laserDownHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
        
        -- CRITICAL: Check if another virtual tool is active
        local currentTool = mc.mcToolGetCurrent(inst)
        if currentTool >= 90 and currentTool <= 99 and currentTool ~= 91 then
            mc.mcCntlSetLastError(inst, "ERROR: Must retract T" .. currentTool .. " before deploying laser")
            return false
        end
        
        -- Stop spindle if running
        if mc.mcSpindleGetCommandRPM(inst) > 0 then
            mc.mcSpindleSetDirection(inst, 0)
        end
        
        -- Move to safe Z and activate laser
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z0")
        mc.mcSignalSetState(laserDownHandle, 1)
        
        -- Set tool
        mc.mcToolSetCurrent(inst, 91)
        mc.mcCntlSetPoundVar(inst, 350, 1)  -- Virtual tool active
        
        -- Apply laser offsets with recovery protection
        local xOffset = mc.mcCntlGetPoundVar(inst, 318)
        local yOffset = mc.mcCntlGetPoundVar(inst, 319)
        
        -- If offsets were previously saved/shifted, restore first
        if mc.mcCntlGetPoundVar(inst, 410) == 1 then
            restoreOriginalOffsets(inst)
        end
        
        saveOriginalOffsets(inst)  -- Save before modifying
        applyOffset(inst, xOffset, yOffset)
        
        -- Check if laser has been measured
        local laserHeight = mc.mcToolGetData(inst, mc.MTOOL_MILL_HEIGHT, 91)
        if type(laserHeight) ~= "number" or laserHeight < -1e300 then
            mc.mcCntlSetLastError(inst, "T91 Laser deployed - use 'Measure Tool' button if needed")
        end
        
        -- Apply height offset
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        mc.mcCntlGcodeExecuteWait(inst, "G43 H91")
        
        return true
    end
    
    local function retractProbe()
        local probeDownHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
        
        -- Move to safe Z
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z0")
        
        -- Restore work offsets
        restoreOriginalOffsets(inst)
        
        -- Retract probe
        mc.mcSignalSetState(probeDownHandle, 0)
        
        -- Clear tool
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        mc.mcCntlSetPoundVar(inst, 350, 0)  -- Clear virtual tool flag
        mc.mcToolSetCurrent(inst, 0)
    end
    
    local function retractLaser()
        local laserDownHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
        
        -- Move to safe Z
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z0")
        
        -- Restore work offsets
        restoreOriginalOffsets(inst)
        
        -- Turn off laser
        mc.mcSignalSetState(laserDownHandle, 0)
        
        -- Clear tool
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        mc.mcCntlSetPoundVar(inst, 350, 0)  -- Clear virtual tool flag
        mc.mcToolSetCurrent(inst, 0)
    end
    
    -- ============================================
    -- PHYSICAL TOOL RETURN FOR VIRTUAL TOOLS
    -- ============================================
    
    local function returnPhysicalToolForVirtual(toolNum)
        local TOOL_CHANGE_Z = mc.mcCntlGetPoundVar(inst, 308) or -6.5
        local PULLOUT_DISTANCE = mc.mcCntlGetPoundVar(inst, 309) or 1.75
        local APPROACH_FEED = mc.mcCntlGetPoundVar(inst, 310) or 200
        
        local x = mc.mcToolGetDataExDbl(inst, toolNum, "XToolChange") or 0
        local y = mc.mcToolGetDataExDbl(inst, toolNum, "YToolChange") or 0
        local z = mc.mcToolGetDataExDbl(inst, toolNum, "ZToolChange") or 0
        
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z0")
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f Y%.4f", x, y - PULLOUT_DISTANCE))
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G1 Z%.4f F%.1f", z, APPROACH_FEED))
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G1 Y%.4f F%.1f", y, APPROACH_FEED))
        
        local toolReleaseHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        mc.mcCntlSetPoundVar(inst, 498, 1)
        mc.mcSignalSetState(toolReleaseHandle, 1)
        mc.mcCntlSetPoundVar(inst, 498, 0)
        
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Z%.4f", TOOL_CHANGE_Z))
        
        mc.mcCntlSetPoundVar(inst, 498, 1)
        mc.mcSignalSetState(toolReleaseHandle, 0)
        mc.mcCntlSetPoundVar(inst, 498, 0)
    end
    
    -- ============================================
    -- MAIN M6 LOGIC STARTS HERE
    -- ============================================
    
    local toolPresentHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    local requestedTool = mc.mcToolGetSelected(inst)
    local currentTool = mc.mcToolGetCurrent(inst)
    
    -- Handle virtual tools (T90-T99)
    if requestedTool >= 90 and requestedTool <= 99 then
        -- If physical tool is loaded, return it first
        if currentTool > 0 and currentTool < 90 then
            mc.mcCntlSetPoundVar(inst, 351, currentTool)
            
            if mc.mcSignalGetState(toolPresentHandle) == 1 then
                returnPhysicalToolForVirtual(currentTool)
                mc.mcToolSetCurrent(inst, 0)
            end
        elseif currentTool >= 90 and currentTool <= 99 and currentTool ~= requestedTool then
            -- Different virtual tool active - retract it first
            if currentTool == 90 then
                retractProbe()
            elseif currentTool == 91 then
                retractLaser()
            end
        end
        
        -- Deploy requested virtual tool
        if requestedTool == 90 then
            if not deployProbe() then
                return
            end
        elseif requestedTool == 91 then
            deployLaser()
        else
            mc.mcCntlSetLastError(inst, string.format("Virtual tool T%d not implemented", requestedTool))
        end
        
        return
    end
    
    -- If switching FROM virtual TO physical
    if currentTool >= 90 and currentTool <= 99 and requestedTool < 90 then
        if currentTool == 90 then
            retractProbe()
        elseif currentTool == 91 then
            retractLaser()
        end
        
        currentTool = 0
    end
    
    -- ============================================
    -- PHYSICAL TOOL CHANGE LOGIC
    -- ============================================
    
    local SAFE_Z = 0
    local TOOL_CHANGE_Z = mc.mcCntlGetPoundVar(inst, 308) or -6.5
    local PULLOUT_DISTANCE = mc.mcCntlGetPoundVar(inst, 309) or 1.75
    local APPROACH_FEED = mc.mcCntlGetPoundVar(inst, 310) or 200
    
    local PROBE_X = mc.mcCntlGetPoundVar(inst, 311) or 2.4
    local PROBE_Y = mc.mcCntlGetPoundVar(inst, 312) or 12.65
    
    local MAX_PROBE_DEPTH = mc.mcCntlGetPoundVar(inst, 314) or -9.0
    local FAST_FEED = mc.mcCntlGetPoundVar(inst, 315) or 75
    local SLOW_FEED = mc.mcCntlGetPoundVar(inst, 316) or 3
    local RETRACT = mc.mcCntlGetPoundVar(inst, 317) or 0.1
    
    local function validateProbeParams()
        if MAX_PROBE_DEPTH >= SAFE_Z then
            mc.mcCntlSetLastError(inst, "ERROR: Max probe depth must be negative")
            return false
        end
        if FAST_FEED <= 0 or SLOW_FEED <= 0 then
            mc.mcCntlSetLastError(inst, "ERROR: Probe feeds must be positive")
            return false
        end
        return true
    end
    
    if not validateProbeParams() then
        return
    end
    
    local handles = {
        toolRelease = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2),
        dustBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3),
        lowAir = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT6),
        dustBootUp = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT7),
        clampOpen = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT16),
        toolPresent = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17),
        laserDown = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1),
        probeDown = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7),
        probe = mc.mcSignalGetHandle(inst, mc.ISIG_PROBE)
    }
    
    -- If same tool requested, just update height offset
    if requestedTool == currentTool then
        if currentTool > 0 then
            mc.mcCntlGcodeExecuteWait(inst, "G43 H" .. currentTool)
        else
            mc.mcCntlGcodeExecuteWait(inst, "G49")
        end
        return
    end
    
    local function waitForSignal(handle, state, timeout)
        local checks = 0
        while checks < timeout * 5 do
            if mc.mcSignalGetState(handle) == state then return true end
            mc.mcCntlGcodeExecuteWait(inst, "G4 P0.2")
            checks = checks + 1
        end
        return false
    end
    
    local function getToolPosition(toolNum)
        if toolNum < 1 or toolNum > 99 then
            mc.mcCntlSetLastError(inst, "ERROR: Invalid tool " .. toolNum)
            return nil
        end
        
        if toolNum >= 90 and toolNum <= 99 then
            mc.mcCntlSetLastError(inst, "ERROR: Virtual tool " .. toolNum .. " has no physical position")
            return nil
        end
        
        local x = mc.mcToolGetDataExDbl(inst, toolNum, "XToolChange") or 0
        local y = mc.mcToolGetDataExDbl(inst, toolNum, "YToolChange") or 0
        local z = mc.mcToolGetDataExDbl(inst, toolNum, "ZToolChange") or 0
        
        return {X = x, Y = y, Z = z}
    end
    
    -- Validate tool numbers
    if requestedTool < 0 or requestedTool > 99 then
        mc.mcCntlSetLastError(inst, "ERROR: Invalid tool " .. requestedTool)
        return
    end
    
    if requestedTool >= 90 and requestedTool <= 99 then
        mc.mcCntlSetLastError(inst, "ERROR: Virtual tool T" .. requestedTool .. " should have been handled earlier")
        return
    end
    
    local toolPos = nil
    if requestedTool > 0 then
        toolPos = getToolPosition(requestedTool)
        if not toolPos then
            return
        end
    end
    
    -- Safety checks
    if mc.mcSpindleGetCommandRPM(inst) > 0 then
        mc.mcSpindleSetDirection(inst, 0)
    end
    
    mc.mcSignalSetState(handles.laserDown, 0)
    mc.mcSignalSetState(handles.probeDown, 0)
    
    if mc.mcSignalGetState(handles.lowAir) == 1 then
        mc.mcCntlSetLastError(inst, "ERROR: Low air pressure")
        return
    end
    
    if not (mc.mcAxisIsHomed(inst, mc.X_AXIS) and mc.mcAxisIsHomed(inst, mc.Y_AXIS) and mc.mcAxisIsHomed(inst, mc.Z_AXIS)) then
        mc.mcCntlSetLastError(inst, "ERROR: Machine must be homed")
        return
    end
    
    -- Save current state
    local saved = {
        fro = mc.mcCntlGetFRO(inst),
        workOffset = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14),
        feedRate = mc.mcCntlGetPoundVar(inst, mc.SV_FEEDRATE),
        toolComp = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_8),
        dustBoot = mc.mcSignalGetState(handles.dustBoot),
        plane = mc.mcCntlGetPoundVar(inst, 4002),
        absInc = mc.mcCntlGetPoundVar(inst, 4003),
        feedMode = mc.mcCntlGetPoundVar(inst, 4001),
    }
    
    mc.mcCntlSetFRO(inst, 100)
    mc.mcSignalSetState(handles.dustBoot, 0)
    
    if not waitForSignal(handles.dustBootUp, 1, 2) then
        mc.mcCntlSetLastError(inst, "ERROR: Dust boot failed to raise")
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    mc.mcCntlGcodeExecuteWait(inst, "G20 G90 G94 G40 G17")
    mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
    
    -- Return current tool if needed
    local currentPos = nil
    if currentTool > 0 and currentTool < 90 then
        currentPos = getToolPosition(currentTool)
        if not currentPos then
            return
        end
    end
    
    if currentTool > 0 and currentTool < 90 and mc.mcSignalGetState(handles.toolPresent) == 1 then
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
        -- Direct move to tool position (no probe X detour)
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f Y%.4f", 
            currentPos.X, currentPos.Y - PULLOUT_DISTANCE))
        mc.mcCntlGcodeExecuteWait(inst, "G53 G1 Z" .. currentPos.Z .. " F" .. APPROACH_FEED)
        
        mc.mcCntlGcodeExecuteWait(inst, "G53 G1 Y" .. currentPos.Y .. " F" .. APPROACH_FEED)
        
        mc.mcCntlSetPoundVar(inst, 498, 1)
        mc.mcSignalSetState(handles.toolRelease, 1)
        
        if not waitForSignal(handles.clampOpen, 1, 5) then
            mc.mcCntlSetPoundVar(inst, 498, 0)
            mc.mcCntlSetLastError(inst, "ERROR: Clamp failed to open")
            mc.mcSignalSetState(handles.toolRelease, 0)
            mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
            mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
            mc.mcCntlSetFRO(inst, saved.fro)
            return
        end
        
        local raiseZ = (requestedTool > 0) and TOOL_CHANGE_Z or SAFE_Z
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. raiseZ)
        
        mc.mcCntlSetPoundVar(inst, 498, 0)
        
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        
        if requestedTool == 0 then
            mc.mcSignalSetState(handles.toolRelease, 0)
            mc.mcCntlSetPoundVar(inst, 498, 0)
        end
    elseif currentTool > 0 and currentTool < 90 then
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
    end
    
    -- If requested tool is T0, we're done
    if requestedTool == 0 then
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        
        local restoreGcode = "G94\n"
        if saved.workOffset >= 54 and saved.workOffset <= 59.3 then
            restoreGcode = restoreGcode .. "G" .. saved.workOffset .. "\n"
        end
        if saved.feedRate and saved.feedRate > 0 and saved.feedRate < 1e308 then
            restoreGcode = restoreGcode .. "F" .. saved.feedRate .. "\n"
        else
            restoreGcode = restoreGcode .. "F100\n"
        end
        mc.mcCntlGcodeExecuteWait(inst, restoreGcode)
        
        return
    end
    
    -- Check spindle is empty
    if mc.mcSignalGetState(handles.toolPresent) == 1 then
        mc.mcCntlGcodeExecuteWait(inst, "G4 P0.5")
        if mc.mcSignalGetState(handles.toolPresent) == 1 then
            mc.mcCntlSetLastError(inst, "ERROR: Spindle not empty")
            mc.mcSignalSetState(handles.toolRelease, 0)
            mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
            mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
            mc.mcCntlSetFRO(inst, saved.fro)
            return
        end
    end
    
    -- Move to new tool position
    if currentTool > 0 and currentTool < 90 then
        -- Tool-to-tool swap: move Y first for safety, then X
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Y" .. toolPos.Y)
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 X" .. toolPos.X)
    else
        -- Coming from no tool: direct XY move to new tool
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f Y%.4f", toolPos.X, toolPos.Y))
    end
    
    -- Open clamp if picking up from T0
    if currentTool == 0 then
        mc.mcCntlSetPoundVar(inst, 498, 1)
        mc.mcSignalSetState(handles.toolRelease, 1)
        
        if not waitForSignal(handles.clampOpen, 1, 5) then
            mc.mcCntlSetPoundVar(inst, 498, 0)
            mc.mcCntlSetLastError(inst, "ERROR: Clamp failed to open for pickup")
            mc.mcSignalSetState(handles.toolRelease, 0)
            mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
            mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
            mc.mcCntlSetFRO(inst, saved.fro)
            return
        end
        mc.mcCntlSetPoundVar(inst, 498, 0)
    end
    
    -- Check spindle not running
    local spindleOn = mc.mcSignalGetHandle(inst, mc.OSIG_SPINDLEON)
    if spindleOn and mc.mcSignalGetState(spindleOn) == 1 then
        mc.mcCntlSetLastError(inst, "ERROR: Spindle running - cannot grab tool")
        mc.mcSignalSetState(handles.toolRelease, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    -- Grab tool
    mc.mcCntlGcodeExecuteWait(inst, "G53 G1 Z" .. toolPos.Z .. " F" .. APPROACH_FEED)
    mc.mcCntlGcodeExecuteWait(inst, "G0")
    
    mc.mcCntlSetPoundVar(inst, 498, 1)
    mc.mcSignalSetState(handles.toolRelease, 0)
    mc.mcCntlGcodeExecuteWait(inst, "G4 P.5")
    mc.mcCntlSetPoundVar(inst, 498, 0)
    
    -- Verify tool grabbed
    if mc.mcSignalGetState(handles.toolPresent) == 0 then
        mc.mcCntlSetLastError(inst, "ERROR: Tool not detected after clamp")
        mc.mcCntlSetPoundVar(inst, 498, 1)
        mc.mcSignalSetState(handles.toolRelease, 1)
        mc.mcCntlSetPoundVar(inst, 498, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    -- Pull out and up
    mc.mcCntlGcodeExecuteWait(inst, "G53 G1 Y" .. (toolPos.Y - PULLOUT_DISTANCE) .. " F" .. APPROACH_FEED)
    
    mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
    
    if mc.mcSignalGetState(handles.toolPresent) == 0 then
        mc.mcCntlSetLastError(inst, "ERROR: Tool lost during pickup")
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    mc.mcToolSetCurrent(inst, requestedTool)
    
    mc.mcCntlGcodeExecuteWait(inst, "G49")
    mc.mcCntlGcodeExecuteWait(inst, "G43 H" .. requestedTool)
    
    -- Skip measurement for Tool 1
    if requestedTool == 1 then
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        
        local restoreGcode = ""
        
        if saved.plane == 17 then
            restoreGcode = restoreGcode .. "G17\n"
        elseif saved.plane == 18 then
            restoreGcode = restoreGcode .. "G18\n"
        elseif saved.plane == 19 then
            restoreGcode = restoreGcode .. "G19\n"
        end
        
        if saved.absInc == 90 then
            restoreGcode = restoreGcode .. "G90\n"
        elseif saved.absInc == 91 then
            restoreGcode = restoreGcode .. "G91\n"
        end
        
        restoreGcode = restoreGcode .. "G94\n"
        
        if saved.workOffset >= 54 and saved.workOffset <= 59.3 then
            restoreGcode = restoreGcode .. "G" .. saved.workOffset .. "\n"
        end
        
        if saved.toolComp == 40 then
            restoreGcode = restoreGcode .. "G40\n"
        elseif saved.toolComp == 41 then
            restoreGcode = restoreGcode .. "G41\n"
        elseif saved.toolComp == 42 then
            restoreGcode = restoreGcode .. "G42\n"
        end
        
        if saved.feedRate and saved.feedRate > 0 and saved.feedRate < 1e308 then
            restoreGcode = restoreGcode .. "F" .. saved.feedRate .. "\n"
        else
            restoreGcode = restoreGcode .. "F100\n"
        end
        
        mc.mcCntlGcodeExecuteWait(inst, restoreGcode)
        
        mc.mcCntlSetLastError(inst, "T1 loaded (no measurement)")
        
        mc.mcCntlSetPoundVar(inst, 498, 0)
        return
    end
    
    -- ============================================
    -- TOOL HEIGHT MEASUREMENT
    -- ============================================
    
    if mc.mcSignalGetState(handles.probe) == 1 then
        mc.mcCntlSetLastError(inst, "ERROR: Probe already triggered")
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    -- Move to probe station in single XY move
    local rc = mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f Y%.4f", PROBE_X, PROBE_Y))
    if rc ~= mc.MERROR_NOERROR then
        mc.mcCntlSetLastError(inst, "ERROR: Failed to move to probe position")
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    -- Fast probe
    rc = mc.mcCntlGcodeExecuteWait(inst, "G53 G31 Z" .. MAX_PROBE_DEPTH .. " F" .. FAST_FEED)
    if rc ~= mc.MERROR_NOERROR then
        mc.mcCntlSetLastError(inst, "ERROR: Fast probe failed")
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    local currentZ = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)
    if currentZ <= (MAX_PROBE_DEPTH + 0.1) then
        mc.mcCntlSetLastError(inst, "ERROR: No probe contact within travel distance")
        mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. (currentZ + RETRACT))
    
    -- Slow probe
    mc.mcCntlGcodeExecuteWait(inst, "G53 G31 Z" .. MAX_PROBE_DEPTH .. " F" .. SLOW_FEED)
    
    mc.mcCntlGcodeExecuteWait(inst, "G53 G0 Z" .. SAFE_Z)
    
    -- Calculate and save tool height
    local finalZ = mc.mcCntlGetPoundVar(inst, 5073)
    if finalZ == 0 then
        mc.mcCntlSetLastError(inst, "ERROR: Could not read probe position")
        mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
        mc.mcCntlSetFRO(inst, saved.fro)
        return
    end
    
    local toolHeight = finalZ - WORK_SURFACE_Z
    
    mc.mcToolSetData(inst, mc.MTOOL_MILL_HEIGHT, requestedTool, toolHeight)
    
    mc.mcCntlGcodeExecuteWait(inst, "G49")
    mc.mcCntlGcodeExecuteWait(inst, "G43 H" .. requestedTool)
    
    -- ============================================
    -- RESTORE STATE AND FINISH
    -- ============================================
    
    mc.mcSignalSetState(handles.dustBoot, saved.dustBoot)
    mc.mcCntlSetFRO(inst, saved.fro)
    
    local restoreGcode = ""
    
    if saved.plane == 17 then
        restoreGcode = restoreGcode .. "G17\n"
    elseif saved.plane == 18 then
        restoreGcode = restoreGcode .. "G18\n"
    elseif saved.plane == 19 then
        restoreGcode = restoreGcode .. "G19\n"
    end
    
    if saved.absInc == 90 then
        restoreGcode = restoreGcode .. "G90\n"
    elseif saved.absInc == 91 then
        restoreGcode = restoreGcode .. "G91\n"
    end
    
    restoreGcode = restoreGcode .. "G94\n"
    
    if saved.workOffset >= 54 and saved.workOffset <= 59.3 then
        restoreGcode = restoreGcode .. "G" .. saved.workOffset .. "\n"
    end
    
    if saved.toolComp == 40 then
        restoreGcode = restoreGcode .. "G40\n"
    elseif saved.toolComp == 41 then
        restoreGcode = restoreGcode .. "G41\n"
    elseif saved.toolComp == 42 then
        restoreGcode = restoreGcode .. "G42\n"
    end
    
    if saved.feedRate and saved.feedRate > 0 and saved.feedRate < 1e308 then
        restoreGcode = restoreGcode .. "F" .. saved.feedRate .. "\n"
    else
        restoreGcode = restoreGcode .. "F100\n"
    end
    
    mc.mcCntlGcodeExecuteWait(inst, restoreGcode)
    
    mc.mcCntlSetLastError(inst, string.format("T%d measured: %.3f\"", 
                                             requestedTool, toolHeight))
    
    mc.mcCntlSetPoundVar(inst, 498, 0)
end

if (mc.mcInEditor() == 1) then m6() end
