pageId = 0
screenId = 0
testcount = 0
machState = 0
machStateOld = -1
machEnabled = 0
machWasEnabled = 0
inst = mc.mcGetInstance()
Tframe = nil --TouchFrame handle

--mobdebug = require('mobdebug')
--mobdebug.onexit = mobdebug.done
--mobdebug.start() -- This line is to start the debug Process Comment out for no debuging

-- ===== Base libs =====
local function safeRequire(name)
  local ok, mod = pcall(require, name)
  if not ok then
    mc.mcCntlSetLastError(inst, ("[Degraded Mode] Missing lib '%s'"):format(name))
    return nil
  end
  return mod
end

_G.SystemLib = _G.SystemLib or safeRequire("SystemLib")
_G.ToolLib   = _G.ToolLib   or safeRequire("ToolLib")
_G.AuxLib    = _G.AuxLib    or safeRequire("AuxLib")
_G.UILib     = _G.UILib     or safeRequire("UILib")

if SystemLib and SystemLib.Log then SystemLib.Log(inst, "ScreenLoad libs loaded", "INFO") end

-- Initialize libs that support init/update
if ToolLib   and ToolLib.Init   then pcall(ToolLib.Init,   inst) end  -- Tool outputs virtual/physical management

-- AuxLib interlocks (so devices can see M6/virtual/rotation in their ctx)
if AuxLib and AuxLib.BindInterlocks then
  AuxLib.BindInterlocks({
    virtualActive = function() return (tonumber(SystemLib and SystemLib.PoundVarGet and SystemLib.PoundVarGet(inst, 406) or mc.mcCntlGetPoundVar(inst, 406)) or 0) >= 90 and 1 or 0 end,
    rotationActive = function() return (SystemLib and SystemLib.G68Active and select(1, SystemLib.G68Active(inst))) and 1 or 0 end,
    m6Active = function() return (tonumber(SystemLib and SystemLib.PoundVarGet and SystemLib.PoundVarGet(inst, 499) or mc.mcCntlGetPoundVar(inst, 499)) == 1) and 1 or 0 end,
  })
end  -- AuxLib.BindInterlocks docs

-- === AuxLib: device registration ===
-- NOTE: Adjust pv=... numbers if your PV map differs.
if AuxLib and AuxLib.Register then
  -- Dust collector: AUTO follows spindle/inCycle, clears at M30, clears manual on spindle start
  AuxLib.Register("dust", {
    outputs = { main = "OSIG_OUTPUT4" },
    pv      = { auto = 400, target = 404, override = 405 }, -- adjust if needed
    auto    = function(ctx) return (ctx.spindle == 1 or ctx.inCycle == 1) and 1 or 0 end,
    events  = { offOnM30 = true, clearManualOnSpindleRise = true },
  })

  -- Dust boot: force UP during M6 or when a virtual tool is active
  AuxLib.Register("boot", {
    outputs = { main = "OSIG_OUTPUT3" },
    pv      = { auto = 402, target = 403 },                  -- adjust if needed
    safety  = function(ctx) if ctx.m6 == 1 or ctx.virt == 1 then return 0 end end,
  })

  -- Zone vacs (example split front/rear)
  AuxLib.Register("vacRear",  { outputs = { main = "OSIG_OUTPUT5" }, pv = { auto = 401, target = 411 } })
  AuxLib.Register("vacFront", { outputs = { main = "OSIG_OUTPUT6" }, pv = { auto = 401, target = 412 } })
end


---------------------------------------------------------------
-- Signal Library
---------------------------------------------------------------
SigLib = {
[mc.OSIG_MACHINE_ENABLED] = function (state)
    machEnabled = state;
    ButtonEnable()

  if state == 0 then
    -- On disable: ensure any virtual tool is safe
    if ToolLib and ToolLib.RetractVirtual then pcall(ToolLib.RetractVirtual, inst) end  -- retract and restore offsets
    mc.mcCntlSetLastError(inst, "Disable: virtual tools secured")
  else
    -- On enable: refresh simple UI bits, leave rotation/H-logic to ToolLib flows
    if _G.PopulateTools then pcall(_G.PopulateTools) end  -- same as your old enable-refresh
  end
end,

[mc.OSIG_SPINDLEON] = function (state)
  -- Edge-drive AuxLib events for devices that react to spindle transitions
  if not AuxLib or not AuxLib.OnEvent then return end
  if state == 1 then AuxLib.OnEvent(inst, "spindle_rise") else AuxLib.OnEvent(inst, "spindle_fall") end
end, 
-- AuxLib.OnEvent supports "spindle_rise/fall"

[mc.ISIG_INPUT0] = function (state)
    
end,

[mc.ISIG_INPUT1] = function (state) -- this is an example for a condition in the signal table.
   -- if (state == 1) then   
--        CycleStart()
--    --else
--        --mc.mcCntlFeedHold (0)
--    end

end,

[mc.OSIG_JOG_CONT] = function (state)
    if( state == 1) then 
       scr.SetProperty('labJogMode', 'Label', 'Continuous');
       scr.SetProperty('txtJogInc', 'Bg Color', '#C0C0C0');--Light Grey
       scr.SetProperty('txtJogInc', 'Fg Color', '#808080');--Dark Grey
    end
end,

[mc.OSIG_JOG_INC] = function (state)
    if( state == 1) then
        scr.SetProperty('labJogMode', 'Label', 'Incremental');
        scr.SetProperty('txtJogInc', 'Bg Color', '#FFFFFF');--White    
        scr.SetProperty('txtJogInc', 'Fg Color', '#000000');--Black
   end
end,

[mc.OSIG_JOG_MPG] = function (state)
    if( state == 1) then
        scr.SetProperty('labJogMode', 'Label', '');
        scr.SetProperty('txtJogInc', 'Bg Color', '#C0C0C0');--Light Grey
        scr.SetProperty('txtJogInc', 'Fg Color', '#808080');--Dark Grey
        --add the bits to grey jog buttons becasue buttons can't be MPGs
    end
end
}
---------------------------------------------------------------
-- Message Library
---------------------------------------------------------------
-- More messages can be found in the Message Script section of the scripting manual
--or by typing "mc.MSG_" scroll through the list to see if one of the messages fits your use case
MsgLib = {
	[mc.MSG_REG_CHANGED] = function (param1, param2)
		-- param1 in this case is the handle of the register that has changed
		-- For information on handles/registers please reference our scripting manual
		--local value = mc.mcRegGetValue(param1)
		--local info = mc.mcRegGetInfo(param1)
	end
}
---------------------------------------------------------------
-- Keyboard Inputs Toggle() function. Updated 5-16-16
---------------------------------------------------------------
function KeyboardInputsToggle()
	local iReg = mc.mcIoGetHandle (inst, "Keyboard/Enable")
    local iReg2 = mc.mcIoGetHandle (inst, "Keyboard/EnableKeyboardJog")
	
	if (iReg ~= nil) and (iReg2 ~= nil) then
        local val = mc.mcIoGetState(iReg);
		if (val == 1) then
            mc.mcIoSetState(iReg, 0);
            mc.mcIoSetState(iReg2, 0);
			scr.SetProperty('btnKeyboardJog', 'Bg Color', '');
            scr.SetProperty('btnKeyboardJog', 'Label', 'Keyboard\nInputs Enable');
		else
            mc.mcIoSetState(iReg, 1);
            mc.mcIoSetState(iReg2, 1);
            scr.SetProperty('btnKeyboardJog', 'Bg Color', '#00FF00');
            scr.SetProperty('btnKeyboardJog', 'Label', 'Keyboard\nInputs Disable');
        end
	end
end
---------------------------------------------------------------
-- Remember Position function.
---------------------------------------------------------------
function RememberPosition()
    local pos = mc.mcAxisGetMachinePos(inst, 0) -- Get current X (0) Machine Coordinates
    mc.mcProfileWriteString(inst, "RememberPos", "X", string.format (pos)) --Create a register and write the machine coordinates to it
    local pos = mc.mcAxisGetMachinePos(inst, 1) -- Get current Y (1) Machine Coordinates
    mc.mcProfileWriteString(inst, "RememberPos", "Y", string.format (pos)) --Create a register and write the machine coordinates to it
    local pos = mc.mcAxisGetMachinePos(inst, 2) -- Get current Z (2) Machine Coordinates
    mc.mcProfileWriteString(inst, "RememberPos", "Z", string.format (pos)) --Create a register and write the machine coordinates to it
end
---------------------------------------------------------------
-- Return to Position function.
---------------------------------------------------------------
function ReturnToPosition()
    local xval = mc.mcProfileGetString(inst, "RememberPos", "X", "NotFound") -- Get the register Value
    local yval = mc.mcProfileGetString(inst, "RememberPos", "Y", "NotFound") -- Get the register Value
    local zval = mc.mcProfileGetString(inst, "RememberPos", "Z", "NotFound") -- Get the register Value
    
    if(xval == "NotFound")then -- check to see if the register is found
        wx.wxMessageBox('Register xval does not exist.\nYou must remember a postion before you can return to it.'); -- If the register does not exist tell us in a message box
    elseif (yval == "NotFound")then -- check to see if the register is found
        wx.wxMessageBox('Register yval does not exist.\nYou must remember a postion before you can return to it.'); -- If the register does not exist tell us in a message box
    elseif (zval == "NotFound")then -- check to see if the register is found
        wx.wxMessageBox('Register zval does not exist.\nYou must remember a postion before you can return to it.'); -- If the register does not exist tell us in a message box
    else
        mc.mcCntlMdiExecute(inst, "G00 G53 Z0.0000 \n G00 G53 X" .. xval .. "\n G00 G53 Y" .. yval .. "\n G00 G53 Z" .. zval)
    end
end
---------------------------------------------------------------
-- Spin CW function.
---------------------------------------------------------------
function SpinCW()
    local sigh = mc.mcSignalGetHandle(inst, mc.OSIG_SPINDLEON);
    local sigState = mc.mcSignalGetState(sigh);
    
    if (sigState == 1) then 
        mc.mcSpindleSetDirection(inst, 0);
    else 
        mc.mcSpindleSetDirection(inst, 1);
    end
end
---------------------------------------------------------------
-- Spin CCW function.
---------------------------------------------------------------
function SpinCCW()
    local sigh = mc.mcSignalGetHandle(inst, mc.OSIG_SPINDLEON);
    local sigState = mc.mcSignalGetState(sigh);
    
    if (sigState == 1) then 
        mc.mcSpindleSetDirection(inst, 0);
    else 
        mc.mcSpindleSetDirection(inst, -1);
    end
end
---------------------------------------------------------------
-- Open Docs function.
---------------------------------------------------------------
function OpenDocs()
    local major, minor = wx.wxGetOsVersion()
    local dir = mc.mcCntlGetMachDir(inst);
    local cmd = "explorer.exe /open," .. dir .. "\\Docs\\"
    if(minor <= 5) then -- Xp we don't need the /open
        cmd = "explorer.exe ," .. dir .. "\\Docs\\"
    end
	os.execute(cmd)
    scr.RefreshScreen(250); -- Windows 7 and 8 seem to require the screen to be refreshed.  
end
---------------------------------------------------------------
-- Cycle Stop function.
---------------------------------------------------------------
function CycleStop()
mc.mcCntlCycleStop(inst);
mc.mcSpindleSetDirection(inst, 0);
mc.mcCntlSetLastError(inst, "Cycle Stopped");
	if(wait ~= nil) then
		wait = nil;
	end
end
---------------------------------------------------------------
-- Button Jog Mode Toggle() function.
---------------------------------------------------------------
function ButtonJogModeToggle()
    local cont = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_CONT);
    local jogcont = mc.mcSignalGetState(cont)
    local inc = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_INC);
    local joginc = mc.mcSignalGetState(inc)
    local mpg = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_MPG);
    local jogmpg = mc.mcSignalGetState(mpg)
    
    if (jogcont == 1) then
        mc.mcSignalSetState(cont, 0)
        mc.mcSignalSetState(inc, 1)
        mc.mcSignalSetState(mpg, 0)        
    else
        mc.mcSignalSetState(cont, 1)
        mc.mcSignalSetState(inc, 0)
        mc.mcSignalSetState(mpg, 0)
    end

end
---------------------------------------------------------------
-- Ref All Home() function.
---------------------------------------------------------------
function RefAllHome()
    mc.mcAxisDerefAll(inst)  --Just to turn off all ref leds
    mc.mcAxisHomeAll(inst)
    coroutine.yield() --yield coroutine so we can do the following after motion stops
    ----See ref all home button and plc script for coroutine.create and coroutine.resume
    wx.wxMessageBox('Referencing is complete')
end
---------------------------------------------------------------
-- Go To Work Zero() function.
---------------------------------------------------------------
function GoToWorkZero()
    mc.mcCntlMdiExecute(inst, "G00 X0 Y0")--Without Z moves
    --mc.mcCntlMdiExecute(inst, "G00 G53 Z0\nG00 X0 Y0 A0\nG00 Z0")--With Z moves
end
---------------------------------------------------------------
-- Cycle Start() function.
---------------------------------------------------------------
function CycleStart()	
	local rc
    local tab, rc = scr.GetProperty("MainTabs", "Current Tab")
    local tabG_Mdione, rc = scr.GetProperty("nbGCodeMDI1", "Current Tab")
	local tabG_Mditwo, rc = scr.GetProperty("nbGCodeMDI2", "Current Tab")
	local state = mc.mcCntlGetState(inst)
	--mc.mcCntlSetLastError(inst,"tab == " .. tostring(tab))
	
	if (state == mc.MC_STATE_MRUN_MACROH) then 
		mc.mcCntlCycleStart(inst)
	elseif ((tonumber(tab) == 0 and tonumber(tabG_Mdione) == 1)) then  
		scr.ExecMdi('mdi1')
	elseif ((tonumber(tab) == 5 and tonumber(tabG_Mditwo) == 1)) then  
		scr.ExecMdi('mdi2')
	else
		mc.mcCntlCycleStart(inst)    
	end
end
-------------------------------------------------------
--  Seconds to time Added 5-9-16
-------------------------------------------------------
--Converts decimal seconds to an HH:MM:SS.xx format
function SecondsToTime(seconds)
	if seconds == 0 then
		return "00:00:00.00"
	else
		local hours = string.format("%02.f", math.floor(seconds/3600))
		local mins = string.format("%02.f", math.floor((seconds/60) - (hours*60)))
		local secs = string.format("%04.2f",(seconds - (hours*3600) - (mins*60)))
		return hours .. ":" .. mins .. ":" .. secs
	end
end
---------------------------------------------------------------
-- Set Button Jog Mode to Cont.
---------------------------------------------------------------
local cont = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_CONT);
local jogcont = mc.mcSignalGetState(cont)
mc.mcSignalSetState(cont, 1)
-------------------------------------------------------
--  Decimal to Fractions
-------------------------------------------------------
function DecToFrac(axis)
	--Determine position to get and labels to set.
    local work = mc.mcAxisGetPos(inst, axis)
	local lab = string.format("lblFrac" .. tostring(axis))
	local labNum = string.format("lblFracNum" .. tostring(axis))
	local labDen = string.format("lblFracDen" .. tostring(axis))
    local sign = (" ")		--Use a blank space so we do not get any errors.
	
    if work < 0 then	--Change the sign to -
		sign = ("-")
	end
	
	work = math.abs (work)
	local remainder = math.fmod(work, .0625)

	if remainder >= .03125 then 	--Round up to the closest 1/16
		work = work + remainder
	else							--Round down to the closest 1/16
		work = work - remainder
	end

	local inches = math.floor(work / 1.000)
	local iremainder = work % 1.000
	local halves = math.floor(iremainder / .5000)
	local remainder = iremainder % .5000
	local quarters = math.floor(remainder / .2500)
	local remainder = remainder % .2500
	local eights = math.floor(remainder / .1250)
	local remainder = remainder % .1250
	local sixteens = math.floor(remainder / .0625)

	numar = 0	--Default to 0. The next if statement will change it if needed.
	denom = 0	--Default to 0. The next if statement will change it if needed.

	if sixteens > 0 then
		numar = math.floor(iremainder / .0625)
		denom = 16
	elseif eights > 0 then
		numar = math.floor(iremainder / .1250)
		denom = 8
	elseif quarters > 0 then
		numar = math.floor(iremainder / .2500)
		denom = 4
	elseif halves > 0 then
		numar = math.floor(iremainder / .5000)
		denom = 2
	end
	
    scr.SetProperty((lab), 'Label', (sign) .. tostring(inches))
	scr.SetProperty((labNum), 'Label', tostring(numar))
	scr.SetProperty((labDen), 'Label', "/" .. tostring(denom))
end
---------------------------------------------------------------
--Timer panel example
---------------------------------------------------------------
TimerPanel = wx.wxPanel (wx.NULL, wx.wxID_ANY, wx.wxDefaultPosition, wx.wxSize( 0,0 ) )
timer = wx.wxTimer(TimerPanel)
TimerPanel:Connect(wx.wxEVT_TIMER,
function (event)
    wx.wxMessageBox("Hello")
    timer:Stop()
end)
---------------------------------------------------------------
-- Load modules
---------------------------------------------------------------
--Master module
package.loaded.mcRegister = nil
mm = require "mcRegister"

--ErrorCheck module Added 11-4-16
package.loaded.mcErrorCheck = nil
mcErrorCheck = require "mcErrorCheck"

--Trace module
package.loaded.mcTrace = nil
mcTrace = require "mcTrace"

---------------------------------------------------------------
-- Get fixtue offset pound variables function Updated 5-16-16
---------------------------------------------------------------
function GetFixOffsetVars()
    local FixOffset = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14)
    local Pval = mc.mcCntlGetPoundVar(inst, mc.SV_BUFP)
    local FixNum, whole, frac

    if (FixOffset ~= 54.1) then --G54 through G59
        whole, frac = math.modf (FixOffset)
        FixNum = (whole - 53) 
        PoundVarX = ((mc.SV_FIXTURES_START - mc.SV_FIXTURES_INC) + (FixNum * mc.SV_FIXTURES_INC))
        CurrentFixture = string.format('G' .. tostring(FixOffset)) 
    else --G54.1 P1 through G54.1 P100
        FixNum = (Pval + 6)
        CurrentFixture = string.format('G54.1 P' .. tostring(Pval))
        if (Pval > 0) and (Pval < 51) then -- G54.1 P1 through G54.1 P50
            PoundVarX = ((mc.SV_FIXTURE_EXPAND - mc.SV_FIXTURES_INC) + (Pval * mc.SV_FIXTURES_INC))
        elseif (Pval > 50) and (Pval < 101) then -- G54.1 P51 through G54.1 P100
            PoundVarX = ((mc.SV_FIXTURE_EXPAND2 - mc.SV_FIXTURES_INC) + (Pval * mc.SV_FIXTURES_INC))	
        end
    end
PoundVarY = (PoundVarX + 1)
PoundVarZ = (PoundVarX + 2)
return PoundVarX, PoundVarY, PoundVarZ, FixNum, CurrentFixture
-------------------------------------------------------------------------------------------------------------------
--return information from the fixture offset function
-------------------------------------------------------------------------------------------------------------------
--PoundVar(Axis) returns the pound variable for the current fixture for that axis (not the pound variables value).
--CurrentFixture returned as a string (examples G54, G59, G54.1 P12).
--FixNum returns a simple number (1-106) for current fixture (examples G54 = 1, G59 = 6, G54.1 P1 = 7, etc).
-------------------------------------------------------------------------------------------------------------------
end
---------------------------------------------------------------
-- Button Enable function Updated 11-8-2015
---------------------------------------------------------------
function ButtonEnable() --This function enables or disables buttons associated with an axis if the axis is enabled or disabled.

    AxisTable = {
        [0] = 'X',
        [1] = 'Y',
        [2] = 'Z',
        [3] = 'A',
        [4] = 'B',
        [5] = 'C'}
        
    for Num, Axis in pairs (AxisTable) do -- for each paired Num (key) and Axis (value) in the Axis table
        local rc = mc.mcAxisIsEnabled(inst,(Num)) -- find out if the axis is enabled, returns a 1 or 0
        scr.SetProperty((string.format ('btnPos' .. Axis)), 'Enabled', tostring(rc)); --Turn the jog positive button on or off
        scr.SetProperty((string.format ('btnNeg' .. Axis)), 'Enabled', tostring(rc)); --Turn the jog negative button on or off
        scr.SetProperty((string.format ('btnZero' .. Axis)), 'Enabled', tostring(rc)); --Turn the zero axis button on or off
        scr.SetProperty((string.format ('btnRef' .. Axis)), 'Enabled', tostring(rc)); --Turn the reference button on or off
    end
    
end
--ButtonEnable()



-- ===== UI helpers (optional: call from button scripts) =====
_G.UI = _G.UI or {}

function UI.Device(deviceName, action)
  if AuxLib and AuxLib.Request then AuxLib.Request(inst, { device = tostring(deviceName), action = tostring(action or "manual.toggle") }) end
end  -- Unified AuxLib control surface

function UI.Virtual(toolNo)
  if not ToolLib then return end
  local n = tonumber(toolNo or 0) or 0
  if n >= 90 and ToolLib.DeployVirtual then ToolLib.DeployVirtual(inst, n) else if ToolLib.RetractVirtual then ToolLib.RetractVirtual(inst) end end
end  -- Deploy/retract via ToolLib

function UI.ToolChange(toolNo)
  local n = tonumber(toolNo or 0) or 0
  if n >= 90 then return UI.Virtual(n) end
  mc.mcCntlGcodeExecuteWait(inst, ("T%d M6"):format(n))
end

-- ===== Minimal tool preview + list (only if those controls exist) =====
local function ctrlExists(name, prop) local ok, _ = pcall(scr.GetProperty, name, prop or "Visible"); return ok end
local function UpdateToolPreview()
  if not ctrlExists("lblToolPreview", "Label") then return end
  local t = mc.mcToolGetCurrent(inst) or 0
  local d = (t > 0) and (mc.mcToolGetDesc(inst, t) or "") or "No Tool"
  scr.SetProperty("lblToolPreview", "Label", (t>0) and (("T%d - %s"):format(t,d)) or "T0 - No Tool")
end

if not _G.PopulateTools then
  function PopulateTools()
    if not ctrlExists("lstCurrentTool", "Strings") then return end
    _G.toolNumbers = { 0 }; local items = { "0 - No Tool" }
    for t = 1, 99 do local d = mc.mcToolGetDesc(inst, t); if d and d ~= "" then items[#items+1] = ("%d - %s"):format(t, d); _G.toolNumbers[#_G.toolNumbers+1] = t end end
    scr.SetProperty("lstCurrentTool", "Strings", table.concat(items, "|"))
    local curr = mc.mcToolGetCurrent(inst) or 0; local idx = 0
    for i, tn in ipairs(_G.toolNumbers) do if tn == curr then idx = i-1 break end end
    scr.SetProperty("lstCurrentTool", "Value", tostring(idx)); UpdateToolPreview()
  end
end

--if _G.PopulateTools then pcall(_G.PopulateTools) end

-- ===== UI service for legacy PLC flags (tool prompt / low air) =====
local _panel = wx.wxPanel(wx.NULL, wx.wxID_ANY, wx.wxDefaultPosition, wx.wxSize(0,0))
local _timer = wx.wxTimer(_panel)
_panel:Connect(wx.wxEVT_TIMER, function(_)
  if _G.needToolPrompt then
    _G.needToolPrompt = false
    if _G.ShowToolSelectionDialog then _G.ShowToolSelectionDialog(_G.toolPromptIsStartup) end
  end

  if _G.needLowAirDialog then
    _G.needLowAirDialog = false
    local icon = wx.wxICON_WARNING
    if _G.lowAirDialogType == "error" then icon = wx.wxICON_ERROR
    elseif _G.lowAirDialogType == "info" then icon = wx.wxICON_INFORMATION end
    wx.wxMessageBox(_G.lowAirDialogMessage or "System Alert", "Air Pressure Alert", wx.wxOK + icon)
  end

  -- Apply H offset on request from PLC (non-blocking)
  if _G.requestHApply ~= nil then
    local n = tonumber(_G.requestHApply) or 0
    _G.requestHApply = nil  -- consume request
    mc.mcCntlMdiExecute(inst, "G49")
    if n > 0 then mc.mcCntlMdiExecute(inst, ("G43 H%d"):format(n)) end
  end

  UpdateToolPreview()

end)

_timer:Start(150)  -- mirrors your prior non-blocking timer pattern
