pageId = 0
screenId = 0
testcount = 0
machState = 0
machStateOld = -1
machEnabled = 0
machWasEnabled = 0
inst = mc.mcGetInstance()
Tframe = nil --TouchFrame handle

--mobdebug = require('mobdebug')
--mobdebug.onexit = mobdebug.done
--mobdebug.start() -- This line is to start the debug Process Comment out for no debuging

---------------------------------------------------------------
-- Signal Library
---------------------------------------------------------------
SigLib = {
	
[mc.OSIG_MACHINE_ENABLED] = function (state)
    -- PREVENT RE-ENTRANCY
    if _G.processingMachineEnable then
        return  -- Already processing, avoid re-entrancy
    end
    _G.processingMachineEnable = true
    
    machEnabled = state;
    ButtonEnable()
    
    -- Reset homing warning bypass based on machine state
    if state == 0 then
        -- Machine disabled - reset bypass immediately
        if _G.HOMING_WARNING_IGNORED then
            _G.HOMING_WARNING_IGNORED = false
            local inst = mc.mcGetInstance()
        end
        
        -- Clear tool selection on disable
        _G.selectedToolIndex = nil
        
        -- Clear M6 automation flags for dust boot
        mc.mcCntlSetPoundVar(inst, 481, 0)  -- Clear completion signal
        _G.waitingForMotionAfterToolChange = false
        _G.motionHasStarted = false
        
        -- IMMEDIATE virtual tool output shutdown on ANY disable
        -- This prevents Mach4 from remembering them as "on"
        local inst = mc.mcGetInstance()
        local virtualState = mc.mcCntlGetPoundVar(inst, 406)
        if virtualState >= 90 and virtualState <= 99 then
            -- Turn off outputs immediately to prevent restore issues
            local h7 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
            if h7 and h7 > 0 then mc.mcSignalSetState(h7, 0) end
            
            local h1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
            if h1 and h1 > 0 then mc.mcSignalSetState(h1, 0) end
            
            -- Don't clear state yet - we need it for proper recovery
            mc.mcCntlSetLastError(inst, "Disable: Virtual tool outputs secured")
        end
        
    elseif state == 1 then
        -- Machine enabled
        local inst = mc.mcGetInstance()
        
        -- Refresh tool dropdown
        if PopulateTools then
            PopulateTools()
        end
        
        -- Cancel any rotation on enable
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        
        -- CHECK AND FIX H OFFSET STATE
        local currentTool = mc.mcToolGetCurrent(inst)
        local activeH = mc.mcCntlGetPoundVar(inst, 4120)
        local compMode = mc.mcCntlGetPoundVar(inst, 4008)
        
        -- Cancel H offset first to ensure clean state
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        
        -- If there's a physical tool loaded, re-apply its H offset
        if currentTool > 0 and currentTool < 90 then
            mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", currentTool))
        end
        
        -- CHECK FOR ORPHANED VIRTUAL TOOL (E-stop/crash recovery)
        -- Let the virtual tool system manage its own outputs
        local virtualState = mc.mcCntlGetPoundVar(inst, 406)
        if virtualState >= 90 and virtualState <= 99 then
            -- Virtual tool was left active - need to clean up
            mc.mcCntlSetLastError(inst, "Recovery: Virtual tool was active, retracting...")
            
            -- Use the global retraction function
            if RetractVirtualTool then
                RetractVirtualTool()  -- This properly handles outputs and offsets
                mc.mcCntlSetLastError(inst, "Virtual tool retracted after recovery")
            else
                -- Fallback if global function missing
                -- Just clear the state, outputs already turned off in disable
                mc.mcCntlSetPoundVar(inst, 406, 0)  -- Clear virtual tool state
                mc.mcCntlSetPoundVar(inst, 407, 0)  -- Clear X delta
                mc.mcCntlSetPoundVar(inst, 408, 0)  -- Clear Y delta
                mc.mcToolSetCurrent(inst, 0)
                mc.mcCntlGcodeExecuteWait(inst, "G49")
                mc.mcCntlSetLastError(inst, "WARNING: Virtual tool state cleared (RetractVirtualTool not found)")
            end
        end
        
        -- Check if homing warning needed
        local anyUnhomed = false
        for axis = 0, 5 do
            local enabled = mc.mcAxisIsEnabled(inst, axis)
            local homed = mc.mcAxisIsHomed(inst, axis)
            if enabled == 1 and homed ~= 1 then
                anyUnhomed = true
                break
            end
        end
        
        -- Log status
        if anyUnhomed then
            mc.mcCntlSetLastError(inst, "Machine enabled - axes not homed, jog protection active")
        end
    end
    
    -- CLEAR RE-ENTRANCY FLAG
    _G.processingMachineEnable = false
end,




[mc.ISIG_INPUT1] = function (state) -- this is an example for a condition in the signal table.
   -- if (state == 1) then   
--        CycleStart()
--    --else
--        --mc.mcCntlFeedHold (0)
--    end
end,



[mc.OSIG_JOG_CONT] = function (state)
    if( state == 1) then 
       scr.SetProperty('labJogMode', 'Label', 'Continuous');
       scr.SetProperty('txtJogInc', 'Bg Color', '#C0C0C0');--Light Grey
       scr.SetProperty('txtJogInc', 'Fg Color', '#808080');--Dark Grey
    end
end,

[mc.OSIG_JOG_INC] = function (state)
    if( state == 1) then
        scr.SetProperty('labJogMode', 'Label', 'Incremental');
        scr.SetProperty('txtJogInc', 'Bg Color', '#FFFFFF');--White    
        scr.SetProperty('txtJogInc', 'Fg Color', '#000000');--Black
   end
end,

[mc.OSIG_JOG_MPG] = function (state)
    if( state == 1) then
        scr.SetProperty('labJogMode', 'Label', '');
        scr.SetProperty('txtJogInc', 'Bg Color', '#C0C0C0');--Light Grey
        scr.SetProperty('txtJogInc', 'Fg Color', '#808080');--Dark Grey
        --add the bits to grey jog buttons becasue buttons can't be MPGs
    end
end
}

---------------------------------------------------------------
-- Message Library
---------------------------------------------------------------
-- More messages can be found in the Message Script section of the scripting manual
--or by typing "mc.MSG_" scroll through the list to see if one of the messages fits your use case
MsgLib = {
	[mc.MSG_REG_CHANGED] = function (param1, param2)
		-- param1 in this case is the handle of the register that has changed
		-- For information on handles/registers please reference our scripting manual
		--local value = mc.mcRegGetValue(param1)
		--local info = mc.mcRegGetInfo(param1)
	end
}
---------------------------------------------------------------
-- Keyboard Inputs Toggle() function. Updated to handle multiple buttons
---------------------------------------------------------------
function KeyboardInputsToggle()
    local iReg = mc.mcIoGetHandle (inst, "Keyboard/Enable")
    local iReg2 = mc.mcIoGetHandle (inst, "Keyboard/EnableKeyboardJog")
    
    if (iReg ~= nil) and (iReg2 ~= nil) then
        local val = mc.mcIoGetState(iReg);
        if (val == 1) then
            mc.mcIoSetState(iReg, 0);
            mc.mcIoSetState(iReg2, 0);
            
            -- Update all keyboard jog buttons
            scr.SetProperty('btnKeyboardJog', 'Bg Color', '');
            scr.SetProperty('btnKeyboardJog', 'Label', 'Keyboard\nInputs Enable');
            
            -- Handle duplicate button if it exists
            if scr.GetProperty('btnKeyboardJog_1', 'Bg Color') ~= nil then
                scr.SetProperty('btnKeyboardJog_1', 'Bg Color', '');
                scr.SetProperty('btnKeyboardJog_1', 'Label', 'Keyboard\nInputs Enable');
            end
        else
            mc.mcIoSetState(iReg, 1);
            mc.mcIoSetState(iReg2, 1);
            
            -- Update all keyboard jog buttons
            scr.SetProperty('btnKeyboardJog', 'Bg Color', '#00FF00');
            scr.SetProperty('btnKeyboardJog', 'Label', 'Keyboard\nInputs Disable');
            
            -- Handle duplicate button if it exists
            if scr.GetProperty('btnKeyboardJog_1', 'Bg Color') ~= nil then
                scr.SetProperty('btnKeyboardJog_1', 'Bg Color', '#00FF00');
                scr.SetProperty('btnKeyboardJog_1', 'Label', 'Keyboard\nInputs Disable');
            end
        end
    end
end
---------------------------------------------------------------
-- Remember Position function.
---------------------------------------------------------------
function RememberPosition()
    local pos = mc.mcAxisGetMachinePos(inst, 0) -- Get current X (0) Machine Coordinates
    mc.mcProfileWriteString(inst, "RememberPos", "X", string.format (pos)) --Create a register and write the machine coordinates to it
    local pos = mc.mcAxisGetMachinePos(inst, 1) -- Get current Y (1) Machine Coordinates
    mc.mcProfileWriteString(inst, "RememberPos", "Y", string.format (pos)) --Create a register and write the machine coordinates to it
    local pos = mc.mcAxisGetMachinePos(inst, 2) -- Get current Z (2) Machine Coordinates
    mc.mcProfileWriteString(inst, "RememberPos", "Z", string.format (pos)) --Create a register and write the machine coordinates to it
end
---------------------------------------------------------------
-- Return to Position function.
---------------------------------------------------------------
function ReturnToPosition()
    local xval = mc.mcProfileGetString(inst, "RememberPos", "X", "NotFound") -- Get the register Value
    local yval = mc.mcProfileGetString(inst, "RememberPos", "Y", "NotFound") -- Get the register Value
    local zval = mc.mcProfileGetString(inst, "RememberPos", "Z", "NotFound") -- Get the register Value
    
    if(xval == "NotFound")then -- check to see if the register is found
        wx.wxMessageBox('Register xval does not exist.\nYou must remember a postion before you can return to it.'); -- If the register does not exist tell us in a message box
    elseif (yval == "NotFound")then -- check to see if the register is found
        wx.wxMessageBox('Register yval does not exist.\nYou must remember a postion before you can return to it.'); -- If the register does not exist tell us in a message box
    elseif (zval == "NotFound")then -- check to see if the register is found
        wx.wxMessageBox('Register zval does not exist.\nYou must remember a postion before you can return to it.'); -- If the register does not exist tell us in a message box
    else
        mc.mcCntlMdiExecute(inst, "G00 G53 Z0.0000 \n G00 G53 X" .. xval .. "\n G00 G53 Y" .. yval .. "\n G00 G53 Z" .. zval)
    end
end
---------------------------------------------------------------
-- Spin CW function.
---------------------------------------------------------------
function SpinCW()
    local sigh = mc.mcSignalGetHandle(inst, mc.OSIG_SPINDLEON);
    local sigState = mc.mcSignalGetState(sigh);
    
    if (sigState == 1) then 
        mc.mcSpindleSetDirection(inst, 0);
    else 
        mc.mcSpindleSetDirection(inst, 1);
    end
end
---------------------------------------------------------------
-- Spin CCW function.
---------------------------------------------------------------
function SpinCCW()
    local sigh = mc.mcSignalGetHandle(inst, mc.OSIG_SPINDLEON);
    local sigState = mc.mcSignalGetState(sigh);
    
    if (sigState == 1) then 
        mc.mcSpindleSetDirection(inst, 0);
    else 
        mc.mcSpindleSetDirection(inst, -1);
    end
end
---------------------------------------------------------------
-- Open Docs function.
---------------------------------------------------------------
function OpenDocs()
    local major, minor = wx.wxGetOsVersion()
    local dir = mc.mcCntlGetMachDir(inst);
    local cmd = "explorer.exe /open," .. dir .. "\\Docs\\"
    if(minor <= 5) then -- Xp we don't need the /open
        cmd = "explorer.exe ," .. dir .. "\\Docs\\"
    end
	os.execute(cmd)
    scr.RefreshScreen(250); -- Windows 7 and 8 seem to require the screen to be refreshed.  
end
---------------------------------------------------------------
-- Cycle Stop function.
---------------------------------------------------------------
function CycleStop()
mc.mcCntlCycleStop(inst);
mc.mcSpindleSetDirection(inst, 0);
mc.mcCntlSetLastError(inst, "Cycle Stopped");
	if(wait ~= nil) then
		wait = nil;
	end
end
---------------------------------------------------------------
-- Button Jog Mode Toggle() function.
---------------------------------------------------------------
function ButtonJogModeToggle()
    local cont = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_CONT);
    local jogcont = mc.mcSignalGetState(cont)
    local inc = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_INC);
    local joginc = mc.mcSignalGetState(inc)
    local mpg = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_MPG);
    local jogmpg = mc.mcSignalGetState(mpg)
    
    if (jogcont == 1) then
        mc.mcSignalSetState(cont, 0)
        mc.mcSignalSetState(inc, 1)
        mc.mcSignalSetState(mpg, 0)        
    else
        mc.mcSignalSetState(cont, 1)
        mc.mcSignalSetState(inc, 0)
        mc.mcSignalSetState(mpg, 0)
    end

end
---------------------------------------------------------------
-- Ref All Home() function.
---------------------------------------------------------------
function RefAllHome()
    mc.mcAxisDerefAll(inst)  --Just to turn off all ref leds
    mc.mcAxisHomeAll(inst)
    coroutine.yield() --yield coroutine so we can do the following after motion stops
    ----See ref all home button and plc script for coroutine.create and coroutine.resume
    wx.wxMessageBox('Referencing is complete')
end
---------------------------------------------------------------
-- Go To Work Zero() function.
---------------------------------------------------------------
function GoToWorkZero()
    mc.mcCntlMdiExecute(inst, "G00 X0 Y0")--Without Z moves
    --mc.mcCntlMdiExecute(inst, "G00 G53 Z0\nG00 X0 Y0 A0\nG00 Z0")--With Z moves
end
---------------------------------------------------------------
-- Cycle Start() function.
---------------------------------------------------------------
function CycleStart()	
	
	if not CheckHomingBeforeMove() then
        return
    end
	
	local rc
    local tab, rc = scr.GetProperty("MainTabs", "Current Tab")
    local tabG_Mdione, rc = scr.GetProperty("nbGCodeMDI1", "Current Tab")
	local tabG_Mditwo, rc = scr.GetProperty("nbGCodeMDI2", "Current Tab")
	local state = mc.mcCntlGetState(inst)
	--mc.mcCntlSetLastError(inst,"tab == " .. tostring(tab))
	
	if (state == mc.MC_STATE_MRUN_MACROH) then 
		mc.mcCntlCycleStart(inst)
	elseif ((tonumber(tab) == 0 and tonumber(tabG_Mdione) == 1)) then  
		scr.ExecMdi('mdi1')
	elseif ((tonumber(tab) == 5 and tonumber(tabG_Mditwo) == 1)) then  
		scr.ExecMdi('mdi2')
	else
		mc.mcCntlCycleStart(inst)    
	end
end
-------------------------------------------------------
--  Seconds to time Added 5-9-16
-------------------------------------------------------
--Converts decimal seconds to an HH:MM:SS.xx format
function SecondsToTime(seconds)
	if seconds == 0 then
		return "00:00:00.00"
	else
		local hours = string.format("%02.f", math.floor(seconds/3600))
		local mins = string.format("%02.f", math.floor((seconds/60) - (hours*60)))
		local secs = string.format("%04.2f",(seconds - (hours*3600) - (mins*60)))
		return hours .. ":" .. mins .. ":" .. secs
	end
end
---------------------------------------------------------------
-- Set Button Jog Mode to Cont.
---------------------------------------------------------------
local cont = mc.mcSignalGetHandle(inst, mc.OSIG_JOG_CONT);
local jogcont = mc.mcSignalGetState(cont)
mc.mcSignalSetState(cont, 1)
-------------------------------------------------------
--  Decimal to Fractions
-------------------------------------------------------
function DecToFrac(axis)
	--Determine position to get and labels to set.
    local work = mc.mcAxisGetPos(inst, axis)
	local lab = string.format("lblFrac" .. tostring(axis))
	local labNum = string.format("lblFracNum" .. tostring(axis))
	local labDen = string.format("lblFracDen" .. tostring(axis))
    local sign = (" ")		--Use a blank space so we do not get any errors.
	
    if work < 0 then	--Change the sign to -
		sign = ("-")
	end
	
	work = math.abs (work)
	local remainder = math.fmod(work, .0625)

	if remainder >= .03125 then 	--Round up to the closest 1/16
		work = work + remainder
	else							--Round down to the closest 1/16
		work = work - remainder
	end

	local inches = math.floor(work / 1.000)
	local iremainder = work % 1.000
	local halves = math.floor(iremainder / .5000)
	local remainder = iremainder % .5000
	local quarters = math.floor(remainder / .2500)
	local remainder = remainder % .2500
	local eights = math.floor(remainder / .1250)
	local remainder = remainder % .1250
	local sixteens = math.floor(remainder / .0625)

	numar = 0	--Default to 0. The next if statement will change it if needed.
	denom = 0	--Default to 0. The next if statement will change it if needed.

	if sixteens > 0 then
		numar = math.floor(iremainder / .0625)
		denom = 16
	elseif eights > 0 then
		numar = math.floor(iremainder / .1250)
		denom = 8
	elseif quarters > 0 then
		numar = math.floor(iremainder / .2500)
		denom = 4
	elseif halves > 0 then
		numar = math.floor(iremainder / .5000)
		denom = 2
	end
	
    scr.SetProperty((lab), 'Label', (sign) .. tostring(inches))
	scr.SetProperty((labNum), 'Label', tostring(numar))
	scr.SetProperty((labDen), 'Label', "/" .. tostring(denom))
end
---------------------------------------------------------------
--Timer panel example
---------------------------------------------------------------
TimerPanel = wx.wxPanel (wx.NULL, wx.wxID_ANY, wx.wxDefaultPosition, wx.wxSize( 0,0 ) )
timer = wx.wxTimer(TimerPanel)
TimerPanel:Connect(wx.wxEVT_TIMER,
function (event)
    wx.wxMessageBox("Hello")
    timer:Stop()
end)
---------------------------------------------------------------
-- Load modules
---------------------------------------------------------------
--Master module
package.loaded.mcRegister = nil
mm = require "mcRegister"

--ErrorCheck module Added 11-4-16
package.loaded.mcErrorCheck = nil
mcErrorCheck = require "mcErrorCheck"

--Trace module
package.loaded.mcTrace = nil
mcTrace = require "mcTrace"

---------------------------------------------------------------
-- Get fixtue offset pound variables function Updated 5-16-16
---------------------------------------------------------------
function GetFixOffsetVars()
    local FixOffset = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14)
    local Pval = mc.mcCntlGetPoundVar(inst, mc.SV_BUFP)
    local FixNum, whole, frac

    if (FixOffset ~= 54.1) then --G54 through G59
        whole, frac = math.modf (FixOffset)
        FixNum = (whole - 53) 
        PoundVarX = ((mc.SV_FIXTURES_START - mc.SV_FIXTURES_INC) + (FixNum * mc.SV_FIXTURES_INC))
        CurrentFixture = string.format('G' .. tostring(FixOffset)) 
    else --G54.1 P1 through G54.1 P100
        FixNum = (Pval + 6)
        CurrentFixture = string.format('G54.1 P' .. tostring(Pval))
        if (Pval > 0) and (Pval < 51) then -- G54.1 P1 through G54.1 P50
            PoundVarX = ((mc.SV_FIXTURE_EXPAND - mc.SV_FIXTURES_INC) + (Pval * mc.SV_FIXTURES_INC))
        elseif (Pval > 50) and (Pval < 101) then -- G54.1 P51 through G54.1 P100
            PoundVarX = ((mc.SV_FIXTURE_EXPAND2 - mc.SV_FIXTURES_INC) + (Pval * mc.SV_FIXTURES_INC))	
        end
    end
PoundVarY = (PoundVarX + 1)
PoundVarZ = (PoundVarX + 2)
return PoundVarX, PoundVarY, PoundVarZ, FixNum, CurrentFixture
-------------------------------------------------------------------------------------------------------------------
--return information from the fixture offset function
-------------------------------------------------------------------------------------------------------------------
--PoundVar(Axis) returns the pound variable for the current fixture for that axis (not the pound variables value).
--CurretnFixture returned as a string (examples G54, G59, G54.1 P12).
--FixNum returns a simple number (1-106) for current fixture (examples G54 = 1, G59 = 6, G54.1 P1 = 7, etc).
-------------------------------------------------------------------------------------------------------------------
end
---------------------------------------------------------------
-- Button Enable function Updated 11-8-2015
---------------------------------------------------------------
function ButtonEnable() --This function enables or disables buttons associated with an axis if the axis is enabled or disabled.

    AxisTable = {
        [0] = 'X',
        [1] = 'Y',
        [2] = 'Z',
        [3] = 'A',
        [4] = 'B',
        [5] = 'C'}
        
    for Num, Axis in pairs (AxisTable) do -- for each paired Num (key) and Axis (value) in the Axis table
        local rc = mc.mcAxisIsEnabled(inst,(Num)) -- find out if the axis is enabled, returns a 1 or 0
        scr.SetProperty((string.format ('btnPos' .. Axis)), 'Enabled', tostring(rc)); --Turn the jog positive button on or off
        scr.SetProperty((string.format ('btnNeg' .. Axis)), 'Enabled', tostring(rc)); --Turn the jog negative button on or off
        scr.SetProperty((string.format ('btnZero' .. Axis)), 'Enabled', tostring(rc)); --Turn the zero axis button on or off
        scr.SetProperty((string.format ('btnRef' .. Axis)), 'Enabled', tostring(rc)); --Turn the reference button on or off
    end
    
end
ButtonEnable()






-- Global table to map dropdown indices to tool numbers
_G.toolNumbers = {}
_G.selectedToolIndex = nil  -- Track user selection separately

function PopulateTools()
    local inst = mc.mcGetInstance()
    local tools = {}  -- List of display strings
    
    -- Tool 0 always first
    table.insert(tools, "0 - No Tool")
    table.insert(_G.toolNumbers, 0)
    
    -- Check all tools 1-99, but only include those with descriptions
    for toolNum = 1, 99 do
        local desc = mc.mcToolGetDesc(inst, toolNum)
        if desc and desc ~= "" then
            table.insert(tools, toolNum .. " - " .. desc)
            table.insert(_G.toolNumbers, toolNum)
        end
    end
    
    -- Store for dialog
    _G.toolChoices = tools
    
    -- Set the ListBox strings
    local toolList = table.concat(tools, "|")
    scr.SetProperty("lstCurrentTool", "Strings", toolList)
    
    -- Get current tool
    local currTool = mc.mcToolGetCurrent(inst)
    local index = 0  -- Default to 0 (No Tool)
    
    for i, t in ipairs(_G.toolNumbers) do
        if t == currTool then
            index = i - 1  -- Convert to 0-based
            break
        end
    end
    
    -- Set dropdown to current tool
    scr.SetProperty("lstCurrentTool", "Value", tostring(index))
    _G.selectedToolIndex = nil  -- No selection yet
    
    -- Update display
    UpdateToolPreview()
    
  --  mc.mcCntlSetLastError(inst, "Tool system ready - " .. (#tools - 1) .. " tools available")
end

function UpdateToolPreview()
    local inst = mc.mcGetInstance()
    
    -- Always show the current tool
    local currTool = mc.mcToolGetCurrent(inst)
    local displayText = "T0 - No Tool"
    
    if currTool == 0 then
        displayText = "T0 - No Tool"
    else
        local desc = mc.mcToolGetDesc(inst, currTool) or "Unnamed"
        displayText = "T" .. currTool .. " - " .. desc
    end
    
    -- Update preview label
    scr.SetProperty("lblToolPreview", "Label", displayText)
end

-- Call on load
PopulateTools()

-- Initialize for PLC - force T0 on startup with H offset sync
local inst = mc.mcGetInstance()
mc.mcToolSetCurrent(inst, 0)  -- Set to T0
mc.mcCntlGcodeExecuteWait(inst, "G49")  -- CRITICAL: Cancel any stale H offset


_G.hOffsetSyncPending = false
_G.hOffsetLastSync = 0
_G.hOffsetSyncPending = false
_G.hOffsetLastSync = 0
_G.lastHSync = {}  -- Initialize as empty table to prevent nil errors





-- ============================================
-- Global Virtual Tool Retraction Function
-- Called by: PLC, M6 (optional), Recovery, Manual buttons
-- Single source of truth for virtual tool retraction
-- ============================================
function RetractVirtualTool()
    local inst = mc.mcGetInstance()
    local state = mc.mcCntlGetPoundVar(inst, 406)
    
    -- Only retract if virtual tool active (90-99)
    if state < 90 or state > 99 then
        return false  -- No virtual tool active
    end
    
    -- Get stored delta values
    local xDelta = mc.mcCntlGetPoundVar(inst, 407)
    local yDelta = mc.mcCntlGetPoundVar(inst, 408)
    
    -- VALIDATE DELTAS BEFORE USING (NEW!)
    if xDelta < -1e300 or yDelta < -1e300 then
        mc.mcCntlSetLastError(inst, "WARNING: Virtual tool deltas lost - clearing state only")
        
        -- Still turn off hardware based on tool type
        if state == 90 then
            local h = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
            if h and h > 0 then mc.mcSignalSetState(h, 0) end
        elseif state == 91 then
            local h = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
            if h and h > 0 then mc.mcSignalSetState(h, 0) end
        end
        
        -- Clear state variables
        mc.mcCntlSetPoundVar(inst, 406, 0)
        mc.mcCntlSetPoundVar(inst, 407, 0)
        mc.mcCntlSetPoundVar(inst, 408, 0)
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        
        return false  -- Couldn't fully recover offsets
    end
    
    -- Log what we're doing
    local toolName = "virtual tool"
    if state == 90 then 
        toolName = "probe"
    elseif state == 91 then 
        toolName = "laser"
    end
    
    -- Restore work offsets by adding deltas back
    if math.abs(xDelta) > 0.0001 or math.abs(yDelta) > 0.0001 then
        for i = 0, 5 do
            local baseVar = 5221 + (i * 20)  -- G54-G59 base addresses
            local currentX = mc.mcCntlGetPoundVar(inst, baseVar)
            local currentY = mc.mcCntlGetPoundVar(inst, baseVar + 1)
            
            -- Only apply if values look reasonable (sanity check)
            if math.abs(currentX) < 1000 and math.abs(currentY) < 1000 then
                mc.mcCntlSetPoundVar(inst, baseVar, currentX + xDelta)
                mc.mcCntlSetPoundVar(inst, baseVar + 1, currentY + yDelta)
            end
        end
    end
    
    -- Turn off hardware based on tool type
    if state == 90 then
        -- Turn off probe (Output 7)
        local h = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
        if h and h > 0 then 
            mc.mcSignalSetState(h, 0) 
        end
    elseif state == 91 then
        -- Turn off laser (Output 1)
        local h = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
        if h and h > 0 then 
            mc.mcSignalSetState(h, 0) 
        end
    end
    
    -- Clear all state variables
    mc.mcCntlSetPoundVar(inst, 406, 0)  -- Clear virtual tool state
    mc.mcCntlSetPoundVar(inst, 407, 0)  -- Clear X delta
    mc.mcCntlSetPoundVar(inst, 408, 0)  -- Clear Y delta
    
    -- Set tool to 0 and cancel height offset
    mc.mcToolSetCurrent(inst, 0)
    mc.mcCntlGcodeExecuteWait(inst, "G49")
    
    mc.mcCntlSetLastError(inst, string.format("Virtual %s retracted", toolName))
    
    return true  -- Successfully retracted
end

-- CRITICAL: Make it globally accessible
_G.RetractVirtualTool = RetractVirtualTool






-- ============================================
-- Virtual Tool Recovery Function
-- Uses the global RetractVirtualTool() function
-- ============================================
do
    local inst = mc.mcGetInstance()
    
    -- Function to recover virtual tool state on startup
    local function recoverVirtualToolState()
        local state = mc.mcCntlGetPoundVar(inst, 406)
        
        -- Only recover if virtual tool was active (90-99)
        if state >= 90 and state <= 99 then
            mc.mcCntlSetLastError(inst, "Recovering from virtual tool deployment")
            
            -- Use the global retraction function
            RetractVirtualTool()
        end
    end
    
    -- Call recovery on startup
    recoverVirtualToolState()
end







function ShowHomingRequiredDialog()
    local inst = mc.mcGetInstance()
    
    -- Check which axes need homing
    local unhomedAxes = {}
    for axis = 0, 5 do
        local enabled = mc.mcAxisIsEnabled(inst, axis)
        local homed = mc.mcAxisIsHomed(inst, axis)
        
        if enabled and enabled == 1 and (not homed or homed ~= 1) then
            local axisName = ({"X","Y","Z","A","B","C"})[axis + 1]
            table.insert(unhomedAxes, axisName)
        end
    end
    
    -- If all axes are homed, return true (allow movement)
    if #unhomedAxes == 0 then
        return true
    end
    
    -- Loop to handle going back from confirmation
    local continueDialog = true
    local finalResult = false
    
    while continueDialog do
        -- Get screen size for centering
        local screenWidth = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_X)
        local screenHeight = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_Y)
        local dialogWidth = 350
        local dialogHeight = 200
        local xPos = (screenWidth - dialogWidth) / 2
        local yPos = (screenHeight - dialogHeight) / 2
        
        -- Create custom dialog
        local dialog = wx.wxDialog(wx.NULL, wx.wxID_ANY, "Homing Required",
                                  wx.wxPoint(xPos, yPos), wx.wxSize(dialogWidth, dialogHeight),
                                  wx.wxDEFAULT_DIALOG_STYLE)
        
        -- Create panel
        local panel = wx.wxPanel(dialog, wx.wxID_ANY)
        
        -- Create message
        local message = "You must home the following axes\nbefore movement:\n\n" ..
                       table.concat(unhomedAxes, ", ")
        
        local staticText = wx.wxStaticText(panel, wx.wxID_ANY, message,
                                          wx.wxDefaultPosition, wx.wxDefaultSize,
                                          wx.wxALIGN_CENTER)
        
        -- Make text larger
        local font = staticText:GetFont()
        font:SetPointSize(12)
        staticText:SetFont(font)
        
        -- Create buttons with specific sizes
        local btnIgnore = wx.wxButton(panel, wx.wxID_ANY, "Ignore Warning", 
                                     wx.wxDefaultPosition, wx.wxSize(120, 35))
        local btnHomeAll = wx.wxButton(panel, wx.wxID_ANY, "HOME ALL",
                                       wx.wxDefaultPosition, wx.wxSize(120, 35))
        
        -- Style the HOME ALL button - GREEN
        btnHomeAll:SetBackgroundColour(wx.wxColour(0, 255, 0))  -- Bright green
        btnHomeAll:SetForegroundColour(wx.wxColour(0, 0, 0))    -- Black text
        
        -- Make HOME ALL button text bold
        local homeFont = btnHomeAll:GetFont()
        homeFont:SetWeight(wx.wxFONTWEIGHT_BOLD)
        homeFont:SetPointSize(11)
        btnHomeAll:SetFont(homeFont)
        
        -- Make Home All the default button (Enter key)
        btnHomeAll:SetDefault()
        
        -- Layout
        local mainSizer = wx.wxBoxSizer(wx.wxVERTICAL)
        local buttonSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
        
        mainSizer:Add(staticText, 1, wx.wxEXPAND + wx.wxALL, 20)
        
        buttonSizer:Add(btnIgnore, 0, wx.wxALL, 5)
        buttonSizer:Add(btnHomeAll, 0, wx.wxALL, 5)
        
        mainSizer:Add(buttonSizer, 0, wx.wxALIGN_CENTER + wx.wxBOTTOM, 15)
        
        panel:SetSizer(mainSizer)
        mainSizer:Fit(dialog)
        
        -- Center dialog on screen
        dialog:Centre()
        
        -- Button event handlers
        local dialogResult = "cancel"  -- Default
        
        btnIgnore:Connect(wx.wxEVT_COMMAND_BUTTON_CLICKED,
            function(event)
                dialogResult = "ignore"
                dialog:EndModal(wx.wxID_OK)
            end)
        
        btnHomeAll:Connect(wx.wxEVT_COMMAND_BUTTON_CLICKED,
            function(event)
                dialogResult = "home"
                dialog:EndModal(wx.wxID_OK)
            end)
        
        -- Show dialog
        dialog:ShowModal()
        dialog:Destroy()
        
        -- Handle dialog result
        if dialogResult == "home" then
            -- User chose Home All
            mc.mcCntlSetLastError(inst, "Homing all axes...")
            -- Call the RefAllHome function that already exists in your screen script
            RefAllHome()
            finalResult = true
            continueDialog = false
        elseif dialogResult == "ignore" then
            -- Show confirmation dialog
            local confirmResult = ShowIgnoreConfirmDialog()
            
            if confirmResult == "continue" then
                -- User confirmed ignore
                mc.mcCntlSetLastError(inst, "WARNING: Movement allowed without homing!")
                finalResult = true
                continueDialog = false
            else
                -- User chose to go back - loop will continue
                mc.mcCntlSetLastError(inst, "Returning to homing dialog...")
            end
        else
            -- Dialog was closed with X or escaped
            mc.mcCntlSetLastError(inst, "Movement cancelled - axes not homed")
            finalResult = false
            continueDialog = false
        end
    end
    
    return finalResult
end





-- ===== SCREEN LOAD SCRIPT =====
-- REPLACE the existing CheckHomingBeforeMove function with this version
-- (This function should already exist in your Screen Load Script)
function CheckHomingBeforeMove()
    local inst = mc.mcGetInstance()
    
    -- Quick check if any axis needs homing
    for axis = 0, 5 do
        local enabled = mc.mcAxisIsEnabled(inst, axis)
        local homed = mc.mcAxisIsHomed(inst, axis)
        
        if enabled and enabled == 1 and (not homed or homed ~= 1) then
            -- Show enhanced dialog and return result
            return ShowHomingRequiredDialog()
        end
    end
    
    return true  -- All homed, allow movement
end




-- ===== HOMING SAFETY SYSTEM INITIALIZATION =====
-- REPLACE the existing initialization section (around line 818-847)
-- This goes at the END of your Screen Load Script
do
    local inst = mc.mcGetInstance()
    
    -- Check initial homing state
    local allHomed = true
    for axis = 0, 5 do
        local enabled = mc.mcAxisIsEnabled(inst, axis)
        local homed = mc.mcAxisIsHomed(inst, axis)
        if enabled and enabled == 1 and (not homed or homed ~= 1) then
            allHomed = false
            break
        end
    end
    
    -- Set initial global state
    _G.AXES_HOMED = allHomed
    _G.lastHomingFlashState = nil
    _G.lastHomedState = nil
    _G.jogSafetyCounter = 0
    _G.lastJogStopTime = 0
    _G.HOMING_WARNING_IGNORED = false  -- NEW: Track if user ignored warning
    
    -- Stop any active jogs on startup
    for axis = 0, 5 do
        mc.mcJogVelocityStop(inst, axis)
    end
    
    -- Set initial button appearance based on homing state
    if allHomed then
        _G.HOMING_WARNING_IGNORED = false  -- Reset bypass when homed
        scr.SetProperty("btnRefAllAxes", "Bg Color", "#4B4B4B")  -- Dark gray
        scr.SetProperty("btnRefAllAxes", "Fg Color", "#FFFFFF")  -- White text
        scr.SetProperty("btnRefAllAxes", "Label", "Ref All\nAxis")
     --   mc.mcCntlSetLastError(inst, "All axes homed - movement enabled")
    else
        scr.SetProperty("btnRefAllAxes", "Bg Color", "#4B4B4B")  -- Start with dark gray
        scr.SetProperty("btnRefAllAxes", "Fg Color", "#000000")  -- Black text
        scr.SetProperty("btnRefAllAxes", "Label", "HOME\nREQUIRED")
        mc.mcCntlSetLastError(inst, "Axes not homed - movement disabled")
    end
end
-- ===== END HOMING SAFETY SYSTEM INITIALIZATION =====




function ShowIgnoreConfirmDialog()
    local inst = mc.mcGetInstance()
    
    -- Get screen size for centering
    local screenWidth = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_X)
    local screenHeight = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_Y)
    local dialogWidth = 300
    local dialogHeight = 150
    local xPos = (screenWidth - dialogWidth) / 2
    local yPos = (screenHeight - dialogHeight) / 2
    
    -- Create confirmation dialog
    local dialog = wx.wxDialog(wx.NULL, wx.wxID_ANY, "Confirm Ignore Homing",
                              wx.wxPoint(xPos, yPos), wx.wxSize(dialogWidth, dialogHeight),
                              wx.wxDEFAULT_DIALOG_STYLE)
    
    -- Create panel
    local panel = wx.wxPanel(dialog, wx.wxID_ANY)
    
    -- Create warning message
    local message = "ARE YOU SURE?\n\nRunning without homing can cause\ncrashes and damage!"
    
    local staticText = wx.wxStaticText(panel, wx.wxID_ANY, message,
                                      wx.wxDefaultPosition, wx.wxDefaultSize,
                                      wx.wxALIGN_CENTER)
    
    -- Make text larger and bold
    local font = staticText:GetFont()
    font:SetPointSize(11)
    font:SetWeight(wx.wxFONTWEIGHT_BOLD)
    staticText:SetFont(font)
    
    -- Set text color to red for warning
    staticText:SetForegroundColour(wx.wxColour(255, 0, 0))
    
    -- Create buttons
    local btnGoBack = wx.wxButton(panel, wx.wxID_ANY, "Go Back", 
                                 wx.wxDefaultPosition, wx.wxSize(100, 30))
    local btnContinue = wx.wxButton(panel, wx.wxID_ANY, "Continue",
                                    wx.wxDefaultPosition, wx.wxSize(100, 30))
    
    -- Make Go Back the default (safer option)
    btnGoBack:SetDefault()
    
    -- Layout
    local mainSizer = wx.wxBoxSizer(wx.wxVERTICAL)
    local buttonSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
    
    mainSizer:Add(staticText, 1, wx.wxEXPAND + wx.wxALL, 20)
    
    buttonSizer:Add(btnGoBack, 0, wx.wxALL, 5)
    buttonSizer:Add(btnContinue, 0, wx.wxALL, 5)
    
    mainSizer:Add(buttonSizer, 0, wx.wxALIGN_CENTER + wx.wxBOTTOM, 10)
    
    panel:SetSizer(mainSizer)
    mainSizer:Fit(dialog)
    
    -- Center dialog
    dialog:Centre()
    
    -- Button event handlers
    local result = "goback"  -- Default to go back
    
    btnGoBack:Connect(wx.wxEVT_COMMAND_BUTTON_CLICKED,
        function(event)
            result = "goback"
            dialog:EndModal(wx.wxID_OK)
        end)
    
    btnContinue:Connect(wx.wxEVT_COMMAND_BUTTON_CLICKED,
        function(event)
            result = "continue"
            dialog:EndModal(wx.wxID_OK)
        end)
    
    -- Show dialog
    dialog:ShowModal()
    dialog:Destroy()
    
    return result
end






-- Manual H set function
function SetH(h)
    local inst = mc.mcGetInstance()
    if not h or h < 0 or h > 99 then
        return
    end
    
    local currentH = mc.mcCntlGetPoundVar(inst, 4120)
    if currentH ~= h then
        mc.mcCntlSetPoundVar(inst, 4120, h)
        mc.mcCntlSetPoundVar(inst, 4008, 43)
        
        -- Clear sync tracking since manual override
        _G.lastHSync = _G.lastHSync or {}  -- INITIALIZE TABLE IF NIL
        _G.lastHSync.tool = -1
        _G.lastHSync.h = h
    end
end




--mc.mcCntlSetLastError(mc.mcGetInstance(), "Screen Load complete - UpdateToolPreview exists: " .. tostring(UpdateToolPreview ~= nil))




-- ============================================
-- ShowProbeSettingsDialog() Function - ENHANCED VERSION
-- Includes Work Surface Reference, Laser Offsets, and Touch Probe Z Offset
-- Ready to paste into Screen Load Script
-- ============================================
function ShowProbeSettingsDialog()
    local inst = mc.mcGetInstance()
    
    -- Probe, laser & tool-change setting pound variables and their defaults
    local PROBE_VARS = {
        -- XYZ Touch Probe (T90)
        PROBE_DIAMETER     = {var = 300,  default = 0.250,  desc = "Probe Diameter"},
        PROBE_X_OFFSET     = {var = 301,  default = 0.000,  desc = "X Offset (Probe)"},
        PROBE_Y_OFFSET     = {var = 302,  default = 0.000,  desc = "Y Offset (Probe)"},
        PROBE_Z_OFFSET     = {var = 320,  default = 0.000,  desc = "Z Offset (Probe)"},  -- NEW!
        PROBE_FAST_FEED    = {var = 303,  default = 20.000, desc = "Fast Feed (Probe)"},
        PROBE_SLOW_FEED    = {var = 304,  default = 5.000,  desc = "Slow Feed (Probe)"},
        PROBE_MAX_TRAVEL   = {var = 305,  default = 0.100,  desc = "Max Travel (Probe)"},
        PROBE_BACKOFF_1    = {var = 306,  default = 0.100,  desc = "Backoff #1"},
        PROBE_BACKOFF_2    = {var = 307,  default = 0.100,  desc = "Backoff #2"},
        
        -- Laser (T91)
        LASER_X_OFFSET     = {var = 318,  default = 0.000,  desc = "X Offset (Laser)"},
        LASER_Y_OFFSET     = {var = 319,  default = 0.000,  desc = "Y Offset (Laser)"},
        
        -- Tool Change Movement
        TOOL_CHANGE_Z      = {var = 308,  default = -6.500, desc = "Tool Change Z Lift"},
        PULLOUT_DISTANCE   = {var = 309,  default = 1.750,  desc = "Tool Pullout Dist."},
        APPROACH_FEED      = {var = 310,  default = 200.000,desc = "Approach Feed"},
        
        -- Height Probe Station
        PROBE_STATION_X    = {var = 311,  default = 2.400,  desc = "Probe Station X"},
        PROBE_STATION_Y    = {var = 312,  default = 12.650, desc = "Probe Station Y"},
        WORK_SURFACE_Z     = {var = 353,  default = -7.800, desc = "Work Surface Z Ref"},
        
        -- Tool Height Measurement
        MAX_PROBE_DEPTH    = {var = 314,  default = -9.000, desc = "Max Probe Depth"},
        FAST_TOOL_FEED     = {var = 315,  default = 75.000, desc = "Fast Feed (Height)"},
        SLOW_TOOL_FEED     = {var = 316,  default = 3.000,  desc = "Slow Feed (Height)"},
        RETRACT_TOOL       = {var = 317,  default = 0.100,  desc = "Retract (Height)"}
    }
    
    -- Load all values from profile (or use defaults)
    for _, data in pairs(PROBE_VARS) do
        local saved = mc.mcProfileGetString(inst, "ProbeSettings", 
                                           "Var_" .. data.var, "NOT_FOUND")
        if saved ~= "NOT_FOUND" and tonumber(saved) then
            mc.mcCntlSetPoundVar(inst, data.var, tonumber(saved))
        else
            mc.mcCntlSetPoundVar(inst, data.var, data.default)
        end
    end
    
    -- Create dialog with adjusted size for better centering
    local dialog = wx.wxDialog(wx.NULL, wx.wxID_ANY, "Probe, Laser & Tool-Change Settings",
                              wx.wxDefaultPosition, wx.wxSize(500, 540),
                              wx.wxDEFAULT_DIALOG_STYLE)
    
    -- Center the dialog on screen
    dialog:Centre()
    
    -- Create main panel
    local mainPanel = wx.wxPanel(dialog, wx.wxID_ANY)
    local mainSizer = wx.wxBoxSizer(wx.wxVERTICAL)
    
    -- Create title
    local title = wx.wxStaticText(mainPanel, wx.wxID_ANY,
                    "Configure Virtual Tool and Tool-Change Parameters")
    title:SetFont(wx.wxFont(12, wx.wxFONTFAMILY_DEFAULT,
                            wx.wxFONTSTYLE_NORMAL, wx.wxFONTWEIGHT_BOLD))
    mainSizer:Add(title, 0, wx.wxALIGN_CENTER + wx.wxALL, 10)
    mainSizer:Add(wx.wxStaticLine(mainPanel, wx.wxID_ANY), 0, wx.wxEXPAND + wx.wxLEFT + wx.wxRIGHT, 10)
    
    -- Create scrolled window
    local scrollWin = wx.wxScrolledWindow(mainPanel, wx.wxID_ANY,
                                         wx.wxDefaultPosition, wx.wxDefaultSize,
                                         wx.wxVSCROLL)
    
    -- Set scroll rate (pixels per scroll unit)
    scrollWin:SetScrollRate(0, 20)
    
    -- Create sizer for scrolled content
    local scrollSizer = wx.wxBoxSizer(wx.wxVERTICAL)
    
    -- Input storage - store by var number for easy access
    local inputs = {}
    local inputOrder = {}  -- To maintain order
    
    -- Helper function to add section header
    local function addSectionHeader(title, description)
        -- Add some space before section (except first)
        if #inputOrder > 0 then
            scrollSizer:Add(wx.wxStaticLine(scrollWin, wx.wxID_ANY), 0, 
                           wx.wxEXPAND + wx.wxLEFT + wx.wxRIGHT + wx.wxTOP, 15)
        end
        
        -- Section title
        local headerText = wx.wxStaticText(scrollWin, wx.wxID_ANY, title)
        headerText:SetFont(wx.wxFont(11, wx.wxFONTFAMILY_DEFAULT,
                                    wx.wxFONTSTYLE_NORMAL, wx.wxFONTWEIGHT_BOLD))
        scrollSizer:Add(headerText, 0, wx.wxALL, 10)
        
        -- Section description
        if description then
            local descText = wx.wxStaticText(scrollWin, wx.wxID_ANY, description)
            descText:SetFont(wx.wxFont(9, wx.wxFONTFAMILY_DEFAULT,
                                      wx.wxFONTSTYLE_ITALIC, wx.wxFONTWEIGHT_NORMAL))
            descText:Wrap(460)  -- Wrap text to fit dialog
            scrollSizer:Add(descText, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM, 10)
        end
    end
    
    -- Helper function to add input grid for a section
    local function addInputGrid(inputDefs)
        local grid = wx.wxFlexGridSizer(#inputDefs, 3, 5, 10)
        grid:AddGrowableCol(1, 1)
        
        for _, def in ipairs(inputDefs) do
            local data, tip, unit = def[1], def[2], def[3]
            
            local lbl = wx.wxStaticText(scrollWin, wx.wxID_ANY, data.desc..":")
            local val = string.format("%.4f", mc.mcCntlGetPoundVar(inst, data.var))
            local txt = wx.wxTextCtrl(scrollWin, wx.wxID_ANY, val,
                          wx.wxDefaultPosition, wx.wxSize(140,-1))
            
            -- Set detailed tooltip
            if tip then 
                txt:SetToolTip(tip)
                -- Also set tooltip on label for better discoverability
                lbl:SetToolTip(tip)
            end
            
            local units = wx.wxStaticText(scrollWin, wx.wxID_ANY, unit or "")
            
            grid:Add(lbl, 0, wx.wxALIGN_RIGHT + wx.wxALIGN_CENTER_VERTICAL)
            grid:Add(txt, 0, wx.wxEXPAND)
            grid:Add(units, 0, wx.wxALIGN_LEFT + wx.wxALIGN_CENTER_VERTICAL)
            
            inputs[data.var] = txt
            table.insert(inputOrder, data)
        end
        
        scrollSizer:Add(grid, 0, wx.wxALL + wx.wxEXPAND, 10)
    end
    
    -- XYZ Touch Probe Section (T90)
    addSectionHeader("XYZ Touch Probe (T90)", 
                    "Settings for the spindle-mounted touch probe used for work offsets and part location")
    addInputGrid({
        {PROBE_VARS.PROBE_DIAMETER, 
         "Pound Variable #300: The actual diameter of the probe tip ball. This value is critical for accurate edge-finding and bore measurements. Measure with calipers for best accuracy. Typical values: 0.250\" for 1/4\" probe tips.", 
         "in"},
        {PROBE_VARS.PROBE_X_OFFSET, 
         "Pound Variable #301: The X-axis distance from the spindle centerline to the probe tip centerline when deployed. Positive values mean probe is to the right of spindle. Used to automatically shift work offsets when probe is active. Set to 0.000 if probe mounts concentrically in spindle.", 
         "in"},
        {PROBE_VARS.PROBE_Y_OFFSET, 
         "Pound Variable #302: The Y-axis distance from the spindle centerline to the probe tip centerline when deployed. Positive values mean probe is forward of spindle. Used to automatically shift work offsets when probe is active. Set to 0.000 if probe mounts concentrically in spindle.", 
         "in"},
        {PROBE_VARS.PROBE_Z_OFFSET, 
         "Pound Variable #320: The Z-axis calibration offset for the probe trigger point. Positive values move the measured surface UP (probe triggers before actual surface). Negative values move the measured surface DOWN (probe triggers after surface). Use this to calibrate if probe measurements are consistently off from actual surface by a fixed amount. Typical: 0.000\" for properly calibrated probes.", 
         "in"},
        {PROBE_VARS.PROBE_FAST_FEED, 
         "Pound Variable #303: Initial fast approach speed for XYZ probing operations. This is the speed used for the first touch to quickly find the surface. Typical range: 10-30 ipm. Higher speeds save time but may reduce accuracy.", 
         "in/min"},
        {PROBE_VARS.PROBE_SLOW_FEED, 
         "Pound Variable #304: Final slow approach speed for accurate XYZ probing. This is the speed used for the second, precise measurement. Typical range: 1-10 ipm. Slower speeds increase accuracy but take more time.", 
         "in/min"},
        {PROBE_VARS.PROBE_MAX_TRAVEL, 
         "Pound Variable #305: Maximum distance the probe will travel before aborting if no contact is made. Safety feature to prevent probe damage. Should be slightly larger than expected distance to surface. Typical: 0.100-0.500\".", 
         "in"},
        {PROBE_VARS.PROBE_BACKOFF_1, 
         "Pound Variable #306: Distance to retract after first fast probe contact before starting slow probe. Should be enough to ensure probe tip fully releases from surface. Typical: 0.050-0.100\".", 
         "in"},
        {PROBE_VARS.PROBE_BACKOFF_2, 
         "Pound Variable #307: Distance to retract after final slow probe measurement. Final clearance distance from measured surface. Typical: 0.050-0.200\".", 
         "in"}
    })
    
    -- Laser Section (T91)
    addSectionHeader("Laser Cross-Hair (T91)", 
                    "Settings for the spindle-mounted laser used for visual alignment and positioning")
    addInputGrid({
        {PROBE_VARS.LASER_X_OFFSET, 
         "Pound Variable #318: The X-axis distance from the spindle centerline to the laser cross-hair intersection point. Positive values mean laser is to the right of spindle. Used for accurate positioning when laser is active. Measure by comparing laser point to actual spindle position.", 
         "in"},
        {PROBE_VARS.LASER_Y_OFFSET, 
         "Pound Variable #319: The Y-axis distance from the spindle centerline to the laser cross-hair intersection point. Positive values mean laser is forward of spindle. Used for accurate positioning when laser is active. Measure by comparing laser point to actual spindle position.", 
         "in"}
    })
    
    -- Tool Change Section
    addSectionHeader("Tool Change Movement", 
                    "Parameters for automatic tool change positioning and movements")
    addInputGrid({
        {PROBE_VARS.TOOL_CHANGE_Z, 
         "Pound Variable #308: The Z height (in machine coordinates) where tools are safely grabbed and released during tool changes. Should be low enough to engage tool holder but high enough to clear when moving. Typical: -6.0 to -7.0\" depending on tool holder design.", 
         "in"},
        {PROBE_VARS.PULLOUT_DISTANCE, 
         "Pound Variable #309: The Y-axis distance to pull tool forward after grabbing and before lifting to clear the tool holder fork. Prevents tool from catching on holder during lift. Typical: 1.5-2.0\" depending on holder design.", 
         "in"},
        {PROBE_VARS.APPROACH_FEED, 
         "Pound Variable #310: The feedrate used when approaching tool holders during tool change operations. Should be slow enough for smooth engagement but fast enough for efficiency. Typical: 100-300 ipm.", 
         "in/min"}
    })
    
    -- Height Probe Station Section
    addSectionHeader("Height Probe Station", 
                    "Location and reference for the fixed tool height setter")
    addInputGrid({
        {PROBE_VARS.PROBE_STATION_X, 
         "Pound Variable #311: The X machine coordinate of the tool height setter center. This is where tools move to measure their height. Must be accessible from tool change position without interference. Measure in machine coordinates with setter installed.", 
         "in"},
        {PROBE_VARS.PROBE_STATION_Y, 
         "Pound Variable #312: The Y machine coordinate of the tool height setter center. This is where tools move to measure their height. Should be clear of clamps and fixtures. Measure in machine coordinates with setter installed.", 
         "in"},
        {PROBE_VARS.WORK_SURFACE_Z, 
         "Pound Variable #353 - CRITICAL: The Z machine coordinate that represents your actual work surface (spoilboard top). All tool heights are measured as positive distances above this reference. Default -7.8\" is typical for many machines but MUST be calibrated to your specific machine. To calibrate: jog a tool tip to barely touch the spoilboard and note the Z machine coordinate.", 
         "in"}
    })
    
    -- Tool Height Measurement Section
    addSectionHeader("Tool Height Measurement", 
                    "Settings for automatic tool height measurement at the probe station")
    addInputGrid({
        {PROBE_VARS.MAX_PROBE_DEPTH, 
         "Pound Variable #314: Maximum Z depth (in machine coordinates) the tool will travel when searching for the height setter. Prevents crashes if setter is missing or tool is too short. Should be below your work surface but above machine limits. Typical: -9.0 to -10.0\".", 
         "in"},
        {PROBE_VARS.FAST_TOOL_FEED, 
         "Pound Variable #315: Initial fast approach speed when measuring tool height. Used for first contact to quickly find the setter surface. Higher speeds save time during tool changes. Typical: 50-100 ipm.", 
         "in/min"},
        {PROBE_VARS.SLOW_TOOL_FEED, 
         "Pound Variable #316: Final slow approach speed for accurate tool height measurement. Used for second precise measurement. Slower speeds increase repeatability. Typical: 1-5 ipm.", 
         "in/min"},
        {PROBE_VARS.RETRACT_TOOL, 
         "Pound Variable #317: Distance to retract between fast and slow height measurements. Should fully release setter button/plunger. Too small may not release properly, too large wastes time. Typical: 0.050-0.150\".", 
         "in"}
    })
    
    -- Set sizer for scrolled window
    scrollWin:SetSizer(scrollSizer)
    scrollWin:FitInside()
    
    -- Add scrolled window to main sizer
    mainSizer:Add(scrollWin, 1, wx.wxEXPAND + wx.wxALL, 5)
    
    -- Button panel (outside scroll area)
    local btnPanel = wx.wxPanel(mainPanel, wx.wxID_ANY)
    local btnSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
    
    -- Create buttons (no reset button)
    local btnOK = wx.wxButton(btnPanel, wx.wxID_OK, "OK")
    local btnCancel = wx.wxButton(btnPanel, wx.wxID_CANCEL, "Cancel")
    
    btnSizer:AddStretchSpacer()
    btnSizer:Add(btnOK, 0, wx.wxALL, 5)
    btnSizer:Add(btnCancel, 0, wx.wxALL, 5)
    btnPanel:SetSizer(btnSizer)
    
    mainSizer:Add(btnPanel, 0, wx.wxEXPAND + wx.wxALL, 5)
    
    -- Set main panel sizer
    mainPanel:SetSizer(mainSizer)
    
    -- Show dialog
    if dialog:ShowModal() == wx.wxID_OK then
        -- Validate and save
        local allValid = true
        local firstError = nil
        
        for varNum, txt in pairs(inputs) do
            local val = tonumber(txt:GetValue())
            if not val then
                allValid = false
                if not firstError then
                    firstError = txt
                end
            end
        end
        
        if allValid then
            -- Save all values
            for varNum, txt in pairs(inputs) do
                local val = tonumber(txt:GetValue())
                
                -- Save to pound variable (runtime)
                mc.mcCntlSetPoundVar(inst, varNum, val)
                
                -- Save to profile (persistent)
                mc.mcProfileWriteString(inst, "ProbeSettings", 
                                       "Var_" .. varNum, 
                                       string.format("%.6f", val))
            end
            
            -- Force profile write to disk
            mc.mcProfileFlush(inst)
            
            mc.mcCntlSetLastError(inst, "Settings saved successfully")
        else
            wx.wxMessageBox("Please enter valid numeric values for all fields",
                           "Invalid Input", wx.wxOK + wx.wxICON_ERROR)
            if firstError then
                firstError:SetFocus()
            end
        end
    end
    
    dialog:Destroy()
end


-- ============================================
-- Initialize Probe Settings on Startup
-- This section must be in Screen Load Script
-- Place AFTER the function definition above
-- ============================================
do
    local inst = mc.mcGetInstance()
    
    -- Probe and laser variables to initialize
    local probeVars = {
        -- Probe parameters
        {300, 0.250},   -- Probe diameter
        {301, 0.000},   -- Probe X offset
        {302, 0.000},   -- Probe Y offset
        {320, 0.000},   -- Probe Z offset (NEW!)
        {303, 20.000},  -- Probe fast feed
        {304, 5.000},   -- Probe slow feed
        {305, 0.100},   -- Probe max travel
        {306, 0.100},   -- Probe backoff 1
        {307, 0.100},   -- Probe backoff 2
        
        -- Tool change parameters
        {308, -6.500},  -- Tool change Z
        {309, 1.750},   -- Pullout distance
        {310, 200.000}, -- Approach feed
        
        -- Height probe station
        {311, 2.400},   -- Probe station X
        {312, 12.650},  -- Probe station Y
        
        -- Tool height measurement
        {314, -9.000},  -- Max probe depth
        {315, 75.000},  -- Fast tool feed
        {316, 3.000},   -- Slow tool feed
        {317, 0.100},   -- Retract distance
        
        -- Laser offsets
        {318, 0.000},   -- Laser X offset
        {319, 0.000},   -- Laser Y offset
        
        -- Work surface reference
        {353, -7.800}   -- Work surface Z reference
    }
    
    -- Load each from profile or use default
    for _, data in ipairs(probeVars) do
        local varNum, defaultVal = data[1], data[2]
        local v = mc.mcCntlGetPoundVar(inst, varNum)
        
        -- Only initialize if uninitialized (value will be -1.79e308)
        if v < -1e300 then
            local saved = mc.mcProfileGetString(inst, "ProbeSettings", 
                                               "Var_" .. varNum, "NotFound")
            if saved ~= "NotFound" then
                local savedVal = tonumber(saved)
                if savedVal then
                    mc.mcCntlSetPoundVar(inst, varNum, savedVal)
                else
                    mc.mcCntlSetPoundVar(inst, varNum, defaultVal)
                end
            else
                mc.mcCntlSetPoundVar(inst, varNum, defaultVal)
            end
        end
    end
end








-- ============================================
-- GetAllScreenButtons() Helper Function
-- Finds all buttons matching a pattern
-- ============================================
function GetAllScreenButtons(pattern)
    local buttons = {}
    
    -- Check base name
    if scr.GetProperty(pattern, "Bg Color") ~= nil then
        table.insert(buttons, pattern)
    end
    
    -- Check common suffixes
    local suffixes = {"_1", "_2", "_3", "_4", "_5", "(1)", "(2)", "(3)", "_copy", "_dup", "_a", "_b", "_c"}
    for _, suffix in ipairs(suffixes) do
        local name = pattern .. suffix
        if scr.GetProperty(name, "Bg Color") ~= nil then
            table.insert(buttons, name)
        end
    end
    
    -- Check numbered versions up to 10
    for i = 1, 10 do
        local name = pattern .. "_" .. i
        if scr.GetProperty(name, "Bg Color") ~= nil then
            table.insert(buttons, name)
        end
    end
    
    return buttons
end






-- ============================================
-- UpdateWorkOffsetButtons() Function
-- Updates all work offset button states
-- ============================================
function UpdateWorkOffsetButtons()
    local inst = mc.mcGetInstance()
    
    -- Get current work offset from pound variable
    local currentOffset = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14 or 5220)
    
    -- Extract the offset number
    local offsetNum = math.floor(currentOffset)
    
    -- Update all buttons for each offset
    for offset = 54, 59 do
        -- Find all buttons that start with this pattern
        local pattern = string.format("tbtnG%.0f", offset)
        local buttons = GetAllScreenButtons(pattern)
        
        -- Determine if this offset is active
        local isActive = (offset == offsetNum)
        
        -- Update all found buttons
        for _, btnName in ipairs(buttons) do
            if isActive then
                scr.SetProperty(btnName, "Bg Color", "#00FF00")  -- Green
                scr.SetProperty(btnName, "Button State", "1")
            else
                scr.SetProperty(btnName, "Bg Color", "#C0C0C0")  -- Gray
                scr.SetProperty(btnName, "Button State", "0")
            end
        end
    end
end

-- ============================================
-- Initialization Section
-- This goes at the END of Screen Load Script
-- ============================================
-- Initialize work offset buttons on screen load
do
    local inst = mc.mcGetInstance()
    
    -- Small delay to ensure screen is fully loaded
    wx.wxMilliSleep(100)
    
    -- Update buttons to show current work offset
    if UpdateWorkOffsetButtons then
        UpdateWorkOffsetButtons()
        -- No logging here - keeps startup clean
    end
end










-- ============================================
-- Show Fixture Table Modal
-- ============================================

function ShowFixtureTable()
    local inst = mc.mcGetInstance()
    
    -- Get screen dimensions for centering
    local screenWidth = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_X)
    local screenHeight = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_Y)
    local dialogWidth = 735
    local dialogHeight = 250
    
    -- Calculate center position
    local xPos = (screenWidth - dialogWidth) / 2
    local yPos = (screenHeight - dialogHeight) / 2
    
    -- Create dialog with centered position
    local dialog = wx.wxDialog(wx.NULL, wx.wxID_ANY, "Fixture Table",
                              wx.wxPoint(xPos, yPos), wx.wxSize(dialogWidth, dialogHeight))
    
    local panel = wx.wxPanel(dialog, wx.wxID_ANY)
    local mainSizer = wx.wxBoxSizer(wx.wxVERTICAL)
    
    -- Create list control - exact size for 6 rows
    local list = wx.wxListCtrl(panel, wx.wxID_ANY,
                              wx.wxDefaultPosition, wx.wxSize(715, 150),
                              wx.wxLC_REPORT + wx.wxLC_SINGLE_SEL)
    
    -- Add columns - adjusted to fill exactly 715 pixels
    list:InsertColumn(0, "Fixture", wx.wxLIST_FORMAT_LEFT, 100)
    list:InsertColumn(1, "Description", wx.wxLIST_FORMAT_LEFT, 285)
    list:InsertColumn(2, "X", wx.wxLIST_FORMAT_RIGHT, 110)
    list:InsertColumn(3, "Y", wx.wxLIST_FORMAT_RIGHT, 110)
    list:InsertColumn(4, "Z", wx.wxLIST_FORMAT_RIGHT, 110)
    
    -- Get current fixture
    local currentOffset = 54  -- Default
    
    -- Try modal group first (most reliable)
    local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
    if modalOffset >= 54 and modalOffset <= 59 then
        currentOffset = math.floor(modalOffset + 0.5)
    else
        -- Fallback to 5220
        local offset5220 = mc.mcCntlGetPoundVar(inst, 5220)
        if offset5220 >= 54 and offset5220 <= 59 then
            currentOffset = math.floor(offset5220 + 0.5)
        end
    end
    
    -- Store fixture codes
    local fixtureList = {}
    local fixtureData = {}
    local selectedIndex = -1
    
    -- Populate list with ONLY G54-G59
    local itemIndex = 0
    
    for i = 54, 59 do
        local fixture = string.format("G%d", i)
        local desc = GetFixtureDescription(fixture)
        
        -- Get offsets from pound variables
        local baseVar = 5221 + ((i - 54) * 20)
        local x = mc.mcCntlGetPoundVar(inst, baseVar)
        local y = mc.mcCntlGetPoundVar(inst, baseVar + 1)
        local z = mc.mcCntlGetPoundVar(inst, baseVar + 2)
        
        list:InsertItem(itemIndex, fixture)
        list:SetItem(itemIndex, 1, desc)
        list:SetItem(itemIndex, 2, string.format("%.4f", x))
        list:SetItem(itemIndex, 3, string.format("%.4f", y))
        list:SetItem(itemIndex, 4, string.format("%.4f", z))
        
        -- Store fixture code and data
        fixtureList[itemIndex] = fixture
        fixtureData[itemIndex] = {
            fixture = fixture,
            desc = desc,
            values = {x, y, z}
        }
        
        -- Highlight current fixture
        if i == currentOffset then
            list:SetItemBackgroundColour(itemIndex, wx.wxColour(144, 238, 144))  -- Light green
            list:SetItemState(itemIndex, wx.wxLIST_STATE_SELECTED, wx.wxLIST_STATE_SELECTED)
            selectedIndex = itemIndex
            list:EnsureVisible(itemIndex)
        end
        
        itemIndex = itemIndex + 1
    end
    
    mainSizer:Add(list, 1, wx.wxALL + wx.wxEXPAND, 5)
    
    -- Track selection changes
    list:Connect(wx.wxEVT_COMMAND_LIST_ITEM_SELECTED, function(event)
        selectedIndex = event:GetIndex()
    end)
    
    list:Connect(wx.wxEVT_COMMAND_LIST_ITEM_DESELECTED, function(event)
        selectedIndex = -1
    end)
    
    -- Button panel
    local btnSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
    local btnActivate = wx.wxButton(panel, wx.wxID_ANY, "Activate")
    local btnEdit = wx.wxButton(panel, wx.wxID_ANY, "Edit")
    local btnClose = wx.wxButton(panel, wx.wxID_CANCEL, "Close")
    
    btnSizer:Add(btnActivate, 0, wx.wxALL, 5)
    btnSizer:Add(btnEdit, 0, wx.wxALL, 5)
    btnSizer:AddStretchSpacer(1)
    btnSizer:Add(btnClose, 0, wx.wxALL, 5)
    mainSizer:Add(btnSizer, 0, wx.wxEXPAND + wx.wxALL, 5)
    
    -- Event handlers
    btnActivate:Connect(wx.wxEVT_COMMAND_BUTTON_CLICKED, function(event)
        if selectedIndex >= 0 then
            local fixture = fixtureList[selectedIndex]
            if fixture then
                mc.mcCntlMdiExecute(inst, fixture)
                mc.mcCntlSetLastError(inst, fixture .. " Set")
                dialog:EndModal(wx.wxID_OK)
            end
        else
            wx.wxMessageBox("Please select a fixture", "No Selection")
        end
    end)
    
    btnEdit:Connect(wx.wxEVT_COMMAND_BUTTON_CLICKED, function(event)
        if selectedIndex >= 0 then
            local data = fixtureData[selectedIndex]
            if data then
                if EditFixture(data.fixture, data.desc, data.values) then
                    dialog:EndModal(wx.wxID_OK)
                    ShowFixtureTable()  -- Reopen with updated values
                end
            end
        else
            wx.wxMessageBox("Please select a fixture to edit", "No Selection")
        end
    end)
    
    -- Double-click to activate
    list:Connect(wx.wxEVT_COMMAND_LIST_ITEM_ACTIVATED, function(event)
        local index = event:GetIndex()
        if index >= 0 and fixtureList[index] then
            local fixture = fixtureList[index]
            mc.mcCntlMdiExecute(inst, fixture)
            mc.mcCntlSetLastError(inst, fixture .. " Set")
            dialog:EndModal(wx.wxID_OK)
        end
    end)
    
    panel:SetSizer(mainSizer)
    panel:Layout()
    dialog:ShowModal()
    dialog:Destroy()
end





-- ============================================
-- Edit Fixture Function
-- ============================================
function EditFixture(fixtureCode, currentDesc, currentValues)
    local inst = mc.mcGetInstance()
    
    -- Ensure currentValues is valid
    currentValues = currentValues or {0, 0, 0}
    
    -- Create edit dialog
    local dialog = wx.wxDialog(wx.NULL, wx.wxID_ANY, "Edit " .. fixtureCode,
                              wx.wxDefaultPosition, wx.wxSize(400, 350))
    
    local panel = wx.wxPanel(dialog, wx.wxID_ANY)
    local sizer = wx.wxBoxSizer(wx.wxVERTICAL)
    
    -- Description
    sizer:Add(wx.wxStaticText(panel, wx.wxID_ANY, "Description:"), 
              0, wx.wxALL, 5)
    local descCtrl = wx.wxTextCtrl(panel, wx.wxID_ANY, currentDesc)
    sizer:Add(descCtrl, 0, wx.wxALL + wx.wxEXPAND, 5)
    
    sizer:Add(wx.wxStaticLine(panel, wx.wxID_ANY), 0, wx.wxEXPAND + wx.wxALL, 10)
    
    -- Offset inputs
    local offsetCtrls = {}
    local axes = {"X", "Y", "Z"}
    
    for i, axis in ipairs(axes) do
        sizer:Add(wx.wxStaticText(panel, wx.wxID_ANY, axis .. " Offset:"), 
                  0, wx.wxALL, 5)
        local ctrl = wx.wxTextCtrl(panel, wx.wxID_ANY, 
                                  string.format("%.4f", currentValues[i]))
        sizer:Add(ctrl, 0, wx.wxALL + wx.wxEXPAND, 5)
        offsetCtrls[i] = ctrl
    end
    
    -- Create button panel
    local buttonPanel = wx.wxPanel(panel, wx.wxID_ANY)
    local btnSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
    
    local btnSave = wx.wxButton(buttonPanel, wx.wxID_OK, "Save", 
                               wx.wxDefaultPosition, wx.wxSize(80, 30))
    local btnCancel = wx.wxButton(buttonPanel, wx.wxID_CANCEL, "Cancel",
                                 wx.wxDefaultPosition, wx.wxSize(80, 30))
    local btnSetCurrent = wx.wxButton(buttonPanel, wx.wxID_ANY, "Set from Current",
                                    wx.wxDefaultPosition, wx.wxSize(120, 30))
    
    btnSizer:Add(btnSave, 0, wx.wxALL, 5)
    btnSizer:Add(btnCancel, 0, wx.wxALL, 5)
    btnSizer:Add(btnSetCurrent, 0, wx.wxALL, 5)
    
    buttonPanel:SetSizer(btnSizer)
    sizer:Add(buttonPanel, 0, wx.wxALIGN_CENTER + wx.wxALL, 10)
    
    -- Set from current position handler
    btnSetCurrent:Connect(wx.wxEVT_COMMAND_BUTTON_CLICKED, function(event)
        local xPos = mc.mcAxisGetMachinePos(inst, 0)
        local yPos = mc.mcAxisGetMachinePos(inst, 1)
        local zPos = mc.mcAxisGetMachinePos(inst, 2)
        
        offsetCtrls[1]:SetValue(string.format("%.4f", xPos))
        offsetCtrls[2]:SetValue(string.format("%.4f", yPos))
        offsetCtrls[3]:SetValue(string.format("%.4f", zPos))
    end)
    
    panel:SetSizer(sizer)
    panel:Layout()
    
    if dialog:ShowModal() == wx.wxID_OK then
        -- Save description
        SaveFixtureDescription(fixtureCode, descCtrl:GetValue())
        
        -- Save offsets
        local baseVar = GetFixtureBaseVar(fixtureCode)
        if baseVar > 0 then
            for i = 1, 3 do  -- Only X, Y, Z
                local value = tonumber(offsetCtrls[i]:GetValue()) or 0
                mc.mcCntlSetPoundVar(inst, baseVar + (i - 1), value)
            end
            mc.mcCntlSetLastError(inst, "Offset Changes Saved")
        end
        
        dialog:Destroy()
        return true
    end
    
    dialog:Destroy()
    return false
end






-- ============================================
-- Helper Functions
-- ============================================
function GetFixtureDescription(fixtureCode)
    local inst = mc.mcGetInstance()
    -- Remove spaces and dots for storage key
    local key = fixtureCode:gsub("%s", ""):gsub("%.", "")
    return mc.mcProfileGetString(inst, "FixtureDescriptions", key, "")
end

function SaveFixtureDescription(fixtureCode, description)
    local inst = mc.mcGetInstance()
    local key = fixtureCode:gsub("%s", ""):gsub("%.", "")
    mc.mcProfileWriteString(inst, "FixtureDescriptions", key, description)
end

function GetFixtureBaseVar(fixtureCode)
    -- Parse fixture code to get base pound variable
    local g = fixtureCode:match("^G(%d+)$")
    if g then
        local num = tonumber(g)
        if num >= 54 and num <= 59 then
            return 5221 + ((num - 54) * 20)
        end
    end
    return 0
end





-- ============================================
-- Soft Limits Initialization
-- Enable soft limits by default on startup
-- ============================================
do
    local inst = mc.mcGetInstance()
    
    -- Enable soft limits for ALL enabled axes
    for axis = 0, 5 do
        if mc.mcAxisIsEnabled(inst, axis) == 1 then
            mc.mcSoftLimitSetState(inst, axis, 1)
        end
    end
	
    local softLimitsHandle = mc.mcSignalGetHandle(inst, mc.OSIG_SOFTLIMITS_ON)
    if softLimitsHandle and softLimitsHandle > 0 then
        mc.mcSignalSetState(softLimitsHandle, 1)
    end
end





-- ============================================
-- SyncSoftLimitsButton() Function
-- Synchronizes button appearance with actual state
-- ============================================
function SyncSoftLimitsButton()
    local inst = mc.mcGetInstance()
    
    -- Get soft limits signal handle
    local hsig = mc.mcSignalGetHandle(inst, mc.OSIG_SOFTLIMITS_ON)
    if not hsig or hsig < 1 then
        -- Invalid handle - set to error state
        scr.SetProperty("btnSoftLimits", "Bg Color", "#808080")  -- Gray
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nERROR")
        return
    end
    
    -- Get current state
    local enabled = mc.mcSignalGetState(hsig)
    
    -- Update button appearance
    if enabled == 1 then
        scr.SetProperty("btnSoftLimits", "Bg Color", "#00FF00")  -- Green
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nENABLED")
    else
        scr.SetProperty("btnSoftLimits", "Bg Color", "#FF0000")  -- Red
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nDISABLED")
    end
end






-- ============================================
-- DUST COLLECTION BUTTON SYNCHRONIZATION
-- ============================================
function SyncDustButtons()
    local inst = mc.mcGetInstance()
    
    -- Sync btnDustCollectAuto button (#400)
    local dustCollectState = mc.mcCntlGetPoundVar(inst, 400)
    scr.SetProperty("btnDustCollectAuto", "Bg Color", dustCollectState > 0 and "#00FF00" or "#FF0000")
    
    -- Sync btnDustBootAuto button (#402)
    local dustBootState = mc.mcCntlGetPoundVar(inst, 402)
    scr.SetProperty("btnDustBootAuto", "Bg Color", dustBootState > 0 and "#00FF00" or "#FF0000")
    
    -- Sync btnVacuumAuto button (#401) if it exists
    if scr.GetProperty("btnVacuumAuto", "Bg Color") ~= nil then
        local vacuumState = mc.mcCntlGetPoundVar(inst, 401)
        scr.SetProperty("btnVacuumAuto", "Bg Color", vacuumState > 0 and "#00FF00" or "#FF0000")
    end
end

-- ============================================
-- Initialize dust collection automation system
-- ============================================
do
    local inst = mc.mcGetInstance()
    
    -- Force all automations OFF on startup
    mc.mcCntlSetPoundVar(inst, 400, 0)  -- Dust collection OFF
    mc.mcCntlSetPoundVar(inst, 401, 0)  -- Vacuum auto OFF
    mc.mcCntlSetPoundVar(inst, 402, 0)  -- Dust boot auto OFF
    
    -- Set all buttons to red (disabled state)
    scr.SetProperty("btnDustCollectAuto", "Bg Color", "#FF0000")
    scr.SetProperty("btnDustBootAuto", "Bg Color", "#FF0000")
    
    if scr.GetProperty("btnVacuumAuto", "Bg Color") ~= nil then
        scr.SetProperty("btnVacuumAuto", "Bg Color", "#FF0000")
    end
end





-- ============================================
-- GLOBAL ROTATION CHECK FUNCTIONS
-- For use in all probing and positioning scripts
-- ============================================
function IsG68Active()
    local inst = mc.mcGetInstance()
    -- Group 16 (rotation) modal code: 68 = G68, 69 = G69
    local MOD_ROT = 4016
    local v = mc.mcCntlGetPoundVar(inst, MOD_ROT)
    if type(v) ~= "number" then return false end
    return (math.floor(v + 0.5) == 68)
end

function CheckRotationWithPrompt(customMessage)
    local inst = mc.mcGetInstance()
    if IsG68Active() then
        local message = customMessage or 
            "Warning: This operation will reset all coordinate rotations (G68→G69).\nProceed?"
        
        local parent = wx.NULL
        local app = wx.wxGetApp()
        if app then pcall(function() parent = app:GetTopWindow() or wx.NULL end) end
        
        local res = wx.wxMessageBox(message, "Rotation Active", 
                                   wx.wxYES_NO + wx.wxICON_WARNING, parent)
        if res ~= wx.wxYES then
            mc.mcCntlSetLastError(inst, "Operation cancelled (G68 active)")
            return false
        end
        -- User approved: clear rotation
        mc.mcCntlGcodeExecuteWait(inst, "G69")
        return true
    else
        return true
    end
end

_G.CheckRotationWithPrompt = CheckRotationWithPrompt





-- ============================================
-- M6 FLAG RECOVERY FOR DUST BOOT AUTOMATION
-- ============================================
-- This clears any stale flags from crashes or E-stops
-- Must be at the end of Screen Load Script
do
    local inst = mc.mcGetInstance()
    
    -- Clear any stale M6 flags from crash/E-stop
    mc.mcCntlSetPoundVar(inst, 499, 0)  -- M6 not running
    mc.mcCntlSetPoundVar(inst, 481, 0)  -- No pending completion
    
    -- Clear motion tracking flags
    _G.waitingForMotionAfterToolChange = false
    _G.motionHasStarted = false
    
    -- Check current tool and notify user if needed
    local currentTool = mc.mcToolGetCurrent(inst)
    if currentTool > 0 and currentTool < 90 then
        -- Physical tool loaded - user needs to run program for boot automation
        if mc.mcCntlGetPoundVar(inst, 402) == 1 then  -- If boot auto enabled
            mc.mcCntlSetLastError(inst, string.format("T%d loaded - dust boot will lower on first cut", currentTool))
        end
    elseif currentTool >= 90 and currentTool <= 99 then
        -- Virtual tool loaded - ensure boot is up
        local hBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
        if hBoot and hBoot > 0 then
            mc.mcSignalSetState(hBoot, 0)  -- Raise boot
        end
        mc.mcCntlSetLastError(inst, string.format("Virtual T%d active - dust boot raised", currentTool))
    end
    
    -- Log that dust boot automation is ready
    if mc.mcCntlGetPoundVar(inst, 402) == 1 then
        mc.mcCntlSetLastError(inst, "Dust boot automation ready")
    end
end
