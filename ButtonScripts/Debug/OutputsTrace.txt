--[[
Mach4 Output Flip Diagnostic v2 (edge + persistence)
Purpose: Reconcile “my tiny script turns them OFF permanently” vs. “manual/direct OFF fails in diag.”
Key: Detect edge‑triggered/latching reassertors and persistence timing.

What it does:
  * Tests OFF behavior under four scenarios per device:
      1) MANUAL OFF without priming (no prior ON)
      2) MANUAL OFF after ON (prime rising edge)
      3) DIRECT OFF without priming
      4) DIRECT OFF after ON (prime rising edge)
  * Runs each with AUTO PV = 0 and AUTO PV = 1
  * Records immediate readback and delayed readback (200 ms, 1000 ms)
  * Optional “hammer” (setSig(0) every 5 ms for 300 ms) to see if a continuous writer exists
  * Saves report to: Profiles/<Profile>/Reports/OutputFlipDiagV2-YYYYMMDD-HHMMSS.log

How to run:
  * Paste into Lua editor (Operator ▸ Edit/Debug Scripts), Run.
  * Machine ENABLED for realistic behavior (note: some mappings only act when enabled).
  * If you can, test twice: (A) Brains enabled, (B) Brains disabled, compare summaries.

Interpreting classes:
  * OK_STICK        – OFF holds across all delays
  * REASSERT_EDGE   – OFF only fails when we first drive ON (prime). Classic Brain latch.
  * REASSERT_CONT   – OFF fails even without prime; likely continuous writer
  * AUX_DOMINATES   – MANUAL OFF fails but DIRECT OFF holds; Aux/auto/safety logic overrides
  * AUTO_REQUIRED   – OFF only works when AUTO=0 (expected if you want auto to dominate)

]]

local mc = mc
local wx = require("wx")

-- ==== simple io/log helpers ===================================================
local function getProfileDir(inst)
  local mach = mc.mcCntlGetMachDir(inst)
  local ok, prof = pcall(mc.mcProfileGetName, inst)
  return mach .. "\\Profiles\\" .. (ok and prof or "BLP")
end
local function nowStamp()
  local t = os.date("!*t"); return string.format("%04d%02d%02d-%02d%02d%02d",t.year,t.month,t.day,t.hour,t.min,t.sec) end
local function ensureDir(path) os.execute(string.format('if not exist "%s" mkdir "%s"', path, path)) end
local function newLogger(inst)
  local base = getProfileDir(inst) .. "\\Reports"; ensureDir(base)
  local file = base .. "\\OutputFlipDiagV2-" .. nowStamp() .. ".log"
  local fh = assert(io.open(file, "w"))
  local function log(fmt, ...)
    local msg = (select('#', ...) > 0) and string.format(fmt, ...) or tostring(fmt)
    fh:write(os.date("%H:%M:%S "), msg, "\n"); fh:flush(); mc.mcCntlSetLastError(inst, msg)
  end
  return { file=file, log=log, close=function() fh:close() end }
end

-- ==== core Mach helpers =======================================================
local function sigHandle(inst, id) local ok,h=pcall(mc.mcSignalGetHandle,inst,id); return ok and h or nil end
local function sigGet(h) local ok,s=pcall(mc.mcSignalGetState,h); return ok and (s==1 and 1 or 0) or -1 end
local function sigSet(h,v) local ok=pcall(mc.mcSignalSetState,h,(v and 1 or 0)); return ok end
local function pvGet(inst,n) local ok,v=pcall(mc.mcCntlGetPoundVar,inst,n); return ok and tonumber(v) or nil end
local function pvSet(inst,n,v) pcall(mc.mcCntlSetPoundVar,inst,n,tonumber(v) or 0) end

-- optional library
local AuxLib = rawget(_G, "AuxLib")

-- ==== device map (matches your project) =======================================
local DEV = {
  { key="dust",     name="Dust Collect", osig=mc.OSIG_OUTPUT4, autoPV=400, tgtPV=404 },
  { key="boot",     name="Dust Boot",    osig=mc.OSIG_OUTPUT3, autoPV=402, tgtPV=403 },
  { key="vacRear",  name="Vac Rear",     osig=mc.OSIG_OUTPUT5, autoPV=401, tgtPV=411 },
  { key="vacFront", name="Vac Front",    osig=mc.OSIG_OUTPUT6, autoPV=401, tgtPV=412 },
}

-- ==== utilities ===============================================================
local function sample(msDelays, reader)
  local out = {}
  for _,ms in ipairs(msDelays) do wx.wxMilliSleep(ms); out[#out+1]=reader() end
  return out
end

local function hammerOff(h, durationMs, periodMs)
  local t=0
  while t < durationMs do sigSet(h,0); wx.wxMilliSleep(periodMs); t=t+periodMs end
end

local function auxUpdate(inst)
  if AuxLib and AuxLib.Update then pcall(AuxLib.Update, inst) end
end

-- One scenario run
local function runScenario(inst, L, d, h, opt)
  -- opt: {auto=0/1, prime=false/true, method="manual"|"direct"}
  pvSet(inst, d.autoPV, opt.auto or 0)
  auxUpdate(inst)

  local s0 = sigGet(h)
  local tgt0 = pvGet(inst, d.tgtPV) or 0
  L.log("Scenario %-7s auto=%d prime=%s start: OSIG=%d TGT=%d", opt.method, opt.auto or 0, tostring(opt.prime), s0, tgt0)

  -- optional prime (force ON first)
  if opt.prime then
    if opt.method=="manual" then pvSet(inst, d.tgtPV, 1); auxUpdate(inst) else sigSet(h,1) end
    wx.wxMilliSleep(30)
  end

  -- attempt OFF
  if opt.method=="manual" then
    pvSet(inst, d.tgtPV, 0); auxUpdate(inst)
  else
    sigSet(h, 0)
  end

  local imm, after200, after1000 = table.unpack(sample({0,200,800}, function() return sigGet(h) end))
  L.log("  OFF readback: immediate=%d, +200ms=%d, +1000ms=%d", imm, after200, after1000)

  -- hammer to see if a continuous writer exists
  hammerOff(h, 300, 5)
  local afterHammer = sigGet(h)
  L.log("  after hammer(300ms,5ms): %d", afterHammer)

  -- classify
  local class
  if imm==0 and after200==0 and after1000==0 then class="OK_STICK"
  elseif (not opt.prime) and (imm==0) and (after200==1 or after1000==1) then class="REASSERT_CONT"
  elseif opt.prime and (imm==0) and (after200==1 or after1000==1) then class="REASSERT_EDGE"
  elseif opt.method=="manual" and (imm==1 and after200==1 and after1000==1) then class="AUX_DOMINATES"
  else class="MIXED"
  end

  return {class=class, imm=imm, d200=after200, d1000=after1000, afterHammer=afterHammer}
end

local function RunV2()
  local inst = mc.mcGetInstance(); if not inst then return end
  local L = newLogger(inst)
  local en = mc.mcSignalGetState(mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED))
  L.log("Output Flip Diag v2 start (MachineEnabled=%d)", en==1 and 1 or 0)

  local results = {}
  for _,d in ipairs(DEV) do
    local h = sigHandle(inst, d.osig)
    L.log("\n=== %s (%s) ===", d.name, d.key)
    results[d.key] = {}
    for _,auto in ipairs({0,1}) do
      for _,prime in ipairs({false,true}) do
        for _,method in ipairs({"manual","direct"}) do
          local r = runScenario(inst, L, d, h, {auto=auto, prime=prime, method=method})
          local tag = string.format("auto%d_%s_%s", auto, prime and "prime" or "noprime", method)
          results[d.key][tag] = r
        end
      end
    end
  end

  L.log("\n=== SUMMARY ===")
  for _,d in ipairs(DEV) do
    L.log("%s:", d.key)
    for _,auto in ipairs({0,1}) do
      for _,prime in ipairs({false,true}) do
        for _,method in ipairs({"manual","direct"}) do
          local tag = string.format("auto%d_%s_%s", auto, prime and "prime" or "noprime", method)
          local r = results[d.key][tag]
          L.log("  %-18s -> %-14s  (imm=%d, +200=%d, +1000=%d, hammer=%d)", tag, r.class or "?", r.imm, r.d200, r.d1000, r.afterHammer)
        end
      end
    end
  end
  L.log("\nReport: %s", L.file)
  L.close()
end

RunV2()
