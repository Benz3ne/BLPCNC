-- Inside Corner Probe v4.0 - Library Enhanced Edition
-- Finds the corner of an inside pocket by probing two adjacent walls
-- Uses ProbeLib v2.1 enhanced library functions
-- Maintains local control of dialog layout and business logic

-- Load libraries
local ProbeLib = require("ProbeLib")
local SystemLib = require("SystemLib")
local UILib = require("UILib")

local inst = ProbeLib.Core.GetInstance()

-- ============================================
-- ROTATION CHECK
-- ============================================
if not ProbeLib.Safety.CheckRotation(inst, "warn") then
    return  -- User cancelled due to rotation
end

-- ============================================
-- TOOL CHECK
-- ============================================
if not ProbeLib.Core.ActivateProbeTool(inst) then
    return  -- User cancelled tool activation
end

-- ============================================
-- PROBE PRECHECK
-- ============================================
if not ProbeLib.Safety.EnsureProbeNotTripped(inst) then
    return  -- Probe is stuck triggered
end

-- ============================================
-- SETTINGS MANAGEMENT (using ProbeLib)
-- ============================================
local settings = SystemLib.Storage.CreateSettings(inst, "InsideCorner", {
    CornerType = 1,    -- 1=LL, 2=LR, 3=UR, 4=UL
    ActionMode = 1     -- 1=Set Datum, 2=Print Coords
})

-- Load saved settings
local lastCornerType = settings:getInt("CornerType", 1)
local lastActionMode = settings:getInt("ActionMode", 1)

-- ============================================
-- CREATE DIALOG (using UILib resizable dialog)
-- ============================================
local parent = UILib.Msg.GetParent()

-- Create resizable dialog with saved geometry
local dlg, panel, mainSizer = UILib.ResizableDialog.CreateWithPanel(
    parent, "Inside Corner Probe Setup", "InsideCornerProbe", 380, 400
)

-- Instructions
local instructText = wx.wxStaticText(panel, wx.wxID_ANY,
    "Position the probe near an inside corner:\n" ..
    "• Within probing distance of both walls\n" ..
    "• At the desired probing depth\n" ..
    "• Probe will move toward the selected corner")
instructText:SetFont(UILib.Styles.Fonts.Default)
mainSizer:Add(instructText, 0, wx.wxALL, 10)

-- Corner Selection with visual grid
local cornerBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Select Corner")

-- Create a 3x3 grid of buttons for corner selection
local gridSizer = wx.wxGridSizer(3, 3, 5, 5)

-- Corner button IDs
local CORNER_UL = wx.wxNewId()
local CORNER_UR = wx.wxNewId()
local CORNER_LL = wx.wxNewId()
local CORNER_LR = wx.wxNewId()

-- Create corner buttons
local cornerButtons = {}

-- Top row
gridSizer:Add(0, 0, 1, wx.wxEXPAND)  -- Empty
local btnUp = wx.wxButton(panel, wx.wxID_ANY, "↑", wx.wxDefaultPosition, wx.wxSize(40, 40))
btnUp:Enable(false)
gridSizer:Add(btnUp, 0, wx.wxALIGN_CENTER)
gridSizer:Add(0, 0, 1, wx.wxEXPAND)  -- Empty

-- Middle row
local btnLeft = wx.wxButton(panel, wx.wxID_ANY, "←", wx.wxDefaultPosition, wx.wxSize(40, 40))
btnLeft:Enable(false)
gridSizer:Add(btnLeft, 0, wx.wxALIGN_CENTER)

-- Center workpiece indicator
local centerPanel = wx.wxPanel(panel, wx.wxID_ANY, wx.wxDefaultPosition, wx.wxSize(60, 60))
centerPanel:SetBackgroundColour(wx.wxColour(200, 200, 200))
gridSizer:Add(centerPanel, 0, wx.wxALIGN_CENTER)

local btnRight = wx.wxButton(panel, wx.wxID_ANY, "→", wx.wxDefaultPosition, wx.wxSize(40, 40))
btnRight:Enable(false)
gridSizer:Add(btnRight, 0, wx.wxALIGN_CENTER)

-- Bottom row
gridSizer:Add(0, 0, 1, wx.wxEXPAND)  -- Empty
local btnDown = wx.wxButton(panel, wx.wxID_ANY, "↓", wx.wxDefaultPosition, wx.wxSize(40, 40))
btnDown:Enable(false)
gridSizer:Add(btnDown, 0, wx.wxALIGN_CENTER)
gridSizer:Add(0, 0, 1, wx.wxEXPAND)  -- Empty

cornerBox:Add(gridSizer, 0, wx.wxALL + wx.wxALIGN_CENTER, 10)

-- Corner selection radio box
local cornerChoices = {
    "Lower Left (LL)",
    "Lower Right (LR)", 
    "Upper Right (UR)",
    "Upper Left (UL)"
}
local cornerRadio = UILib.Controls.CreateRadioBox(panel, "Corner Position", cornerChoices, lastCornerType - 1, 2)
cornerBox:Add(cornerRadio, 0, wx.wxEXPAND + wx.wxALL, 5)

mainSizer:Add(cornerBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Options
local optionsBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Options")
local actionChoices = {"Set Datum (X=0, Y=0)", "Print Corner Coordinates"}
local actionRadio = UILib.Controls.CreateRadioBox(panel, "Action", actionChoices, lastActionMode - 1, 1)
optionsBox:Add(actionRadio, 0, wx.wxEXPAND + wx.wxALL, 5)
mainSizer:Add(optionsBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Update visual indicators based on corner selection
local function UpdateCornerIndicators()
    local corner = cornerRadio:GetSelection() + 1
    
    -- Enable/disable directional buttons based on corner
    btnLeft:Enable(corner == 1 or corner == 4)   -- LL or UL
    btnRight:Enable(corner == 2 or corner == 3)  -- LR or UR
    btnDown:Enable(corner == 1 or corner == 2)   -- LL or LR
    btnUp:Enable(corner == 3 or corner == 4)     -- UR or UL
end

-- Connect event
cornerRadio:Connect(wx.wxID_ANY, wx.wxEVT_COMMAND_RADIOBOX_SELECTED, function(event)
    UpdateCornerIndicators()
end)

-- Initial update
UpdateCornerIndicators()

-- Spacer
mainSizer:AddStretchSpacer()

-- Buttons
local buttonSizer, okBtn, cancelBtn = UILib.Controls.CreateButtonSizer(panel, "OK", "Cancel")
mainSizer:Add(buttonSizer, 0, wx.wxALL + wx.wxALIGN_CENTER, 8)

-- Apply layout
panel:SetSizer(mainSizer)
dlg:Fit()

-- ============================================
-- SHOW DIALOG AND PROCESS
-- ============================================
if dlg:ShowModal() == wx.wxID_OK then
    -- Get values
    local cornerType = cornerRadio:GetSelection() + 1
    local actionSel = actionRadio:GetSelection() + 1
    
    -- Save settings
    settings:setInt("CornerType", cornerType)
    settings:setInt("ActionMode", actionSel)
    
    dlg:Destroy()
    
    -- ============================================
    -- EXECUTE PROBE SEQUENCE
    -- ============================================
    local function ExecuteInsideCornerProbe()
        -- Check if probe is already triggered
        if ProbeLib.Core.IsProbeTriggered(inst) then
            UILib.Msg.Error("Probe is already triggered!\n\nPlease clear the probe and try again.", "Probe Error")
            return false
        end
        
        -- Store starting position
        local startState = {
            machX = mc.mcAxisGetMachinePos(inst, 0),
            machY = mc.mcAxisGetMachinePos(inst, 1),
            machZ = mc.mcAxisGetMachinePos(inst, 2),
            workX = mc.mcAxisGetPos(inst, mc.X_AXIS),
            workY = mc.mcAxisGetPos(inst, mc.Y_AXIS),
            workZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
        }
        
        -- Get probe parameters
        local probeTipDia = mc.mcCntlGetPoundVar(inst, 300) or 0.118
        local fastFeed = mc.mcCntlGetPoundVar(inst, 303) or 30
        local slowFeed = mc.mcCntlGetPoundVar(inst, 304) or 5
        local maxTravel = mc.mcCntlGetPoundVar(inst, 305) or 1.0
        
        -- Define probe directions based on corner type
        -- Corner types: 1=LL, 2=LR, 3=UR, 4=UL
        local xDirection, yDirection
        local xProbeDir, yProbeDir
        local xSign, ySign
        
        if cornerType == 1 then  -- Lower Left
            xDirection = 2  -- S2 = -X
            yDirection = 4  -- S4 = -Y
            xSign = -1
            ySign = -1
        elseif cornerType == 2 then  -- Lower Right
            xDirection = 1  -- S1 = +X
            yDirection = 4  -- S4 = -Y
            xSign = 1
            ySign = -1
        elseif cornerType == 3 then  -- Upper Right
            xDirection = 1  -- S1 = +X
            yDirection = 3  -- S3 = +Y
            xSign = 1
            ySign = 1
        else  -- Upper Left (4)
            xDirection = 2  -- S2 = -X
            yDirection = 3  -- S3 = +Y
            xSign = -1
            ySign = 1
        end
        
        local probeResults = {}
        local success = true
        local errorMsg = nil
        
        -- Probe X wall
        mc.mcCntlSetLastError(inst, "Probing X wall...")
        local xSuccess, xEdgeWork, xEdgeMachine = ProbeLib.Movement.ExecuteProbe(inst, xDirection, "X wall")
        
        if not xSuccess then
            errorMsg = "X wall probe failed - no contact"
            success = false
        else
            probeResults.xEdge = xEdgeWork
            
            -- Retract from X wall
            mc.mcCntlSetLastError(inst, "Retracting from X wall...")
            local retractCmd = string.format("G91 G1 X%.4f F%.1f", -xSign * 0.1, fastFeed)
            mc.mcCntlGcodeExecuteWait(inst, retractCmd)
            mc.mcCntlGcodeExecuteWait(inst, "G90")
        end
        
        -- Probe Y wall if X was successful
        if success then
            -- Check probe state before Y probe
            if ProbeLib.Core.IsProbeTriggered(inst) then
                errorMsg = "Probe stuck before Y wall probe"
                success = false
            else
                mc.mcCntlSetLastError(inst, "Probing Y wall...")
                local ySuccess, yEdgeWork, yEdgeMachine = ProbeLib.Movement.ExecuteProbe(inst, yDirection, "Y wall")
                
                if not ySuccess then
                    errorMsg = "Y wall probe failed - no contact"
                    success = false
                else
                    probeResults.yEdge = yEdgeWork
                    
                    -- Retract from Y wall
                    mc.mcCntlSetLastError(inst, "Retracting from Y wall...")
                    local retractCmd = string.format("G91 G1 Y%.4f F%.1f", -ySign * 0.1, fastFeed)
                    mc.mcCntlGcodeExecuteWait(inst, retractCmd)
                    mc.mcCntlGcodeExecuteWait(inst, "G90")
                end
            end
        end
        
        -- Process results if successful
        if success then
            -- Move to corner position
            mc.mcCntlSetLastError(inst, "Moving to corner...")
            local moveCmd = string.format("G0 X%.4f Y%.4f", probeResults.xEdge, probeResults.yEdge)
            mc.mcCntlGcodeExecuteWait(inst, moveCmd)
            
            -- Execute action
            if actionSel == 1 then  -- Set Datum
                -- Get current machine position to set as zero
                local machX = mc.mcAxisGetMachinePos(inst, 0)
                local machY = mc.mcAxisGetMachinePos(inst, 1)
                ProbeLib.Core.ApplyOrPrint(inst, actionSel, {x = machX, y = machY}, 0)
                
                UILib.Msg.Info(
                    "Work zero set at inside corner:\nX=0, Y=0\n\n" ..
                    string.format("Corner: %s", cornerChoices[cornerType]),
                    "Datum Set")
            else  -- Print Coords
                local msg = string.format(
                    "Inside Corner Coordinates:\nX: %.4f\nY: %.4f\n\nCorner: %s",
                    probeResults.xEdge, probeResults.yEdge, cornerChoices[cornerType]
                )
                UILib.Msg.Info(msg, "Corner Position")
            end
            
            -- Log the probe event
            ProbeLib.Logging.LogEvent(inst, "InsideCorner", 
                probeResults.xEdge, 
                probeResults.yEdge, 
                startState.workZ, 
                string.format("Corner:%s Action:%d", cornerChoices[cornerType], actionSel))
        end
        
        -- Cleanup
        ProbeLib.Cleanup.Standard(inst, success, errorMsg)
        
        return success
    end
    
    -- Execute with error handling
    local ok, err = pcall(ExecuteInsideCornerProbe)
    if not ok then
        UILib.Msg.Error("Inside corner probe failed:\n" .. tostring(err), "Probe Error")
    end
else
    dlg:Destroy()
end