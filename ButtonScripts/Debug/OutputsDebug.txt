-- OutputsDebug.txt
-- Comprehensive diagnostic for Mach4 outputs 3..6 staying high
-- Safe: does not enable machine, does not change e-stop. Optionally forces PVs to reduce interference.

local inst = mc.mcGetInstance()

-- User options
local FORCE_AUTOS_OFF   = true   -- set true to force #400/#401/#402=0 and targets #404/#403/#411/#412=0 before tests
local DELAY_MS          = 150     -- delay after writes before delayed readback
local TEST_OUTPUTS      = {3,4,5,6}
local STEP_DELAY_MS     = 200     -- delay between logical steps when using AuxLib

local function log(level, msg)
  level = level or "INFO"
  mc.mcCntlSetLastError(inst, string.format("[OUTDBG][%s] %s", level, tostring(msg)))
end

local function sigConst(n)
  return mc[string.format("OSIG_OUTPUT%d", n)]
end

local function getHandle(n)
  local id = sigConst(n)
  if not id then return nil end
  local h = mc.mcSignalGetHandle(inst, id)
  return h, id
end

local function readState(n)
  local h, id = getHandle(n)
  if not h or h == 0 then return nil, id, h end
  local st = mc.mcSignalGetState(h)
  return st, id, h
end

local function writeState(n, val)
  local h, id = getHandle(n)
  if not h or h == 0 then return false, id, h, nil, nil end
  mc.mcSignalSetState(h, (val and 1 or 0))
  local imm = mc.mcSignalGetState(h)
  wx.wxMilliSleep(DELAY_MS)
  local aft = mc.mcSignalGetState(h)
  return true, id, h, imm, aft
end

local function pvGet(num)
  local v
  if SystemLib and SystemLib.PoundVarGet then v = SystemLib.PoundVarGet(inst, num) else v = mc.mcCntlGetPoundVar(inst, num) end
  return (type(v)=="number") and v or (tonumber(v) or 0)
end

local function pvSet(num, val)
  if SystemLib and SystemLib.PoundVarSet then return SystemLib.PoundVarSet(inst, num, val) else return mc.mcCntlSetPoundVar(inst, num, val) end
end

local function snapshotAux()
  if not AuxLib then return end
  log("INFO", "Aux devices + PV snapshot:")
  for name, d in pairs(AuxLib.__dev or {}) do
    local spec = d.spec or {}
    local pv   = spec.pv or {}
    local auto = pv.auto and pvGet(pv.auto) or -1
    local targ = pv.target and pvGet(pv.target) or -1
    local outs = {}
    for k, sigName in pairs(spec.outputs or {}) do table.insert(outs, string.format("%s=%s", k, tostring(sigName))) end
    log("INFO", string.format("  %s: auto#%s=%s target#%s=%s outputs={%s}", tostring(name), tostring(pv.auto), tostring(auto), tostring(pv.target), tostring(targ), table.concat(outs, ", ")))    
  end
end

local function maybeForceAutos()
  if not FORCE_AUTOS_OFF then return end
  log("WARNING", "FORCE_AUTOS_OFF=true -> clearing autos (#400/#401/#402) and targets (#404/#403/#411/#412)")
  pvSet(400,0); pvSet(401,0); pvSet(402,0)
  pvSet(404,0); pvSet(403,0); pvSet(411,0); pvSet(412,0)
end

local function enabled()
  local h = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
  return (h and h~=0 and mc.mcSignalGetState(h) == 1) and 1 or 0
end

-- Header
log("INFO", "=== Outputs Debug: begin ===")
log("INFO", string.format("Profile=%s  Time=%s", tostring(mc.mcProfileGetName(inst)), os.date("%Y-%m-%d %H:%M:%S")))
log("INFO", string.format("Machine enabled=%d  Delay=%dms  FORCE_AUTOS_OFF=%s", enabled(), DELAY_MS, tostring(FORCE_AUTOS_OFF)))

snapshotAux()
maybeForceAutos()

-- Map devices -> output numbers for cross checks
local DEV_OUT = {
  dust    = 4,
  boot    = 3,
  vacRear = 5,
  vacFront= 6,
}

local function outStateForDevice(name)
  local n = DEV_OUT[name]
  if not n then return nil end
  local st = readState(n)
  return st
end

local function auxState(name)
  if not AuxLib or not AuxLib.State then return nil end
  local st = AuxLib.State(inst, name) or {}
  return {
    on = st.on,
    auto = st.auto,
    target = st.target,
  }
end

local function requestAndUpdate(name, action)
  if not AuxLib or not AuxLib.Request then return false, "AuxLib missing" end
  local ok, err = pcall(AuxLib.Request, inst, { device=name, action=action })
  if not ok then return false, tostring(err) end
  if AuxLib.Update then pcall(AuxLib.Update, inst) end
  wx.wxMilliSleep(STEP_DELAY_MS)
  return true
end

-- SECTION A: AuxLib manual ON/OFF per device
log("INFO", "-- SECTION A: AuxLib manual toggle (auto=0) --")
for name, outN in pairs(DEV_OUT) do
  -- Ensure auto off for this device
  requestAndUpdate(name, "auto.off")
  -- Manual ON
  requestAndUpdate(name, "manual.on")
  local st_on    = readState(outN)
  local a_on     = auxState(name)
  log("INFO", string.format("%s manual.on -> output%d=%s  aux={on=%s,auto=%s,target=%s}", name, outN, tostring(st_on and st_on or "nil"), tostring(a_on and a_on.on), tostring(a_on and a_on.auto), tostring(a_on and a_on.target)))
  -- Manual OFF
  requestAndUpdate(name, "manual.off")
  local st_off   = readState(outN)
  local a_off    = auxState(name)
  log("INFO", string.format("%s manual.off -> output%d=%s aux={on=%s,auto=%s,target=%s}", name, outN, tostring(st_off and st_off or "nil"), tostring(a_off and a_off.on), tostring(a_off and a_off.auto), tostring(a_off and a_off.target)))
end

-- SECTION B: AuxLib auto toggle (effect depends on policy)
log("INFO", "-- SECTION B: AuxLib auto toggle --")
for name, outN in pairs(DEV_OUT) do
  requestAndUpdate(name, "auto.on")
  local st_aon  = readState(outN)
  local as_on   = auxState(name)
  log("INFO", string.format("%s auto.on -> output%d=%s aux={on=%s,auto=%s,target=%s}", name, outN, tostring(st_aon and st_aon or "nil"), tostring(as_on and as_on.on), tostring(as_on and as_on.auto), tostring(as_on and as_on.target)))
  requestAndUpdate(name, "auto.off")
  local st_aoff = readState(outN)
  local as_off  = auxState(name)
  log("INFO", string.format("%s auto.off -> output%d=%s aux={on=%s,auto=%s,target=%s}", name, outN, tostring(st_aoff and st_aoff or "nil"), tostring(as_off and as_off.on), tostring(as_off and as_off.auto), tostring(as_off and as_off.target)))
end

-- SECTION C: Direct write vs AuxLib re-apply
log("INFO", "-- SECTION C: Direct write OFF/ON with and without AuxLib.Update --")
for _, n in ipairs(TEST_OUTPUTS) do
  local st0, id, h = readState(n)
  log("INFO", string.format("O%d start=%s", n, tostring(st0)))
  -- Direct OFF only
  local ok0, _, _, imm0, aft0 = writeState(n, 0)
  log("INFO", string.format("O%d direct OFF -> imm=%s delayed=%s (no Update)", n, tostring(imm0), tostring(aft0)))
  -- Now force an Aux Update and read again
  if AuxLib and AuxLib.Update then pcall(AuxLib.Update, inst); wx.wxMilliSleep(STEP_DELAY_MS) end
  local st_afterUpd = select(1, readState(n))
  log("INFO", string.format("O%d after Aux.Update -> %s", n, tostring(st_afterUpd)))
  -- Direct ON + read
  local ok1, _, _, imm1, aft1 = writeState(n, 1)
  log("INFO", string.format("O%d direct ON  -> imm=%s delayed=%s", n, tostring(imm1), tostring(aft1)))
end

-- SECTION D: Per-output diagnostic (immediate + delayed) â€” original block
log("INFO", "-- SECTION D: Low-level signal write/read --")
for _, n in ipairs(TEST_OUTPUTS) do
  local st0, id, h = readState(n)
  if not id then
    log("ERROR", string.format("Output%d: missing signal constant (mc.OSIG_OUTPUT%d)" , n, n))
  elseif not h or h == 0 then
    log("ERROR", string.format("Output%d: handle invalid (id=%s) -> check Control/IO mapping & plugin", n, tostring(id)))
  else
    log("INFO", string.format("Output%d: id=%s handle=%s initial=%s", n, tostring(id), tostring(h), tostring(st0)))
    -- Try force 0
    local ok0, _, _, imm0, aft0 = writeState(n, 0)
    log("INFO", string.format("Output%d: write 0 -> imm=%s delayed=%s (enabled=%d)", n, tostring(imm0), tostring(aft0), enabled()))
    -- Try force 1
    local ok1, _, _, imm1, aft1 = writeState(n, 1)
    log("INFO", string.format("Output%d: write 1 -> imm=%s delayed=%s (enabled=%d)", n, tostring(imm1), tostring(aft1), enabled()))
    -- Try force 0 again
    local ok2, _, _, imm2, aft2 = writeState(n, 0)
    log("INFO", string.format("Output%d: write 0 -> imm=%s delayed=%s (enabled=%d)", n, tostring(imm2), tostring(aft2), enabled()))

    if aft0 == 1 and aft1 == 1 and aft2 == 1 then
      log("WARNING", string.format("Output%d: stuck HIGH (override suspected)", n))
    elseif aft0 == 0 and aft1 == 0 and aft2 == 0 then
      log("WARNING", string.format("Output%d: stuck LOW (writes ignored)", n))
    end
  end
end

log("INFO", "=== Outputs Debug: end ===")
