local inst = mc.mcGetInstance()
local rc = 0

-- Get machine enabled state properly
local machEnabledHandle = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
local machEnabled = 0
if machEnabledHandle and machEnabledHandle > 0 then
    machEnabled = mc.mcSignalGetState(machEnabledHandle)
end

-- Get machine state
local machState, rc = mc.mcCntlGetState(inst)
local inCycle = mc.mcCntlIsInCycle(inst)

-- Initialize tracking variables for end of script
local machStateOld = machState
local machWasEnabled = machEnabled

-- Get current tool
local currentTool = mc.mcToolGetCurrent(inst)

-- Increment test counter
testcount = testcount + 1

-------------------------------------------------------
--  Set plate align (G68) Led
-------------------------------------------------------
local curLedState = math.tointeger(scr.GetProperty("ledPlateAlign", "Value"))
local curAlignState = math.tointeger((mc.mcCntlGetPoundVar(inst, 4016) - 69))
curAlignState = math.abs(curAlignState)
if (curLedState ~= curAlignState) then
	scr.SetProperty("ledPlateAlign", "Value", tostring(curAlignState))
end

-------------------------------------------------------
--  Coroutine resume
-------------------------------------------------------
if (wait ~= nil) and (machState == 0) then
    local state = coroutine.status(wait)
    if state == "suspended" then
        coroutine.resume(wait)
    end
end

-------------------------------------------------------
--  Cycle time label update
-------------------------------------------------------
if (machEnabled == 1) then
	local cycletime = mc.mcCntlGetRunTime(inst)
	scr.SetProperty("CycleTime", "Label", SecondsToTime(cycletime))
end

-------------------------------------------------------
--  Set Height Offset Led and Monitor H Sync
-------------------------------------------------------
local HOState = mc.mcCntlGetPoundVar(inst, 4008)
local activeH = mc.mcCntlGetPoundVar(inst, 4120)

-- Update LED
if (HOState == 49) then
    scr.SetProperty("ledHOffset", "Value", "0")
else
    scr.SetProperty("ledHOffset", "Value", "1")
end

-------------------------------------------------------
--  Set Spindle Ratio DRO
-------------------------------------------------------
local spinmotormax, rangemax, ratio
spinmotormax, rc = scr.GetProperty('droSpinMotorMax', 'Value')
spinmotormax = tonumber(spinmotormax) or 1   
rangemax, rc = scr.GetProperty('droRangeMax', 'Value')
rangemax = tonumber(rangemax) or 1
ratio = (rangemax / spinmotormax)    
scr.SetProperty('droRatio', 'Value', tostring(ratio))

-------------------------------------------------------
--  Set Feedback Ratio DRO Updated 5-30-16
-------------------------------------------------------
local range, rc = mc.mcSpindleGetCurrentRange(inst)
local fbratio, rc = mc.mcSpindleGetFeedbackRatio(inst, range)
scr.SetProperty('droFeedbackRatio', 'Value', tostring(fbratio))

-------------------------------------------------------
--  PLC First Run
-------------------------------------------------------
if (testcount == 1) then
    local iReg = mc.mcIoGetHandle (inst, "Keyboard/Enable")
    mc.mcIoSetState(iReg, 1)
    KeyboardInputsToggle()
    DecToFrac(0)
    DecToFrac(1)
    DecToFrac(2)
	
    DROTable = {
	[1034] = "droEdgeFinder",
    [1035] = "droGageBlock",
    [1036] = "droGageBlockT"
    }

    for name,number in pairs (DROTable) do
        local droName = (DROTable[name])
        local val = mc.mcProfileGetString(inst, "PersistentDROs", (droName), "NotFound")
        if(val ~= "NotFound")then
            scr.SetProperty((droName), "Value", val)
        end
    end
end

-- Initialize persistent globals on first run
if not _G.toolPLCInit then
    _G.toolPLCInit = true
    _G.lastTool = -999
	_G.lastSyncedTool = -999
    _G.lastPollTime = os.clock()
    _G.debounceStart = nil
    _G.debouncing = false
    _G.enablePromptDone = false
    _G.toolPresentHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    
    if not _G.toolPresentHandle or _G.toolPresentHandle <= 0 then
        mc.mcCntlSetLastError(inst, "ERROR: Invalid handle for Input #17 (Tool Present)")
        _G.toolPresentHandle = nil
    end
    
    mc.mcToolSetCurrent(inst, 0)
end

-- Function to prompt tool selection
local function promptToolSelection(isStartup)
    local virtualToolActive = mc.mcCntlGetPoundVar(inst, 406) >= 90
    local suppressPrompt = mc.mcCntlGetPoundVar(inst, 498) == 1

    if virtualToolActive or suppressPrompt then
        return
    end
    
    local filteredChoices = {}
    local filteredNumbers = {}
    
    if _G.toolChoices and _G.toolNumbers then
        for i, toolNum in ipairs(_G.toolNumbers) do
            if toolNum > 0 and toolNum < 90 then
                table.insert(filteredChoices, _G.toolChoices[i])
                table.insert(filteredNumbers, toolNum)
            end
        end
    end
    
    if #filteredChoices == 0 then
        mc.mcCntlSetLastError(inst, "ERROR: No physical tools configured")
        mc.mcToolSetCurrent(inst, 1)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        wx.wxMilliSleep(100)
        mc.mcCntlGcodeExecuteWait(inst, "G43 H1")
        return
    end
    
    local message = isStartup and 
        "Tool detected in spindle at startup.\nSelect the actual tool:" or
        "Tool inserted manually.\nSelect the tool number:"
    
    local dlg = wx.wxSingleChoiceDialog(wx.NULL, 
        message, 
        isStartup and "Tool Mismatch Detected" or "Tool Confirmation", 
        filteredChoices)
    
    local timerPanel = wx.wxPanel(dlg, wx.wxID_ANY)
    local timer = wx.wxTimer(timerPanel)
    local spindleCancelled = false
    
    local input8Handle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT8)
    local out2Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
    
    local lastInput8 = 0
    if input8Handle and input8Handle > 0 then
        lastInput8 = mc.mcSignalGetState(input8Handle)
    end
    
    local buttonPressStart = 0
    local buttonHoldRequired = 0.5
    local buttonHeld = false
    
    timerPanel:Connect(wx.wxEVT_TIMER, function(event)
        if not input8Handle or input8Handle <= 0 then
            return
        end
        
        local currentInput8 = mc.mcSignalGetState(input8Handle)
        
        if out2Handle and out2Handle > 0 then
            mc.mcSignalSetState(out2Handle, currentInput8)
        end
        
        if currentInput8 == 1 and lastInput8 == 0 then
            buttonPressStart = os.clock()
            buttonHeld = false
        elseif currentInput8 == 1 and lastInput8 == 1 then
            if not buttonHeld and (os.clock() - buttonPressStart) >= buttonHoldRequired then
                buttonHeld = true
                spindleCancelled = true
                
                dlg:EndModal(wx.wxID_CANCEL)
                timer:Stop()
            end
        elseif currentInput8 == 0 and lastInput8 == 1 then
            buttonPressStart = 0
            buttonHeld = false
        end
        
        lastInput8 = currentInput8
    end)
    
    timer:Start(50)
    
    local result = dlg:ShowModal()
    
    timer:Stop()
    
    if spindleCancelled then
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        
        if UpdateToolPreview then
            UpdateToolPreview()
        end
        
        mc.mcCntlSetLastError(inst, "Tool removed - T0 set")
        
    elseif result == wx.wxID_OK then
        local selection = dlg:GetSelection()
        local newTool = filteredNumbers[selection + 1]
        
        _G.lastTool = -999
        
        mc.mcToolSetCurrent(inst, newTool)
        wx.wxMilliSleep(50)
        
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        wx.wxMilliSleep(100)
        
        if newTool > 0 then
            mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", newTool))
            wx.wxMilliSleep(100)
            
            _G.hOffsetLastSync = os.clock()
            
            local activeH = mc.mcCntlGetPoundVar(inst, 4120)
            local desc = mc.mcToolGetDesc(inst, newTool) or "Unnamed"
        else
            _G.hOffsetLastSync = os.clock()
        end
        
        if UpdateToolPreview then
            UpdateToolPreview()
        end
    else
        if isStartup then
            mc.mcToolSetCurrent(inst, 1)
            
            mc.mcCntlGcodeExecuteWait(inst, "G49")
            wx.wxMilliSleep(100)
            mc.mcCntlGcodeExecuteWait(inst, "G43 H1")
            
            _G.hOffsetLastSync = os.clock()
            
            wx.wxMessageBox("Tool selection cancelled.\n\nTool has been set to T1 by default.\nPlease verify the correct tool number.", 
                           "Tool Set to T1", wx.wxOK + wx.wxICON_WARNING)
        else
            wx.wxMessageBox("Tool change cancelled. Tool not updated.", "Info", wx.wxOK + wx.wxICON_INFORMATION)
        end
        
        if UpdateToolPreview then
            UpdateToolPreview()
        end
    end
    
    dlg:Destroy()
end

-- Check for enable condition
if machEnabled == 1 and not _G.enablePromptDone and _G.toolPresentHandle then
    local toolPresent = mc.mcSignalGetState(_G.toolPresentHandle)
    
    local m6Running = mc.mcCntlGetPoundVar(inst, 499) == 1
    local suppressPrompt = mc.mcCntlGetPoundVar(inst, 498) == 1
    
    if toolPresent == 1 and currentTool == 0 and not suppressPrompt and currentTool < 90 then
        promptToolSelection(true)
    end
    _G.enablePromptDone = true
elseif machEnabled == 0 then
    _G.enablePromptDone = false
end

-- Monitor current tool and sync dropdown
currentTool = mc.mcToolGetCurrent(inst)
if currentTool ~= _G.lastTool then
    local toolChangeTime = os.clock()
    _G.lastTool = currentTool
	
    local machState = mc.mcCntlGetState(inst)
    local m6Running = mc.mcCntlGetPoundVar(inst, 499) == 1
    
    local timeSinceLastSync = toolChangeTime - (_G.hOffsetLastSync or 0)
    
    if machState == 0 and timeSinceLastSync > 1.0 then
        local currentH = mc.mcCntlGetPoundVar(inst, 4120)
        local compMode = mc.mcCntlGetPoundVar(inst, 4008)
        
        local needsSync = false
        if currentTool == 0 and compMode == 43 then
            needsSync = true
        elseif currentTool > 0 and (compMode == 49 or currentH ~= currentTool) then
            needsSync = true
        end
        
        if needsSync then
            mc.mcCntlGcodeExecuteWait(inst, "G49")
            if currentTool > 0 then
                mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", currentTool))
            end
            _G.hOffsetLastSync = os.clock()
        end
    end
    
    if not _G.selectedToolIndex then
        local index = -1
        if _G.toolNumbers then
            for i, t in ipairs(_G.toolNumbers) do
                if t == currentTool then
                    index = i - 1
                    break
                end
            end
        end
        
        if index >= 0 then
            scr.SetProperty("lstCurrentTool", "Value", tostring(index))
        else
            scr.SetProperty("lstCurrentTool", "Value", "0")
        end
        
        if UpdateToolPreview then
            UpdateToolPreview()
        end
    end
end

-- DUST/VACUUM/BOOT AUTOMATION

-- Initialize on first run
if not _G.dustAutoInit then
    _G.dustAutoInit = true
    _G.lastMachineState = mc.mcCntlGetState(inst)
    _G.waitingForMotionAfterToolChange = false
    _G.motionHasStarted = false
    
    if mc.mcCntlGetPoundVar(inst, 400) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 400, 0)
    end
    if mc.mcCntlGetPoundVar(inst, 401) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 401, 0)
    end
    if mc.mcCntlGetPoundVar(inst, 402) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 402, 0)
    end
    if mc.mcCntlGetPoundVar(inst, 481) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 481, 0)
    end
    if mc.mcCntlGetPoundVar(inst, 499) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 499, 0)
    end
    if mc.mcCntlGetPoundVar(inst, 496) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 496, 0)
    end
end

local currentState = mc.mcCntlGetState(inst)
local inCycle = mc.mcCntlIsInCycle(inst)

local STATE_IDLE = 0
local STATE_FRUN = 100

local m6Flag = mc.mcCntlGetPoundVar(inst, 499)
local probeFlag = mc.mcCntlGetPoundVar(inst, 496)
local m6Completed = mc.mcCntlGetPoundVar(inst, 481)

-- CHECK FOR M6 COMPLETION
if m6Completed == 1 then
    mc.mcCntlSetPoundVar(inst, 481, 0)
    
    local currentTool = mc.mcToolGetCurrent(inst)
    
    if mc.mcCntlGetPoundVar(inst, 402) == 1 then
        if currentTool > 0 and currentTool < 90 then
            _G.waitingForMotionAfterToolChange = true
            _G.motionHasStarted = false
            mc.mcCntlSetLastError(inst, string.format("T%d ready - boot will lower on first cut", currentTool))
            
        elseif currentTool >= 90 and currentTool <= 99 then
            local hBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
            if hBoot and hBoot > 0 then
                mc.mcSignalSetState(hBoot, 0)
            end
            _G.waitingForMotionAfterToolChange = false
            _G.motionHasStarted = false
            mc.mcCntlSetLastError(inst, string.format("Virtual T%d active - boot raised", currentTool))
            
        elseif currentTool == 0 then
            _G.waitingForMotionAfterToolChange = false
            _G.motionHasStarted = false
        end
    end
end





-- ============================================
-- POUND VARIABLE #481 DIAGNOSTIC TEST
-- Place this in your PLC script temporarily
-- ============================================

-- Add this section RIGHT AFTER the M6 completion check section
-- (around line 260-280 in your PLC)

-- Diagnostic tracking variables
if not _G.poundVarDiag then
    _G.poundVarDiag = {
        testCounter = 0,
        lastValue481 = -999,
        clearAttempts = 0,
        firstDetection = 0,
        stateWhenDetected = 0,
        cycleWhenDetected = 0,
        lastClearAttempt = 0,
        m6RunningWhenSet = 0,
        valueHistory = {},
        maxHistory = 20
    }
end

-- Every PLC cycle, check #481
local current481 = mc.mcCntlGetPoundVar(inst, 481)
local currentTime = os.clock()

-- Track value changes
if current481 ~= _G.poundVarDiag.lastValue481 then
    -- Value changed!
    local changeInfo = string.format("t=%.3f: #481 changed %d -> %d (state=%d, cycle=%s, M6flag=#499=%d)", 
        currentTime,
        _G.poundVarDiag.lastValue481,
        current481,
        mc.mcCntlGetState(inst),
        tostring(mc.mcCntlIsInCycle(inst)),
        mc.mcCntlGetPoundVar(inst, 499))
    
    mc.mcCntlSetLastError(inst, "DIAG: " .. changeInfo)
    
    -- Store in history
    table.insert(_G.poundVarDiag.valueHistory, changeInfo)
    if #_G.poundVarDiag.valueHistory > _G.poundVarDiag.maxHistory then
        table.remove(_G.poundVarDiag.valueHistory, 1)
    end
    
    -- If it just became 1, record context
    if current481 == 1 and _G.poundVarDiag.lastValue481 ~= 1 then
        _G.poundVarDiag.firstDetection = currentTime
        _G.poundVarDiag.stateWhenDetected = mc.mcCntlGetState(inst)
        _G.poundVarDiag.cycleWhenDetected = mc.mcCntlIsInCycle(inst)
        _G.poundVarDiag.m6RunningWhenSet = mc.mcCntlGetPoundVar(inst, 499)
        _G.poundVarDiag.clearAttempts = 0
    end
    
    _G.poundVarDiag.lastValue481 = current481
end

-- Special test when #481 = 1
if current481 == 1 then
    _G.poundVarDiag.testCounter = _G.poundVarDiag.testCounter + 1
    
    -- Every 10 cycles (200ms), try different clearing methods
    if _G.poundVarDiag.testCounter % 10 == 0 then
        local testNum = math.floor(_G.poundVarDiag.testCounter / 10)
        
        mc.mcCntlSetLastError(inst, string.format("DIAG: Test %d - #481 stuck at 1 for %.2fs", 
            testNum, currentTime - _G.poundVarDiag.firstDetection))
        
        -- Try different clearing methods
        if testNum == 1 then
            -- Method 1: Direct set
            mc.mcCntlSetLastError(inst, "DIAG: Method 1 - Direct set to 0")
            mc.mcCntlSetPoundVar(inst, 481, 0)
            
        elseif testNum == 2 then
            -- Method 2: Set to different value first
            mc.mcCntlSetLastError(inst, "DIAG: Method 2 - Set to 99 then 0")
            mc.mcCntlSetPoundVar(inst, 481, 99)
            wx.wxMilliSleep(1)
            mc.mcCntlSetPoundVar(inst, 481, 0)
            
        elseif testNum == 3 then
            -- Method 3: Check if M6 is still running
            local m6Running = mc.mcCntlGetPoundVar(inst, 499)
            mc.mcCntlSetLastError(inst, string.format("DIAG: Method 3 - M6 running = %d", m6Running))
            if m6Running == 1 then
                mc.mcCntlSetLastError(inst, "DIAG: M6 still running - forcing #499 = 0")
                mc.mcCntlSetPoundVar(inst, 499, 0)
            end
            mc.mcCntlSetPoundVar(inst, 481, 0)
            
        elseif testNum == 4 then
            -- Method 4: Use GCode to set it
            mc.mcCntlSetLastError(inst, "DIAG: Method 4 - Using GCode #481=0")
            mc.mcCntlMdiExecute(inst, "#481=0")
            
        elseif testNum == 5 then
            -- Method 5: Check who's setting it
            mc.mcCntlSetLastError(inst, "DIAG: Method 5 - Checking other pound vars")
            local vars = {
                ["#499 (M6 running)"] = 499,
                ["#495 (Spindle dwell)"] = 495,
                ["#496 (Dwell time)"] = 496,
                ["#498 (Dialog supp)"] = 498
            }
            for name, var in pairs(vars) do
                local val = mc.mcCntlGetPoundVar(inst, var)
                mc.mcCntlSetLastError(inst, string.format("  %s = %d", name, val))
            end
            
        elseif testNum == 6 then
            -- Method 6: Check if it's being set by screen script
            mc.mcCntlSetLastError(inst, "DIAG: Checking if external script is setting #481")
            -- Set a marker to detect external changes
            mc.mcCntlSetPoundVar(inst, 481, -1)  -- Unusual value
            
        elseif testNum == 7 then
            -- Check if -1 stuck or changed back to 1
            if current481 == -1 then
                mc.mcCntlSetLastError(inst, "DIAG: #481 accepted -1, now setting to 0")
                mc.mcCntlSetPoundVar(inst, 481, 0)
            else
                mc.mcCntlSetLastError(inst, "DIAG: #481 changed from -1 back to 1 - EXTERNAL SOURCE!")
            end
            
        elseif testNum >= 8 then
            -- Give up and show history
            mc.mcCntlSetLastError(inst, "DIAG: === POUND VAR #481 HISTORY ===")
            for i, entry in ipairs(_G.poundVarDiag.valueHistory) do
                mc.mcCntlSetLastError(inst, "  " .. entry)
            end
            _G.poundVarDiag.testCounter = 0  -- Reset for next time
        end
        
        _G.poundVarDiag.lastClearAttempt = currentTime
    end
else
    -- #481 is 0, reset counter
    if _G.poundVarDiag.testCounter > 0 then
        mc.mcCntlSetLastError(inst, string.format("DIAG: SUCCESS - #481 cleared after %d tests", 
            math.floor(_G.poundVarDiag.testCounter / 10)))
        _G.poundVarDiag.testCounter = 0
    end
end

-- Also monitor #499 (M6 running flag)
local current499 = mc.mcCntlGetPoundVar(inst, 499)
if not _G.poundVarDiag.lastValue499 then
    _G.poundVarDiag.lastValue499 = current499
elseif current499 ~= _G.poundVarDiag.lastValue499 then
    mc.mcCntlSetLastError(inst, string.format("DIAG: #499 (M6 flag) changed %d -> %d", 
        _G.poundVarDiag.lastValue499, current499))
    _G.poundVarDiag.lastValue499 = current499
end

-- ============================================
-- END DIAGNOSTIC SECTION
-- ============================================





-- Only process on state changes
if currentState ~= _G.lastMachineState then
    
    -- PROGRAM START: Idle -> Feed Run
    if _G.lastMachineState == STATE_IDLE and currentState == STATE_FRUN then
        
        if mc.mcCntlGetPoundVar(inst, 400) == 1 then
            local hDust = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT4)
            if hDust and hDust > 0 then
                mc.mcSignalSetState(hDust, 1)
                mc.mcCntlSetLastError(inst, "AUTO: Dust collection ON")
            end
        end
        
        if not _G.waitingForMotionAfterToolChange then
            local currentTool = mc.mcToolGetCurrent(inst)
            if currentTool > 0 and currentTool < 90 and mc.mcCntlGetPoundVar(inst, 402) == 1 then
                _G.waitingForMotionAfterToolChange = true
                _G.motionHasStarted = false
                mc.mcCntlSetLastError(inst, string.format("T%d active - boot will lower on first cut", currentTool))
            end
        end
        
    -- PROGRAM END: Feed Run -> Idle
    elseif _G.lastMachineState == STATE_FRUN and currentState == STATE_IDLE then
        
        if probeFlag == 1 then
            -- M6/Probe is running, skip auto stop
        else
            local hDust = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT4)
            if hDust and hDust > 0 then
                mc.mcSignalSetState(hDust, 0)
            end
            
            local hBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
            if hBoot and hBoot > 0 then
                mc.mcSignalSetState(hBoot, 0)
            end
            
            if mc.mcCntlGetPoundVar(inst, 401) == 1 then
                local hVac1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT5)
                local hVac2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
                
                if hVac1 and hVac1 > 0 then
                    mc.mcSignalSetState(hVac1, 0)
                end
                if hVac2 and hVac2 > 0 then
                    mc.mcSignalSetState(hVac2, 0)
                end
                mc.mcCntlSetLastError(inst, "AUTO STOP: Dust OFF, Boot UP, Vacuums per setting")
            else
                mc.mcCntlSetLastError(inst, "AUTO STOP: Dust OFF, Boot UP")
            end
            
            _G.waitingForMotionAfterToolChange = false
            _G.motionHasStarted = false
        end
    end
    
    _G.lastMachineState = currentState
end

-- HANDLE BOOT LOWERING ON MOTION
local skipForSpindleDwell = false
if _G.spinUpDwell ~= nil and type(_G.spinUpDwell) == "table" then
    -- Check if spindle delay is still active (new simpler logic)
    if _G.spinUpDwell.armed == true or 
       (_G.spinUpDwell.spindleStartTime > 0 and not _G.spinUpDwell.delayComplete) then
        skipForSpindleDwell = true
    end
end

if not skipForSpindleDwell and inCycle == 1 and mc.mcCntlGetPoundVar(inst, 402) == 1 and not (mc.mcCntlGetPoundVar(inst, 499) == 1) then
    
    local currentTool = mc.mcToolGetCurrent(inst)
    local hBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
    
    if hBoot and hBoot > 0 then
        local bootIsDown = mc.mcSignalGetState(hBoot)
        
        if _G.waitingForMotionAfterToolChange then
            local motionMode = mc.mcCntlGetPoundVar(inst, 4000)
            
            if motionMode >= 1 and motionMode <= 3 then
                local xVel = mc.mcAxisGetVel(inst, 0)
                local yVel = mc.mcAxisGetVel(inst, 1)
                local threshold = 1.0
                
                if math.abs(xVel) > threshold or math.abs(yVel) > threshold then
                    _G.motionHasStarted = true
                end
            end
            
            if _G.motionHasStarted and bootIsDown == 0 then
                if currentTool > 0 and currentTool < 90 then
                    mc.mcSignalSetState(hBoot, 1)
                    mc.mcCntlSetLastError(inst, string.format("Dust boot lowered for T%d", currentTool))
                    _G.waitingForMotionAfterToolChange = false
                    _G.motionHasStarted = false
                end
            end
        end
        
        if currentTool >= 90 and currentTool <= 99 and bootIsDown == 1 then
            mc.mcSignalSetState(hBoot, 0)
            mc.mcCntlSetLastError(inst, "Safety: Boot raised for virtual tool")
        end
    end
end

-- ===== HOMING INDICATOR AND WARNING RESET =====
do
    local inst = mc.mcGetInstance()
    
    if _G.lastHomingFlashState == nil then
        _G.lastHomingFlashState = nil
        _G.lastHomedState = nil
        _G.AXES_HOMED = false
    end
    
    local allHomed = true
    local unhomedAxes = {}
    
    for axis = 0, 5 do
        local enabledOk, enabled = pcall(mc.mcAxisIsEnabled, inst, axis)
        local homedOk, homed = pcall(mc.mcAxisIsHomed, inst, axis)
        
        if enabledOk and homedOk then
            if enabled == 1 and homed ~= 1 then
                allHomed = false
                table.insert(unhomedAxes, axis)
            end
        end
    end
    
    local flashOn = (math.floor(testcount / 6) % 2) == 0
    
    if not allHomed then
        if _G.lastHomingFlashState ~= flashOn or _G.lastHomedState ~= allHomed then
            local color = flashOn and "#FFFF00" or "#4B4B4B"
            
            pcall(scr.SetProperty, "btnRefAllAxes", "Bg Color", color)
            pcall(scr.SetProperty, "btnRefAllAxes", "Fg Color", "#000000")
            pcall(scr.SetProperty, "btnRefAllAxes", "Label", "HOME\nREQUIRED")
            
            _G.lastHomingFlashState = flashOn
        end
    else
        if _G.lastHomedState == false or _G.lastHomedState == nil then
            pcall(scr.SetProperty, "btnRefAllAxes", "Bg Color", "#4B4B4B")
            pcall(scr.SetProperty, "btnRefAllAxes", "Fg Color", "#FFFFFF")
            pcall(scr.SetProperty, "btnRefAllAxes", "Label", "Ref All\nAxis")
        end
        
        if _G.HOMING_WARNING_IGNORED then
            _G.HOMING_WARNING_IGNORED = false
        end
    end
    
    _G.lastHomedState = allHomed
    _G.AXES_HOMED = allHomed
end

-- Work Offset Monitoring Section
if not _G.lastWorkOffset then
    _G.lastWorkOffset = -1
end

if not _G.tabMonitor then
    _G.tabMonitor = {
        lastTab = -1,
        checkCounter = 0,
        checkInterval = 5,
        needsRefresh = false
    }
end

local currentOffset = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14 or 5220)

if currentOffset ~= _G.lastWorkOffset then
    if UpdateWorkOffsetButtons then
        UpdateWorkOffsetButtons()
    end
    
    if _G.lastWorkOffset ~= -1 then
        if currentOffset >= 54 and currentOffset <= 59 then
            mc.mcCntlSetLastError(inst, string.format("Work Offset: G%.0f", currentOffset))
        elseif math.abs(currentOffset - 54.1) < 0.01 then
            local pNumber = mc.mcCntlGetPoundVar(inst, mc.SV_BUFP or 5219)
            mc.mcCntlSetLastError(inst, string.format("WARNING: G54.1 P%d active - not shown in UI", pNumber))
        else
            mc.mcCntlSetLastError(inst, string.format("WARNING: Unknown work offset %.1f", currentOffset))
        end
    end
    
    _G.lastWorkOffset = currentOffset
end

_G.tabMonitor.checkCounter = _G.tabMonitor.checkCounter + 1
if _G.tabMonitor.checkCounter >= _G.tabMonitor.checkInterval then
    _G.tabMonitor.checkCounter = 0
    
    local ok, tabStr = pcall(scr.GetProperty, "MainTabs", "Current Tab")
    if ok and tabStr then
        local currentTab = tonumber(tabStr) or -1
        
        if currentTab ~= _G.tabMonitor.lastTab and currentTab >= 0 then
            _G.tabMonitor.needsRefresh = true
            _G.tabMonitor.lastTab = currentTab
        end
    end
end

if _G.tabMonitor.needsRefresh then
    _G.tabMonitor.needsRefresh = false
    
    if UpdateWorkOffsetButtons then
        UpdateWorkOffsetButtons()
    end
    
    if SyncSoftLimitsButton then
        SyncSoftLimitsButton()
    end
    
    if SyncDustButtons then
        SyncDustButtons()
    end
end

-- SOFT LIMITS STATE MONITORING
if not _G.softLimitsInit then
    _G.softLimitsInit = true
    _G.lastSoftLimitsState = nil
end

local function getActualSoftLimitsEnabled()
    for axis = 0, 5 do
        if mc.mcAxisIsEnabled(inst, axis) == 1 then
            local state = mc.mcSoftLimitGetState(inst, axis)
            if state and state == 1 then
                return 1
            end
        end
    end
    return 0
end

local softLimitsEnabled = getActualSoftLimitsEnabled()

if softLimitsEnabled ~= _G.lastSoftLimitsState then
    if softLimitsEnabled == 1 then
        scr.SetProperty("btnSoftLimits", "Bg Color", "#00FF00")
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nENABLED")
        
        if _G.lastSoftLimitsState ~= nil then
            mc.mcCntlSetLastError(inst, "Soft limits ENABLED")
        end
    else
        scr.SetProperty("btnSoftLimits", "Bg Color", "#FF0000")
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nDISABLED")
        
        if _G.lastSoftLimitsState ~= nil then
            mc.mcCntlSetLastError(inst, "WARNING: Soft limits DISABLED")
        end
    end
    
    _G.lastSoftLimitsState = softLimitsEnabled
end

-- TOUCH PROBE BUTTON STATE MONITORING
if not _G.lastProbeOutputState then 
    _G.lastProbeOutputState = -1 
end

local output7Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
if output7Handle and output7Handle > 0 then
    local probeActive = mc.mcSignalGetState(output7Handle)
    
    if probeActive ~= _G.lastProbeOutputState then
        if probeActive == 1 then
            scr.SetProperty("btnTouchProbe", "Bg Color", "#00FF00")
            scr.SetProperty("btnTouchProbe", "Label", "Deactivate Probe\nChange to T0")
        else
            scr.SetProperty("btnTouchProbe", "Bg Color", "#FF0000")
            scr.SetProperty("btnTouchProbe", "Label", "Activate Probe\nChange to T90")
        end
        _G.lastProbeOutputState = probeActive
    end
end

-- LASER BUTTON STATE MONITORING
if not _G.lastLaserOutputState then 
    _G.lastLaserOutputState = -1 
end

local output1Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
if output1Handle and output1Handle > 0 then
    local laserActive = mc.mcSignalGetState(output1Handle)
    
    if laserActive ~= _G.lastLaserOutputState then
        if laserActive == 1 then
            scr.SetProperty("btnLaserDown", "Bg Color", "#00FF00")
            scr.SetProperty("btnLaserDown", "Label", "Deactivate Laser\nChange to T0")
        else
            scr.SetProperty("btnLaserDown", "Bg Color", "#FF0000")
            scr.SetProperty("btnLaserDown", "Label", "Activate Laser\nChange to T91")
        end
        _G.lastLaserOutputState = laserActive
    end
end

-- Input 8 to Output 2 Mirroring and Tool Detection
if not _G.lastInput8State then 
    _G.lastInput8State = -1 
    _G.toolCheckPending = false
    _G.toolCheckTime = 0
    _G.toolCheckStartTime = nil
    _G.lastToolSensorState = -1
end

local input8Handle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT8)
if input8Handle and input8Handle > 0 then
    local input8State = mc.mcSignalGetState(input8Handle)
    
    if input8State ~= _G.lastInput8State then
        local out2Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        if out2Handle and out2Handle > 0 then
            mc.mcSignalSetState(out2Handle, input8State)
        end
        
        if input8State == 0 and _G.lastInput8State == 1 then
            _G.toolCheckPending = true
            _G.toolCheckTime = os.clock() + 1.0
        end
        
        _G.lastInput8State = input8State
    end
end

-- Handle pending tool check after delay
if _G.toolCheckPending and os.clock() >= _G.toolCheckTime then
    
    if not _G.toolCheckStartTime then
        _G.toolCheckStartTime = os.clock()
    end
    
    if os.clock() - _G.toolCheckStartTime > 30 then
        mc.mcCntlSetLastError(inst, "Tool check cancelled - machine stayed busy for 30 seconds")
        _G.toolCheckPending = false
        _G.toolCheckStartTime = nil
        _G.lastToolSensorState = mc.mcSignalGetState(mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17))
        return
    end
    
    local machState = mc.mcCntlGetState(inst)
    local inCycle = mc.mcCntlIsInCycle(inst)
    
    local inMacro = (machState == mc.MC_STATE_MRUN_MACRO) or 
                    (machState == mc.MC_STATE_MRUN_MACRO_HOLD) or
                    (machState == mc.MC_STATE_MRUN_MACROH)
    
    if machState ~= 0 or inCycle == 1 then
        _G.toolCheckPending = true
        _G.toolCheckTime = os.clock() + 1.0
        return
    end
    
    _G.toolCheckPending = false
    _G.toolCheckStartTime = nil
    
    local toolPresentHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    if not toolPresentHandle or toolPresentHandle <= 0 then
        return
    end
    
    local toolPresent = mc.mcSignalGetState(toolPresentHandle)
    local currentTool = mc.mcToolGetCurrent(inst)
    
    if toolPresent == 1 and (_G.lastToolSensorState == 0 or _G.lastToolSensorState == -1) then
        
        local virtualToolActive = mc.mcCntlGetPoundVar(inst, 406) >= 90
        
        if virtualToolActive then
            if RetractVirtualTool then
                RetractVirtualTool()
                mc.mcCntlSetLastError(inst, "Virtual tool retracted for manual change")
            else
                mc.mcCntlSetLastError(inst, "ERROR: RetractVirtualTool function not found!")
            end
            currentTool = mc.mcToolGetCurrent(inst)
        end
        
        promptToolSelection(false)
    end
    
    _G.lastToolSensorState = toolPresent
end

-- LOW AIR PRESSURE MONITORING
if not _G.lowAirInit then
    _G.lowAirInit = true
    _G.lastLowAirState = -1
    _G.lowAirDisabled = false
    _G.lowAirDialogShown = false
    _G.lowAirDebounceCount = 0
    _G.restoredDialogShown = false
end

local lowAirHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT6)

if lowAirHandle and lowAirHandle > 0 then
    local rawAirState = mc.mcSignalGetState(lowAirHandle)
    
    if rawAirState ~= _G.lastLowAirState then
        _G.lowAirDebounceCount = _G.lowAirDebounceCount + 1
        
        if _G.lowAirDebounceCount < 3 then
            return
        end
        
        _G.lowAirDebounceCount = 0
        
        if rawAirState == 1 then
            if not _G.lowAirDisabled then
                local machState = mc.mcCntlGetState(inst)
                local inCycle = mc.mcCntlIsInCycle(inst)
                
                if inCycle == 1 then
                    mc.mcCntlFeedHold(inst)
                    
                    local waitCount = 0
                    while mc.mcCntlIsInCycle(inst) == 1 and waitCount < 5 do
                        waitCount = waitCount + 1
                    end
                    
                    mc.mcCntlCycleStop(inst)
                end
                
                local spindleOn = mc.mcSpindleGetCommandRPM(inst) > 0
                if spindleOn then
                    mc.mcSpindleSetDirection(inst, 0)
                end
                
                mc.mcCntlEnable(inst, 0)
                _G.lowAirDisabled = true
                _G.restoredDialogShown = false
                
                mc.mcCntlSetLastError(inst, "*** MACHINE DISABLED: LOW AIR PRESSURE DETECTED ***")
                
                if not _G.lowAirDialogShown then
                    _G.lowAirDialogShown = true
                    
                    coroutine.create(function()
                        wx.wxMessageBox(
                            "LOW AIR PRESSURE DETECTED!\n\n" ..
                            "Machine has been disabled for safety.\n" ..
                            "1. Check air compressor\n" ..
                            "2. Check for air leaks\n" ..
                            "3. Restore air pressure above minimum\n" ..
                            "4. Re-enable machine when pressure is normal",
                            "CRITICAL: Low Air Pressure",
                            wx.wxOK + wx.wxICON_ERROR
                        )
                    end)
                end
            end
            
        else
            if _G.lowAirDisabled then
                mc.mcCntlSetLastError(inst, "Air pressure restored - machine can be re-enabled")
                _G.lowAirDisabled = false
                _G.lowAirDialogShown = false
                
                if not _G.restoredDialogShown then
                    _G.restoredDialogShown = true
                    
                    coroutine.create(function()
                        wx.wxMessageBox(
                            "Air pressure has been restored.\n\n" ..
                            "Please verify system is safe before re-enabling machine.",
                            "Air Pressure Restored",
                            wx.wxOK + wx.wxICON_INFORMATION
                        )
                    end)
                end
            end
        end
        
        _G.lastLowAirState = rawAirState
    else
        _G.lowAirDebounceCount = 0
    end
    
    if rawAirState == 1 then
        local machEnabledHandle = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
        if machEnabledHandle and machEnabledHandle > 0 then
            local currentlyEnabled = mc.mcSignalGetState(machEnabledHandle)
            
            if currentlyEnabled == 1 and _G.lowAirDisabled then
                mc.mcCntlEnable(inst, 0)
                mc.mcCntlSetLastError(inst, "*** CANNOT ENABLE: Air pressure still too low! ***")
                
                if testcount % 100 == 0 then
                    mc.mcCntlSetLastError(inst, "*** WARNING: Fix air pressure before enabling! ***")
                end
            end
        end
    end
    
    if testcount % 10 == 0 then
        if scr.GetProperty("btnAirPressure", "Bg Color") ~= nil then
            if rawAirState == 1 then
                scr.SetProperty("btnAirPressure", "Bg Color", "#FF0000")
                scr.SetProperty("btnAirPressure", "Label", "Air Pressure\nLOW!")
            else
                scr.SetProperty("btnAirPressure", "Bg Color", "#00FF00")
                scr.SetProperty("btnAirPressure", "Label", "Air Pressure\nNORMAL")
            end
        end
        
        if scr.GetProperty("ledAirPressure", "Value") ~= nil then
            scr.SetProperty("ledAirPressure", "Value", rawAirState == 1 and "0" or "1")
        end
    end
    
elseif _G.lastLowAirState ~= -2 then
    mc.mcCntlSetLastError(inst, "WARNING: Cannot monitor air pressure - Input 6 not configured")
    _G.lastLowAirState = -2
end

-- ================================
-- SIMPLIFIED: Spindle Spin-UP Delay (No Motion Pause)
-- ================================
local inst = mc.mcGetInstance()

-- Initialize spindle dwell system
if not _G.spinUpDwell then
    _G.spinUpDwell = {
        armed = false,
        delaySeconds = 0,
        spindleStartTime = 0,
        delayComplete = false,
        lastSpindleState = 0
    }
    mc.mcCntlSetLastError(inst, "SPINDLE DELAY: System initialized (non-pausing version)")
end

-- Check if M6 armed the delay
local spinUpFlag = mc.mcCntlGetPoundVar(inst, 495)
if spinUpFlag == 1 then
    _G.spinUpDwell.armed = true
    _G.spinUpDwell.delaySeconds = mc.mcCntlGetPoundVar(inst, 496) or 0.7
    _G.spinUpDwell.delayComplete = false
    _G.spinUpDwell.spindleStartTime = 0
    mc.mcCntlSetPoundVar(inst, 495, 0)
    
    mc.mcCntlSetLastError(inst, string.format("SPINDLE DELAY: Will wait %.1fs after spindle starts", _G.spinUpDwell.delaySeconds))
end

-- Simple spindle detection
local function getSpindleRunning()
    -- Check spindle ON signal (your P2-14 output)
    local hSpindleOn = mc.mcSignalGetHandle(inst, mc.OSIG_SPINDLEON)
    if hSpindleOn and hSpindleOn > 0 then
        return mc.mcSignalGetState(hSpindleOn) == 1
    end
    
    -- Fallback: Check commanded RPM
    local rpm = mc.mcSpindleGetCommandRPM(inst)
    return rpm and rpm > 0
end

-- Track spindle state for dust boot delay
if _G.spinUpDwell.armed then
    local spindleOn = getSpindleRunning() and 1 or 0
    
    -- Detect spindle start (rising edge)
    if _G.spinUpDwell.lastSpindleState == 0 and spindleOn == 1 then
        _G.spinUpDwell.spindleStartTime = os.clock()
        mc.mcCntlSetLastError(inst, string.format("SPINDLE DELAY: Spindle started, waiting %.1fs before allowing boot to lower", _G.spinUpDwell.delaySeconds))
    end
    
    -- Check if delay period has passed
    if _G.spinUpDwell.spindleStartTime > 0 and not _G.spinUpDwell.delayComplete then
        local elapsed = os.clock() - _G.spinUpDwell.spindleStartTime
        
        if elapsed >= _G.spinUpDwell.delaySeconds then
            _G.spinUpDwell.delayComplete = true
            _G.spinUpDwell.armed = false  -- Disarm after completion
            mc.mcCntlSetLastError(inst, "SPINDLE DELAY: Complete - dust boot can now lower on motion")
        end
    end
    
    _G.spinUpDwell.lastSpindleState = spindleOn
end

-- Reset on machine idle
local machState = mc.mcCntlGetState(inst)
if machState == mc.MC_STATE_IDLE then
    if _G.spinUpDwell.armed or _G.spinUpDwell.spindleStartTime > 0 then
        _G.spinUpDwell.armed = false
        _G.spinUpDwell.spindleStartTime = 0
        _G.spinUpDwell.delayComplete = false
    end
end

-------------------------------------------------------
-- This is the last thing we do. So keep it at the end of the script!
machStateOld = machState;
machWasEnabled = machEnabled;
