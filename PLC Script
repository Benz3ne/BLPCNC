local inst = mc.mcGetInstance()
local rc = 0




-- Get machine enabled state properly
local machEnabledHandle = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
local machEnabled = 0
if machEnabledHandle and machEnabledHandle > 0 then
    machEnabled = mc.mcSignalGetState(machEnabledHandle)
end

-- Get machine state
local machState, rc = mc.mcCntlGetState(inst)
local inCycle = mc.mcCntlIsInCycle(inst)

-- Initialize tracking variables for end of script
local machStateOld = machState  -- Will be used at script end
local machWasEnabled = machEnabled  -- Will be used at script end

-- Get current tool
local currentTool = mc.mcToolGetCurrent(inst)

-- Increment test counter
testcount = testcount + 1

-------------------------------------------------------
--  Set plate align (G68) Led
-------------------------------------------------------
local curLedState = math.tointeger(scr.GetProperty("ledPlateAlign", "Value"))
local curAlignState = math.tointeger((mc.mcCntlGetPoundVar(inst, 4016) - 69))
curAlignState = math.abs(curAlignState)
if (curLedState ~= curAlignState) then
	scr.SetProperty("ledPlateAlign", "Value", tostring(curAlignState))
end
-------------------------------------------------------
--  Coroutine resume
-------------------------------------------------------
if (wait ~= nil) and (machState == 0) then --wait exist and state == idle
	local state = coroutine.status(wait)
    if state == "suspended" then --wait is suspended
        coroutine.resume(wait)
    end
end
-------------------------------------------------------
--  Cycle time label update
-------------------------------------------------------
--Requires a static text box named "CycleTime" on the screen
if (machEnabled == 1) then
	local cycletime = mc.mcCntlGetRunTime(inst)  -- Remove the undefined 'time' parameter
	scr.SetProperty("CycleTime", "Label", SecondsToTime(cycletime))
end
-------------------------------------------------------
--  Set Height Offset Led and Monitor H Sync
-------------------------------------------------------
local HOState = mc.mcCntlGetPoundVar(inst, 4008)
local activeH = mc.mcCntlGetPoundVar(inst, 4120)
-- currentTool already declared above, don't redeclare

-- Update LED
if (HOState == 49) then
    scr.SetProperty("ledHOffset", "Value", "0")
else
    scr.SetProperty("ledHOffset", "Value", "1")
    
end
-------------------------------------------------------
--  Set Spindle Ratio DRO
-------------------------------------------------------
local spinmotormax, rangemax, ratio
spinmotormax, rc = scr.GetProperty('droSpinMotorMax', 'Value')
spinmotormax = tonumber(spinmotormax) or 1   
rangemax, rc = scr.GetProperty('droRangeMax', 'Value')
rangemax = tonumber(rangemax) or 1
ratio = (rangemax / spinmotormax)    
scr.SetProperty('droRatio', 'Value', tostring(ratio))

-------------------------------------------------------
--  Set Feedback Ratio DRO Updated 5-30-16
-------------------------------------------------------
local range, rc = mc.mcSpindleGetCurrentRange(inst)
local fbratio, rc = mc.mcSpindleGetFeedbackRatio(inst, range)
scr.SetProperty('droFeedbackRatio', 'Value', tostring(fbratio))

-------------------------------------------------------
--  PLC First Run
-------------------------------------------------------
if (testcount == 1) then --Set Keyboard input startup state
    local iReg = mc.mcIoGetHandle (inst, "Keyboard/Enable")
    mc.mcIoSetState(iReg, 1) --Set register to 1 to ensure KeyboardInputsToggle function will do a disable.
    KeyboardInputsToggle()
    DecToFrac(0)
    DecToFrac(1)
    DecToFrac(2)
	---------------------------------------------------------------
	-- Set Persistent DROs.
	---------------------------------------------------------------

    DROTable = {
	[1034] = "droEdgeFinder",
    [1035] = "droGageBlock",
    [1036] = "droGageBlockT"
    }
	
	-- ******************************************************************************************* --
	-- The following is a loop. As a rule of thumb loops should be avoided in the PLC Script.  --
	-- However, this loop only runs during the first run of the PLC script so it is acceptable.--
	-- ******************************************************************************************* --                                                     

    for name,number in pairs (DROTable) do -- for each paired name (key) and number (value) in the DRO table
        local droName = (DROTable[name]) -- make the variable named droName equal the name from the table above
        --wx.wxMessageBox (droName)
        local val = mc.mcProfileGetString(inst, "PersistentDROs", (droName), "NotFound") -- Get the Value from the profile ini
        if(val ~= "NotFound")then -- If the value is not equal to NotFound
            scr.SetProperty((droName), "Value", val) -- Set the dros value to the value from the profile ini
        end -- End the If statement
    end -- End the For loop
end






-- Initialize persistent globals on first run
if not _G.toolPLCInit then
    _G.toolPLCInit = true
    _G.lastTool = -999  -- Force first update
	_G.lastSyncedTool = -999
    _G.lastPollTime = os.clock()
    _G.debounceStart = nil
    _G.debouncing = false
    _G.enablePromptDone = false
    _G.toolPresentHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    
    -- Validate handle
    if not _G.toolPresentHandle or _G.toolPresentHandle <= 0 then
        mc.mcCntlSetLastError(inst, "ERROR: Invalid handle for Input #17 (Tool Present)")
        _G.toolPresentHandle = nil
    end
    
    -- Set current tool to 0 on startup
    mc.mcToolSetCurrent(inst, 0)
end





-- Function to prompt tool selection
local function promptToolSelection(isStartup)
    -- CHECK M6 PROTECTION FLAG FIRST
    local virtualToolActive = mc.mcCntlGetPoundVar(inst, 406) >= 90
    local suppressPrompt = mc.mcCntlGetPoundVar(inst, 498) == 1

    if virtualToolActive or suppressPrompt then
        return
    end
    
    -- Build filtered tool list (exclude T0 and virtual tools)
    local filteredChoices = {}
    local filteredNumbers = {}
    
    if _G.toolChoices and _G.toolNumbers then
        for i, toolNum in ipairs(_G.toolNumbers) do
            -- Exclude T0 and virtual tools (90-99)
            if toolNum > 0 and toolNum < 90 then
                table.insert(filteredChoices, _G.toolChoices[i])
                table.insert(filteredNumbers, toolNum)
            end
        end
    end
    
    if #filteredChoices == 0 then
        mc.mcCntlSetLastError(inst, "ERROR: No physical tools configured")
        -- Set to T1 by default if no tools available
        mc.mcToolSetCurrent(inst, 1)
        mc.mcCntlGcodeExecuteWait(inst, "G49")
        wx.wxMilliSleep(100)
        mc.mcCntlGcodeExecuteWait(inst, "G43 H1")
        return
    end
    
    local message = isStartup and 
        "Tool detected in spindle at startup.\nSelect the actual tool:" or
        "Tool inserted manually.\nSelect the tool number:"
    
    -- Create dialog with filtered choices
    local dlg = wx.wxSingleChoiceDialog(wx.NULL, 
        message, 
        isStartup and "Tool Mismatch Detected" or "Tool Confirmation", 
        filteredChoices)
    
    -- Create a timer to handle spindle button while dialog is open
    local timerPanel = wx.wxPanel(dlg, wx.wxID_ANY)
    local timer = wx.wxTimer(timerPanel)
    local spindleCancelled = false
    
    -- Get handles for Input 8 and Output 2
    local input8Handle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT8)
    local out2Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
    
    -- Store initial Input 8 state
    local lastInput8 = 0
    if input8Handle and input8Handle > 0 then
        lastInput8 = mc.mcSignalGetState(input8Handle)
    end
    
    -- Debounce variables
    local buttonPressStart = 0
    local buttonHoldRequired = 0.5  -- Require 500ms hold to trigger
    local buttonHeld = false
    
    -- Timer event - runs every 50ms while dialog is open
    timerPanel:Connect(wx.wxEVT_TIMER, function(event)
        if not input8Handle or input8Handle <= 0 then
            return
        end
        
        local currentInput8 = mc.mcSignalGetState(input8Handle)
        
        -- ALWAYS mirror Input 8 to Output 2 (this is what PLC normally does)
        if out2Handle and out2Handle > 0 then
            mc.mcSignalSetState(out2Handle, currentInput8)
        end
        
        -- Check for button press with debounce
        if currentInput8 == 1 and lastInput8 == 0 then
            -- Button just pressed - start timing
            buttonPressStart = os.clock()
            buttonHeld = false
        elseif currentInput8 == 1 and lastInput8 == 1 then
            -- Button still held - check if held long enough
            if not buttonHeld and (os.clock() - buttonPressStart) >= buttonHoldRequired then
                -- Button held long enough - trigger action
                buttonHeld = true
                spindleCancelled = true
                
                -- Close the dialog immediately
                dlg:EndModal(wx.wxID_CANCEL)
                timer:Stop()
            end
        elseif currentInput8 == 0 and lastInput8 == 1 then
            -- Button released - reset
            buttonPressStart = 0
            buttonHeld = false
        end
        
        lastInput8 = currentInput8
    end)
    
    -- Start timer (check every 50ms)
    timer:Start(50)
    
    -- Show dialog (this blocks PLC until closed)
    local result = dlg:ShowModal()
    
    -- Stop timer
    timer:Stop()
    
    -- Check how dialog was closed
    if spindleCancelled then
        -- Dialog closed by spindle button - user is removing tool
        -- Set tool to T0
        mc.mcToolSetCurrent(inst, 0)
        mc.mcCntlGcodeExecuteWait(inst, "G49")  -- Cancel H offset
        
        -- Update display
        if UpdateToolPreview then
            UpdateToolPreview()
        end
        
        mc.mcCntlSetLastError(inst, "Tool removed - T0 set")
        
        -- DO NOT set any flag to skip next check
        -- Let the normal PLC flow handle what happens when clamp closes again
        
    elseif result == wx.wxID_OK then
        -- User selected a tool
        local selection = dlg:GetSelection()  -- 0-based
        local newTool = filteredNumbers[selection + 1]  -- Use filtered list
        
        -- Force PLC to see a change even if same tool selected
        _G.lastTool = -999
        
        mc.mcToolSetCurrent(inst, newTool)
        wx.wxMilliSleep(50)
        
        -- SYNC H OFFSET
        mc.mcCntlGcodeExecuteWait(inst, "G49")  -- Cancel first
        wx.wxMilliSleep(100)
        
        if newTool > 0 then
            mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", newTool))
            wx.wxMilliSleep(100)
            
            -- Record when dialog set the H offset
            _G.hOffsetLastSync = os.clock()
            
            -- Verify
            local activeH = mc.mcCntlGetPoundVar(inst, 4120)
            local desc = mc.mcToolGetDesc(inst, newTool) or "Unnamed"
        else
            _G.hOffsetLastSync = os.clock()
        end
        
        if UpdateToolPreview then
            UpdateToolPreview()
        end
    else
        -- User clicked Cancel or closed with X
        if isStartup then
            -- At startup, default to T1 for safety
            mc.mcToolSetCurrent(inst, 1)
            
            mc.mcCntlGcodeExecuteWait(inst, "G49")
            wx.wxMilliSleep(100)
            mc.mcCntlGcodeExecuteWait(inst, "G43 H1")
            
            -- Record when dialog set the H offset
            _G.hOffsetLastSync = os.clock()
            
            wx.wxMessageBox("Tool selection cancelled.\n\nTool has been set to T1 by default.\nPlease verify the correct tool number.", 
                           "Tool Set to T1", wx.wxOK + wx.wxICON_WARNING)
        else
            -- Manual insertion cancelled - leave at T0
            wx.wxMessageBox("Tool change cancelled. Tool not updated.", "Info", wx.wxOK + wx.wxICON_INFORMATION)
        end
        
        -- Update the preview label
        if UpdateToolPreview then
            UpdateToolPreview()
        end
    end
    
    dlg:Destroy()  -- Always destroy dialog
end





-- Check for enable condition (tool present but T0 active) - ONLY when machine is enabled
if machEnabled == 1 and not _G.enablePromptDone and _G.toolPresentHandle then
    local toolPresent = mc.mcSignalGetState(_G.toolPresentHandle)
    --local currentTool = mc.mcToolGetCurrent(inst)
    
    -- Check protection flags
    local m6Running = mc.mcCntlGetPoundVar(inst, 499) == 1
    local suppressPrompt = mc.mcCntlGetPoundVar(inst, 498) == 1
    
    if toolPresent == 1 and currentTool == 0 and not suppressPrompt and currentTool < 90 then
        promptToolSelection(true)  -- true = startup
    end
    _G.enablePromptDone = true
elseif machEnabled == 0 then
    -- Reset flag when machine is disabled so prompt can show again next enable
    _G.enablePromptDone = false
end

-- Monitor current tool and sync dropdown if no user selection active
currentTool = mc.mcToolGetCurrent(inst)
if currentTool ~= _G.lastTool then
    local toolChangeTime = os.clock()
    _G.lastTool = currentTool
	
	
    -- Only sync H offset if machine is idle, no M6 running, and enough time has passed
    local machState = mc.mcCntlGetState(inst)
    local m6Running = mc.mcCntlGetPoundVar(inst, 499) == 1
    
    -- Check if this was a recent manual sync (within 1 second)
    local timeSinceLastSync = toolChangeTime - (_G.hOffsetLastSync or 0)
    
    if machState == 0 and timeSinceLastSync > 1.0 then
        -- Check if H offset is already correct
        local currentH = mc.mcCntlGetPoundVar(inst, 4120)
        local compMode = mc.mcCntlGetPoundVar(inst, 4008)
        
        local needsSync = false
        if currentTool == 0 and compMode == 43 then
            needsSync = true  -- T0 but H offset active
        elseif currentTool > 0 and (compMode == 49 or currentH ~= currentTool) then
            needsSync = true  -- Tool > 0 but wrong/no H offset
        end
        
        if needsSync then
            mc.mcCntlGcodeExecuteWait(inst, "G49")
            if currentTool > 0 then
                mc.mcCntlGcodeExecuteWait(inst, string.format("G43 H%d", currentTool))
              --  mc.mcCntlSetLastError(inst, string.format("PLC: H offset synced to H%d for T%d", currentTool, currentTool))
            else
              --  mc.mcCntlSetLastError(inst, "PLC: H offset cancelled for T0")
            end
            _G.hOffsetLastSync = os.clock()
        end
    end
    
    -- Update dropdown to reflect current tool (existing code)
    if not _G.selectedToolIndex then
        -- Find tool in dropdown list
        local index = -1
        if _G.toolNumbers then
            for i, t in ipairs(_G.toolNumbers) do
                if t == currentTool then
                    index = i - 1  -- Convert to 0-based
                    break
                end
            end
        end
        
        if index >= 0 then
            scr.SetProperty("lstCurrentTool", "Value", tostring(index))
        else
            -- Tool not in dropdown - set to T0
            scr.SetProperty("lstCurrentTool", "Value", "0")
        end
        
        -- Update preview
        if UpdateToolPreview then
            UpdateToolPreview()
        end
    end
end





-- DUST/VACUUM/BOOT AUTOMATION - POUND VARIABLE VERSION

-- Initialize on first run
if not _G.dustAutoInit then
    _G.dustAutoInit = true
    _G.lastMachineState = mc.mcCntlGetState(inst)
    
    -- Initialize pound variables if they're uninitialized (will be -1.79e308)
    if mc.mcCntlGetPoundVar(inst, 400) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 400, 0)  -- Dust collect auto
    end
    if mc.mcCntlGetPoundVar(inst, 401) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 401, 0)  -- Vacuum auto
    end
    if mc.mcCntlGetPoundVar(inst, 402) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 402, 0)  -- Dust boot auto
    end
    if mc.mcCntlGetPoundVar(inst, 499) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 499, 0)  -- M6 running flag
    end
    if mc.mcCntlGetPoundVar(inst, 496) < -1e300 then
        mc.mcCntlSetPoundVar(inst, 496, 0)  -- Probe flag
    end
    
end

-- Get current machine state
local currentState = mc.mcCntlGetState(inst)

-- Check M6 protection flags
local m6Flag = mc.mcCntlGetPoundVar(inst, 499)
local probeFlag = mc.mcCntlGetPoundVar(inst, 496)

-- Only process on state changes
if currentState ~= _G.lastMachineState then
    
    -- Define state constants
    local STATE_IDLE = 0
    local STATE_FRUN = 100
    
    -- PROGRAM START: Idle -> Feed Run
    if _G.lastMachineState == STATE_IDLE and currentState == STATE_FRUN then
        
        -- Check dust collection auto (#400)
        if mc.mcCntlGetPoundVar(inst, 400) == 1 then
            local hDust = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT4)
            if hDust and hDust > 0 then
                mc.mcSignalSetState(hDust, 1)  -- Turn ON
            end
        end
        
        -- Check dust boot auto (#402)
        if mc.mcCntlGetPoundVar(inst, 402) == 1 then
            local hBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
            if hBoot and hBoot > 0 then
                mc.mcSignalSetState(hBoot, 1)  -- Lower boot
            end
        end
        
        -- Log what's enabled
        local dustOn = mc.mcCntlGetPoundVar(inst, 400) == 1
        local bootOn = mc.mcCntlGetPoundVar(inst, 402) == 1
      
        
    -- PROGRAM END: Feed Run -> Idle
    elseif _G.lastMachineState == STATE_FRUN and currentState == STATE_IDLE then
        
        -- Check if probe is running - if so, DO NOT auto stop!
        if probeFlag == 1 then
            -- M6/Probe is running, skip auto stop
        else
            -- Normal auto stop behavior
            local msg = "AUTO STOP: "
            
            -- Always turn off dust collection
            local hDust = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT4)
            if hDust and hDust > 0 then
                mc.mcSignalSetState(hDust, 0)  -- Turn OFF
                msg = msg .. "Dust OFF, "
            end
            
            -- Always raise dust boot
            local hBoot = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT3)
            if hBoot and hBoot > 0 then
                mc.mcSignalSetState(hBoot, 0)  -- Raise boot
                msg = msg .. "Boot UP, "
            end
            
            -- Check vacuum auto shutdown (#401)
            if mc.mcCntlGetPoundVar(inst, 401) == 1 then
                local hVac1 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT5)
                local hVac2 = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT6)
                
                if hVac1 and hVac1 > 0 then
                    mc.mcSignalSetState(hVac1, 0)  -- Turn OFF
                end
                if hVac2 and hVac2 > 0 then
                    mc.mcSignalSetState(hVac2, 0)  -- Turn OFF
                end
                msg = msg .. "Vacuums OFF"
            else
                msg = msg .. "Vacuums unchanged"
            end
            
            mc.mcCntlSetLastError(inst, msg)
        end
    end
    
    -- Update last state for next cycle
    _G.lastMachineState = currentState
end




-- ===== HOMING INDICATOR AND WARNING RESET =====
do
    local inst = mc.mcGetInstance()
    
    -- Initialize persistent variables
    if _G.lastHomingFlashState == nil then
        _G.lastHomingFlashState = nil
        _G.lastHomedState = nil
        _G.AXES_HOMED = false
    end
    
    -- Check if all axes are homed
    local allHomed = true
    local unhomedAxes = {}
    
    for axis = 0, 5 do
        local enabledOk, enabled = pcall(mc.mcAxisIsEnabled, inst, axis)
        local homedOk, homed = pcall(mc.mcAxisIsHomed, inst, axis)
        
        if enabledOk and homedOk then
            if enabled == 1 and homed ~= 1 then
                allHomed = false
                table.insert(unhomedAxes, axis)
            end
        end
    end
    
    -- Calculate flash state
    local flashOn = (math.floor(testcount / 6) % 2) == 0
    
    -- Update button appearance if not all homed
    if not allHomed then
        if _G.lastHomingFlashState ~= flashOn or _G.lastHomedState ~= allHomed then
            local color = flashOn and "#FFFF00" or "#4B4B4B"
            
            pcall(scr.SetProperty, "btnRefAllAxes", "Bg Color", color)
            pcall(scr.SetProperty, "btnRefAllAxes", "Fg Color", "#000000")
            pcall(scr.SetProperty, "btnRefAllAxes", "Label", "HOME\nREQUIRED")
            
            _G.lastHomingFlashState = flashOn
        end
    else
        -- All axes homed - restore normal button
        if _G.lastHomedState == false or _G.lastHomedState == nil then
            pcall(scr.SetProperty, "btnRefAllAxes", "Bg Color", "#4B4B4B")
            pcall(scr.SetProperty, "btnRefAllAxes", "Fg Color", "#FFFFFF")
            pcall(scr.SetProperty, "btnRefAllAxes", "Label", "Ref All\nAxis")
        end
        
        -- Reset warning bypass when all axes are homed
        if _G.HOMING_WARNING_IGNORED then
            _G.HOMING_WARNING_IGNORED = false
        end
    end
    
    -- Update global state
    _G.lastHomedState = allHomed
    _G.AXES_HOMED = allHomed
end
-- ===== END HOMING INDICATOR AND WARNING RESET =====







-- ============================================
-- Work Offset Monitoring Section
-- Monitors and syncs button states
-- ============================================
-- Initialize tracking variable if needed
if not _G.lastWorkOffset then
    _G.lastWorkOffset = -1  -- Force first update
end

-- Get current work offset
local currentOffset = mc.mcCntlGetPoundVar(inst, mc.SV_MOD_GROUP_14 or 5220)

-- Check if offset has changed
if currentOffset ~= _G.lastWorkOffset then
    -- Update buttons if the function exists
    if UpdateWorkOffsetButtons then
        UpdateWorkOffsetButtons()
    end
    
    -- Only log if this is a real change (not initialization)
    if _G.lastWorkOffset ~= -1 then
        if currentOffset >= 54 and currentOffset <= 59 then
            -- Standard G54-G59
            mc.mcCntlSetLastError(inst, string.format("Work Offset: G%.0f", currentOffset))
        elseif math.abs(currentOffset - 54.1) < 0.01 then
            -- G54.1 detected - warn user
            local pNumber = mc.mcCntlGetPoundVar(inst, mc.SV_BUFP or 5219)
            mc.mcCntlSetLastError(inst, string.format("WARNING: G54.1 P%d active - not shown in UI", pNumber))
        else
            -- Unknown offset
            mc.mcCntlSetLastError(inst, string.format("WARNING: Unknown work offset %.1f", currentOffset))
        end
    end
    
    -- Update tracking variable
    _G.lastWorkOffset = currentOffset
end





-- ============================================
-- SOFT LIMITS STATE INITIALIZATION
-- ============================================
if not _G.softLimitsInit then
    _G.softLimitsInit = true
    _G.lastSoftLimitsState = nil  -- Force first update
end

-- ============================================
-- SOFT LIMITS STATE MONITORING
-- Keeps button synchronized with actual state
-- FIXED: Now checks actual per-axis states
-- ============================================

-- Function to check if ANY axis has soft limits enabled
local function getActualSoftLimitsEnabled()
    for axis = 0, 5 do
        if mc.mcAxisIsEnabled(inst, axis) == 1 then
            local state = mc.mcSoftLimitGetState(inst, axis)
            if state and state == 1 then
                return 1  -- At least one axis enabled
            end
        end
    end
    return 0  -- All disabled
end

-- Get current actual state (from axes, not signal)
local softLimitsEnabled = getActualSoftLimitsEnabled()

-- Check if state has changed
if softLimitsEnabled ~= _G.lastSoftLimitsState then
    -- State changed - update button
    if softLimitsEnabled == 1 then
        scr.SetProperty("btnSoftLimits", "Bg Color", "#00FF00")  -- Green
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nENABLED")
        
        -- Only log if this was a change (not initialization)
        if _G.lastSoftLimitsState ~= nil then
            mc.mcCntlSetLastError(inst, "Soft limits ENABLED")
        end
    else
        scr.SetProperty("btnSoftLimits", "Bg Color", "#FF0000")  -- Red
        scr.SetProperty("btnSoftLimits", "Label", "Soft Limits\nDISABLED")
        
        -- Only log if this was a change (not initialization)
        if _G.lastSoftLimitsState ~= nil then
            mc.mcCntlSetLastError(inst, "WARNING: Soft limits DISABLED")
        end
    end
    
    -- Update tracking variable
    _G.lastSoftLimitsState = softLimitsEnabled
end





-- ============================================
-- TOUCH PROBE BUTTON STATE MONITORING
-- ============================================
-- Monitor Output 7 for btnTouchProbe button state
if not _G.lastProbeOutputState then 
    _G.lastProbeOutputState = -1 
end

local output7Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
if output7Handle and output7Handle > 0 then
    local probeActive = mc.mcSignalGetState(output7Handle)
    
    -- Only update if state CHANGED
    if probeActive ~= _G.lastProbeOutputState then
        if probeActive == 1 then
            -- Probe is DOWN (T90 active)
            scr.SetProperty("btnTouchProbe", "Bg Color", "#00FF00")  -- Green
            scr.SetProperty("btnTouchProbe", "Label", "Deactivate Probe\nChange to T0")
        else
            -- Probe is UP (T90 not active)
            scr.SetProperty("btnTouchProbe", "Bg Color", "#FF0000")  -- Red
            scr.SetProperty("btnTouchProbe", "Label", "Activate Probe\nChange to T90")
        end
        _G.lastProbeOutputState = probeActive
    end
end

-- ============================================
-- LASER BUTTON STATE MONITORING
-- ============================================
-- Monitor Output 1 for btnLaserDown button state
if not _G.lastLaserOutputState then 
    _G.lastLaserOutputState = -1 
end

local output1Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT1)
if output1Handle and output1Handle > 0 then
    local laserActive = mc.mcSignalGetState(output1Handle)
    
    -- Only update if state CHANGED
    if laserActive ~= _G.lastLaserOutputState then
        if laserActive == 1 then
            -- Laser is DOWN (T91 active)
            scr.SetProperty("btnLaserDown", "Bg Color", "#00FF00")  -- Green
            scr.SetProperty("btnLaserDown", "Label", "Deactivate Laser\nChange to T0")
        else
            -- Laser is UP (T91 not active)
            scr.SetProperty("btnLaserDown", "Bg Color", "#FF0000")  -- Red
            scr.SetProperty("btnLaserDown", "Label", "Activate Laser\nChange to T91")
        end
        _G.lastLaserOutputState = laserActive
    end
end





-- ============================================
-- Input 8 to Output 2 Mirroring and Tool Detection
-- ============================================
-- Initialize persistent state
if not _G.lastInput8State then 
    _G.lastInput8State = -1 
    _G.toolCheckPending = false
    _G.toolCheckTime = 0
    _G.toolCheckStartTime = nil  -- Track when check started
    _G.lastToolSensorState = -1
end

-- Get Input 8 state
local input8Handle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT8)
if input8Handle and input8Handle > 0 then
    local input8State = mc.mcSignalGetState(input8Handle)
    
    -- Only process on state change
    if input8State ~= _G.lastInput8State then
        -- Mirror to Output 2
        local out2Handle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT2)
        if out2Handle and out2Handle > 0 then
            mc.mcSignalSetState(out2Handle, input8State)
        end
        
        -- Tool detection on falling edge (button release, clamp closing)
        if input8State == 0 and _G.lastInput8State == 1 then
            -- Schedule tool check for 1 second later
            _G.toolCheckPending = true
            _G.toolCheckTime = os.clock() + 1.0
        end
        
        _G.lastInput8State = input8State
    end
end





-- Handle pending tool check after delay
if _G.toolCheckPending and os.clock() >= _G.toolCheckTime then
    
    -- Track when we started trying (NEW!)
    if not _G.toolCheckStartTime then
        _G.toolCheckStartTime = os.clock()
    end
    
    -- Check for timeout (NEW!)
    if os.clock() - _G.toolCheckStartTime > 30 then  -- 30 second timeout
        mc.mcCntlSetLastError(inst, "Tool check cancelled - machine stayed busy for 30 seconds")
        _G.toolCheckPending = false
        _G.toolCheckStartTime = nil
        _G.lastToolSensorState = mc.mcSignalGetState(mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17))
        return  -- Exit without prompting
    end
    
    -- CHECK IF MACHINE IS IN CYCLE OR BUSY
    local machState = mc.mcCntlGetState(inst)
    local inCycle = mc.mcCntlIsInCycle(inst)
    
    -- Check if we're in a macro
    local inMacro = (machState == mc.MC_STATE_MRUN_MACRO) or 
                    (machState == mc.MC_STATE_MRUN_MACRO_HOLD) or
                    (machState == mc.MC_STATE_MRUN_MACROH)
    
    -- Don't prompt if machine is not idle or is in cycle
    if machState ~= 0 or inCycle == 1 then
        -- Machine is busy - reschedule the check for later
        _G.toolCheckPending = true
        _G.toolCheckTime = os.clock() + 1.0  -- Try again in 1 second
        return
    end
    
    -- Machine is idle, proceed with check
    _G.toolCheckPending = false
    _G.toolCheckStartTime = nil  -- Reset for next time (NEW!)
    
    -- Check Input #17 (tool present)
    local toolPresentHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT17)
    if not toolPresentHandle or toolPresentHandle <= 0 then
        return
    end
    
    local toolPresent = mc.mcSignalGetState(toolPresentHandle)
    local currentTool = mc.mcToolGetCurrent(inst)
    
    -- Check if tool sensor state CHANGED from 0 to 1 (tool inserted)
    if toolPresent == 1 and (_G.lastToolSensorState == 0 or _G.lastToolSensorState == -1) then
        
        -- Check if virtual tool is active
        local virtualToolActive = mc.mcCntlGetPoundVar(inst, 406) >= 90
        
        if virtualToolActive then
            -- MUST retract virtual tool to restore offsets!
            if RetractVirtualTool then
                RetractVirtualTool()
                mc.mcCntlSetLastError(inst, "Virtual tool retracted for manual change")
            else
                mc.mcCntlSetLastError(inst, "ERROR: RetractVirtualTool function not found!")
            end
            -- Update current tool after retraction
            currentTool = mc.mcToolGetCurrent(inst)
        end
        
        -- CALL THE UPDATED FUNCTION WITH TIMER
        promptToolSelection(false)  -- false = not startup, manual insertion
    end
    
    -- Update the last tool sensor state
    _G.lastToolSensorState = toolPresent
end





-- ============================================
-- LOW AIR PRESSURE MONITORING
-- ============================================
-- Initialize tracking on first run
if not _G.lowAirInit then
    _G.lowAirInit = true
    _G.lastLowAirState = -1  -- Force first check
    _G.lowAirDisabled = false  -- Track if we disabled the machine
    _G.lowAirDialogShown = false  -- Prevent multiple dialogs
    _G.lowAirDebounceCount = 0  -- Debounce counter
    _G.restoredDialogShown = false  -- Track restore dialog
end

-- Get low air pressure sensor state (Input 6)
local lowAirHandle = mc.mcSignalGetHandle(inst, mc.ISIG_INPUT6)

if lowAirHandle and lowAirHandle > 0 then
    local rawAirState = mc.mcSignalGetState(lowAirHandle)
    
    -- Debounce the signal (must be stable for 3 PLC cycles = 60ms)
    if rawAirState ~= _G.lastLowAirState then
        _G.lowAirDebounceCount = _G.lowAirDebounceCount + 1
        
        if _G.lowAirDebounceCount < 3 then
            -- Not stable yet, keep monitoring
            return  -- Exit this section, don't process yet
        end
        
        -- Signal is stable, process the change
        _G.lowAirDebounceCount = 0  -- Reset counter
        
        if rawAirState == 1 then  -- LOW AIR PRESSURE DETECTED!
            -- Only process if not already disabled by us
            if not _G.lowAirDisabled then
                -- Get current machine state before disabling
                local machState = mc.mcCntlGetState(inst)
                local inCycle = mc.mcCntlIsInCycle(inst)
                
                -- Stop everything in proper sequence
                if inCycle == 1 then
                    -- Try feed hold first
                    mc.mcCntlFeedHold(inst)
                    
                    -- Small delay to let feed hold take effect
                    local waitCount = 0
                    while mc.mcCntlIsInCycle(inst) == 1 and waitCount < 5 do
                        waitCount = waitCount + 1
                        -- Note: Can't use wxMilliSleep in PLC, just count cycles
                    end
                    
                    -- Now stop the cycle
                    mc.mcCntlCycleStop(inst)
                end
                
                -- Stop spindle
                local spindleOn = mc.mcSpindleGetCommandRPM(inst) > 0
                if spindleOn then
                    mc.mcSpindleSetDirection(inst, 0)
                end
                
                -- Disable machine
                mc.mcCntlEnable(inst, 0)
                _G.lowAirDisabled = true
                _G.restoredDialogShown = false  -- Reset for next restoration
                
                -- Log critical error
                mc.mcCntlSetLastError(inst, "*** MACHINE DISABLED: LOW AIR PRESSURE DETECTED ***")
                
                -- Show alert dialog only once per event
                if not _G.lowAirDialogShown then
                    _G.lowAirDialogShown = true
                    
                    -- Use a coroutine to show dialog without blocking PLC
                    coroutine.create(function()
                        wx.wxMessageBox(
                            "LOW AIR PRESSURE DETECTED!\n\n" ..
                            "Machine has been disabled for safety.\n" ..
                            "1. Check air compressor\n" ..
                            "2. Check for air leaks\n" ..
                            "3. Restore air pressure above minimum\n" ..
                            "4. Re-enable machine when pressure is normal",
                            "CRITICAL: Low Air Pressure",
                            wx.wxOK + wx.wxICON_ERROR
                        )
                    end)
                end
            end
            
        else  -- Air pressure restored
            if _G.lowAirDisabled then
                mc.mcCntlSetLastError(inst, "Air pressure restored - machine can be re-enabled")
                _G.lowAirDisabled = false
                _G.lowAirDialogShown = false  -- Reset for next event
                
                -- Show restore message only once
                if not _G.restoredDialogShown then
                    _G.restoredDialogShown = true
                    
                    -- Use coroutine for non-blocking dialog
                    coroutine.create(function()
                        wx.wxMessageBox(
                            "Air pressure has been restored.\n\n" ..
                            "Please verify system is safe before re-enabling machine.",
                            "Air Pressure Restored",
                            wx.wxOK + wx.wxICON_INFORMATION
                        )
                    end)
                end
            end
        end
        
        _G.lastLowAirState = rawAirState
    else
        -- Signal unchanged, reset debounce counter
        _G.lowAirDebounceCount = 0
    end
    
    -- Continuous protection: Prevent enabling while air is low
    -- This runs every cycle regardless of state changes
    if rawAirState == 1 then
        -- Check if someone tried to enable the machine
        local machEnabledHandle = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
        if machEnabledHandle and machEnabledHandle > 0 then
            local currentlyEnabled = mc.mcSignalGetState(machEnabledHandle)
            
            if currentlyEnabled == 1 and _G.lowAirDisabled then
                -- Machine was somehow re-enabled while air is still low - disable again!
                mc.mcCntlEnable(inst, 0)
                mc.mcCntlSetLastError(inst, "*** CANNOT ENABLE: Air pressure still too low! ***")
                
                -- Flash a warning every 2 seconds (100 PLC cycles)
                if testcount % 100 == 0 then
                    mc.mcCntlSetLastError(inst, "*** WARNING: Fix air pressure before enabling! ***")
                end
            end
        end
    end
    
    -- Update visual indicators if they exist (button or LED)
    -- Only update every 10 cycles to reduce overhead
    if testcount % 10 == 0 then
        if scr.GetProperty("btnAirPressure", "Bg Color") ~= nil then
            if rawAirState == 1 then
                scr.SetProperty("btnAirPressure", "Bg Color", "#FF0000")  -- Red
                scr.SetProperty("btnAirPressure", "Label", "Air Pressure\nLOW!")
            else
                scr.SetProperty("btnAirPressure", "Bg Color", "#00FF00")  -- Green
                scr.SetProperty("btnAirPressure", "Label", "Air Pressure\nNORMAL")
            end
        end
        
        if scr.GetProperty("ledAirPressure", "Value") ~= nil then
            scr.SetProperty("ledAirPressure", "Value", rawAirState == 1 and "0" or "1")
        end
    end
    
elseif _G.lastLowAirState ~= -2 then
    -- Log error once if handle is invalid
    mc.mcCntlSetLastError(inst, "WARNING: Cannot monitor air pressure - Input 6 not configured")
    _G.lastLowAirState = -2
end





-- ================================
-- Spindle Spin-UP Dwell
-- ================================
local inst = mc.mcGetInstance()

-- Initialize on first run
if not _G.spinUpDwell then
    _G.spinUpDwell = {
        armed = false,
        delaySeconds = 0,
        startTime = 0,
        pauseActive = false,
        lastSpindleState = 0
    }
end

-- Check if M6 armed the dwell
local spinUpFlag = mc.mcCntlGetPoundVar(inst, 495)
if spinUpFlag == 1 then
    _G.spinUpDwell.armed = true
    _G.spinUpDwell.delaySeconds = mc.mcCntlGetPoundVar(inst, 496) or 0.7
    mc.mcCntlSetPoundVar(inst, 495, 0)  -- Clear flag immediately
    
    if _G.spinUpDwell.delaySeconds > 0 then
        mc.mcCntlSetLastError(inst, string.format("Spindle dwell armed: %.1fs", _G.spinUpDwell.delaySeconds))
    end
end

-- Get machine state
local machState = mc.mcCntlGetState(inst)

-- Only process if armed and machine is running
if _G.spinUpDwell.armed and machState == mc.MC_STATE_FRUN then
    -- Get spindle state (0=off, 1=CW, 2=CCW)
    local spindleState = mc.mcSpindleGetState(inst)
    local spindleOn = (spindleState ~= 0) and 1 or 0
    
    -- Detect spindle start (rising edge from off to on)
    if _G.spinUpDwell.lastSpindleState == 0 and spindleOn == 1 and not _G.spinUpDwell.pauseActive then
        -- Start the dwell
        _G.spinUpDwell.pauseActive = true
        _G.spinUpDwell.startTime = os.clock()
        
        -- Use feed hold to pause motion
        mc.mcCntlFeedHold(inst)
        mc.mcCntlSetLastError(inst, string.format("Spindle spin-up pause: %.1fs", _G.spinUpDwell.delaySeconds))
    end
    
    -- Check if dwell is complete
    if _G.spinUpDwell.pauseActive then
        local elapsed = os.clock() - _G.spinUpDwell.startTime
        
        if elapsed >= _G.spinUpDwell.delaySeconds then
            -- Resume motion
            mc.mcCntlCycleStart(inst)
            
            -- Reset everything
            _G.spinUpDwell.armed = false
            _G.spinUpDwell.pauseActive = false
            _G.spinUpDwell.delaySeconds = 0
            
            mc.mcCntlSetLastError(inst, "Spindle at speed - resuming")
        end
    end
    
    _G.spinUpDwell.lastSpindleState = spindleOn
end

-- Reset if machine stops
if machState == mc.MC_STATE_IDLE then
    if _G.spinUpDwell.pauseActive then
        _G.spinUpDwell.pauseActive = false
        _G.spinUpDwell.armed = false
        mc.mcCntlSetLastError(inst, "Spindle dwell cancelled - machine idle")
    end
end




-------------------------------------------------------
--This is the last thing we do.  So keep it at the end of the script!
machStateOld = machState;
machWasEnabled = machEnabled;
