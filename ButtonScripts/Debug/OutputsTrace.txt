-- OutputsTrace.txt
-- Purpose: Identify precisely who (file:line) reasserts OSIG_OUTPUT3..6 to 1 after OFF.
-- Safe: Does not enable/disable machine or e-stop. All tracing/guarding is temporary for this run.

local inst = mc.mcGetInstance()

-- ========================= User Toggles =========================
local FORCE_AUTOS_OFF   = true   -- set autos/targets to 0 before tests
local TRACE_MS          = 1200   -- trace window duration (ms)
local TRACE_GUARD_ON    = true   -- within trace window, block ON (1) writes to O3..O6 and log caller
local DELAY_MS          = 150    -- readback delay after each traced write (ms)
local SAMPLE_OFF_FAST   = 10     -- rapid sampling step (ms) for OFF->1 reassert timing
local SAMPLE_OFF_SLOW   = 50     -- slower sampling step (ms)
local TEST_OUTPUTS      = {3,4,5,6,7}

-- ========================= Helpers ==============================
local function log(level, msg)
  level = level or "INFO"
  mc.mcCntlSetLastError(inst, string.format("[OUTTRACE][%s] %s", level, tostring(msg)))
end

local function sigConst(n)
  return mc[string.format("OSIG_OUTPUT%d", n)]
end

local function getHandle(id)
  local h = mc.mcSignalGetHandle(inst, id)
  return h
end

local function readSig(id)
  local h = getHandle(id)
  if not h or h == 0 then return -1 end
  return mc.mcSignalGetState(h) or -1
end

local function writeSig(id, v)
  local h = getHandle(id)
  if not h or h == 0 then return false, -1, -1 end
  mc.mcSignalSetState(h, (v and 1 or 0))
  local imm = mc.mcSignalGetState(h)
  wx.wxMilliSleep(DELAY_MS)
  local aft = mc.mcSignalGetState(h)
  return true, imm, aft
end

local function pvGet(n)
  local v
  if SystemLib and SystemLib.PoundVarGet then v = SystemLib.PoundVarGet(inst,n) else v = mc.mcCntlGetPoundVar(inst,n) end
  return (type(v)=="number") and v or (tonumber(v) or 0)
end

local function pvSet(n, v)
  if SystemLib and SystemLib.PoundVarSet then return SystemLib.PoundVarSet(inst,n,v) else return mc.mcCntlSetPoundVar(inst,n,v) end
end

local function enabled()
  local h = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_ENABLED)
  return (h and h~=0 and mc.mcSignalGetState(h) == 1) and 1 or 0
end

local function getCaller(depth)
  depth = depth or 3
  local info = debug.getinfo(depth, "Sl")
  if not info then return "<unknown>" end
  local src = tostring(info.short_src or info.source or "?")
  local line = tostring(info.currentline or "?")
  return string.format("%s:%s", src, line)
end

-- ========================= Setup & Snapshot =====================
log("INFO", "=== Outputs Trace: begin ===")
log("INFO", string.format("Profile=%s  Time=%s  Enabled=%d",
  tostring(mc.mcProfileGetName(inst)), os.date("%Y-%m-%d %H:%M:%S"), enabled()))

if FORCE_AUTOS_OFF then
  log("WARNING", "FORCE_AUTOS_OFF=true -> clearing autos (#400/#401/#402) and targets (#404/#403/#411/#412)")
  pvSet(400,0); pvSet(401,0); pvSet(402,0);
  pvSet(404,0); pvSet(403,0); pvSet(411,0); pvSet(412,0);
end

-- Probe UI controls (to verify color-binding names) â€” non-fatal
do
  local probe = {
    "btnBootAuto","btnDustBootAuto","btnDustAuto","btnDustCollectAuto","btnVacAuto","btnVacuumAuto",
  }
  for _, name in ipairs(probe) do
    local ok, val = pcall(scr.GetProperty, name, "Button State")
    if ok and val ~= nil then log("INFO", string.format("UI control present: %s state=%s", name, tostring(val))) end
  end
end

-- ========================= Phase 1: Direct OFF & timing =========
for _, n in ipairs(TEST_OUTPUTS) do
  local id = sigConst(n)
  local start = readSig(id)
  log("INFO", string.format("O%d start=%s", n, tostring(start)))
  local ok, imm, aft = writeSig(id, 0)
  log("INFO", string.format("O%d direct OFF -> imm=%s delayed=%s", n, tostring(imm), tostring(aft)))
  -- OFF->1 timing sample up to ~700 ms
  local t0 = wx.wxGetUTCTimeMillis and wx.wxGetUTCTimeMillis() or os.clock()*1000
  local first1
  for i=1,20 do
    wx.wxMilliSleep(SAMPLE_OFF_FAST)
    if readSig(id) == 1 then first1 = ( (wx.wxGetUTCTimeMillis and wx.wxGetUTCTimeMillis() or os.clock()*1000) - t0 ); break end
  end
  if not first1 then
    for i=1,10 do
      wx.wxMilliSleep(SAMPLE_OFF_SLOW)
      if readSig(id) == 1 then first1 = ( (wx.wxGetUTCTimeMillis and wx.wxGetUTCTimeMillis() or os.clock()*1000) - t0 ); break end
    end
  end
  if first1 then log("INFO", string.format("O%d OFF->1 reassert ~%d ms", n, first1)) end
end

-- ========================= Phase 2: Caller Trace Window =========
log("INFO", string.format("TRACE window: %d ms; guard=%s", TRACE_MS, tostring(TRACE_GUARD_ON)))
local traced = {}
local function acc(n, what, caller)
  traced[n] = traced[n] or {}
  local key = tostring(caller).."|"..tostring(what)
  traced[n][key] = (traced[n][key] or 0) + 1
end

local saved = { }
if SystemLib then
  saved.sigSet = SystemLib.SignalSetState
  saved.sigWrite = SystemLib.Signals and SystemLib.Signals.Write

  SystemLib.SignalSetState = function(_, signal, state)
    local id = signal
    if type(signal) == "string" and mc[signal] then id = mc[signal] end
    local outN
    for _, n in ipairs({3,4,5,6}) do if id == sigConst(n) then outN = n break end end
    local caller = getCaller(3)
    if outN and TRACE_GUARD_ON and state == 1 then
      log("WARNING", string.format("GUARD block ON: O%d by %s", outN, caller))
      acc(outN, "block_on", caller)
      return true
    end
    local ok = false
    if saved.sigSet then ok = pcall(saved.sigSet, SystemLib, signal, state) end
    if outN then
      local imm = readSig(id)
      wx.wxMilliSleep(DELAY_MS)
      local aft = readSig(id)
      log("DEBUG", string.format("TRACE write O%d by %s -> want=%s imm=%s aft=%s en=%d", outN, caller, tostring(state), tostring(imm), tostring(aft), enabled()))
      acc(outN, string.format("want=%s imm=%s aft=%s", tostring(state), tostring(imm), tostring(aft)), caller)
    end
    return ok
  end

  if SystemLib.Signals then
    SystemLib.Signals.Write = function(_, values, opts)
      for k, v in pairs(values or {}) do
        local id = mc[k] or k
        local outN
        for _, n in ipairs({3,4,5,6}) do if id == sigConst(n) then outN = n break end end
        local caller = getCaller(3)
        if outN and TRACE_GUARD_ON and v then
          log("WARNING", string.format("GUARD block ON: O%d by %s (Signals.Write)", outN, caller))
          acc(outN, "block_on(Write)", caller)
        else
          SystemLib.SignalSetState(SystemLib, id, (v and 1 or 0))
        end
      end
      return true
    end
  end
else
  log("WARNING", "SystemLib missing; trace wrappers unavailable")
end

-- Force all traced outputs OFF, then hold the window
for _, n in ipairs({3,4,5,6}) do writeSig(sigConst(n), 0) end
local tStart = wx.wxGetUTCTimeMillis and wx.wxGetUTCTimeMillis() or os.clock()*1000
while true do
  wx.wxMilliSleep(20)
  local now = wx.wxGetUTCTimeMillis and wx.wxGetUTCTimeMillis() or os.clock()*1000
  if (now - tStart) >= TRACE_MS then break end
end

-- Restore originals
if SystemLib then
  if saved.sigSet then SystemLib.SignalSetState = saved.sigSet end
  if SystemLib.Signals and saved.sigWrite then SystemLib.Signals.Write = saved.sigWrite end
end

-- Summary
for n, bag in pairs(traced) do
  log("INFO", string.format("TRACE summary O%d:", n))
  for key, cnt in pairs(bag) do log("INFO", string.format("  %s -> %d", key, cnt)) end
end

log("INFO", "=== Outputs Trace: end ===")

