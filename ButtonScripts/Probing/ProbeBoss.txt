-- Boss Probe v3.0 - Button Left-Down Script for Mach4
-- Updated to use ProbeLib v2.1 with enhanced library functions

-- Required Pound Variables:
-- #300 = Probe tip diameter
-- #301 = X offset from spindle center to probe tip
-- #302 = Y offset from spindle center to probe tip
-- #303 = Fast feedrate for probing
-- #304 = Slow feedrate for final probe
-- #305 = Maximum probe travel distance
-- #320 = Z offset for probe calibration
-- #321 = Probe lift height (height above surface for XY moves)
-- #388 = Probe mode state (0=normal, 1=sentinel mode) [Used by M311]
-- #389-392 = M311 output variables
-- #391 = Edge position (adjusted for probe radius)
-- #394 = TRUE surface Z in machine coords (H-compensated for datum setting) [Z only]

-- Required Macro:
-- m311.mcs v1.4.0+ must exist in your profile's Macros folder

-- Load libraries
local ProbeLib = require("ProbeLib")
local SystemLib = require("SystemLib")
local UILib = require("UILib")

local inst = ProbeLib.Core.GetInstance()

-- ============================================
-- CONSTANTS
-- ============================================
local SENTINEL_VALUE = -999999.0      -- Impossible position for failure detection
local PROBE_SIGNAL = mc.ISIG_PROBE1   -- Touch probe signal
local PROBE_SETTLE_MS = 100           -- Probe signal settle time

-- Safety constants
local SAFETY_BUFFER = 0.010           -- Soft limit safety margin
local POSITION_TOLERANCE = 0.001      -- Position comparison threshold
local WIDTH_TOLERANCE = 0.0001        -- Minimum valid measurement
local PERPENDICULARITY_RATIO = 0.95   -- Re-probe if X diameter < this ratio of Y

-- UI constants
local BUTTON_HEIGHT = 30              -- Standard button height
local BUTTON_WIDTH = 90               -- Standard button width
local DIALOG_PADDING = 10             -- Standard dialog padding

-- ============================================
-- ROTATION CHECK
-- ============================================
if not ProbeLib.Safety.CheckRotation(inst, "warn") then
    return  -- User cancelled due to rotation
end

-- ============================================
-- TOOL CHECK (using ProbeLib)
-- ============================================
if not ProbeLib.Core.ActivateProbeTool(inst) then
    return  -- User cancelled tool activation
end

-- ============================================
-- PROBE PRECHECK
-- ============================================
if not ProbeLib.Safety.EnsureProbeNotTripped(inst) then
    return  -- Probe is stuck triggered
end

-- ============================================
-- LOAD SAVED SETTINGS (using ProbeLib)
-- ============================================
local settings = SystemLib.Storage.CreateSettings(inst, "BossProbe", {
    MinRadius = 0.5,
    MaxRadius = 2.0,
    ProbeDepth = 0.1,
    ZDrop = 0.5,
    ActionMode = 1,
    PerformZProbe = 0,
    ProbeOrder = 0
})

local lastMinRadius = settings:getFloat("MinRadius", 0.5)
local lastMaxRadius = settings:getFloat("MaxRadius", 2.0)
local lastProbeDepth = settings:getFloat("ProbeDepth", 0.1)
local lastZDrop = settings:getFloat("ZDrop", 0.5)
local lastAction = settings:getInt("ActionMode", 1)
local lastZProbe = settings:getInt("PerformZProbe", 0)
local lastProbeOrder = settings:getInt("ProbeOrder", 0)  -- 0=X first, 1=Y first

-- ============================================
-- CREATE DIALOG
-- ============================================
-- Determine parent window
local parent = wx.NULL
local app = wx.wxGetApp()
if app then
    local ok, top = pcall(function() return app:GetTopWindow() end)
    if ok and top then parent = top end
end

-- Create resizable dialog with saved geometry
local dlg, panel, mainSizer = UILib.ResizableDialog.CreateWithPanel(
    parent, "Boss Probe Setup", "ProbeBossDialog", 380, 520
)

-- Declare all UI elements
local instructText, datumText
local minRadiusLabel, minRadiusInput, maxRadiusLabel, maxRadiusInput
local probeDepthLabel, probeDepthInput, dropLabel, dropInput
local zProbeCheck, actionRadio, probeOrderRadio

-- Create controls
instructText = wx.wxStaticText(panel, wx.wxID_ANY,
    "Position the probe above the circular boss before starting:\n" ..
    "• Roughly centered over the boss\n" ..
    "• High enough to clear the top surface\n" ..
    "• Probe will move outward, descend, then probe inward")
instructText:SetFont(wx.wxFont(9, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_NORMAL, wx.wxFONTWEIGHT_NORMAL))

datumText = wx.wxStaticText(panel, wx.wxID_ANY, "")
datumText:SetFont(wx.wxFont(9, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_NORMAL, wx.wxFONTWEIGHT_NORMAL))

zProbeCheck = wx.wxCheckBox(panel, wx.wxID_ANY, "Probe Z Surface")
zProbeCheck:SetValue(lastZProbe == 1)
zProbeCheck:SetToolTip("Also probe the top surface to set Z datum")

actionRadio = UILib.Controls.ActionRadio(panel, lastAction - 1)

-- Probe order selection
local orderChoices = {"X First, Then Y", "Y First, Then X"}
probeOrderRadio = UILib.Controls.CreateRadioBox(panel, "Probe Order", orderChoices, lastProbeOrder, 2)

-- Function to update datum description
local function UpdateDatumDescription()
    local action = actionRadio:GetSelection() + 1
    local zProbe = zProbeCheck:GetValue()
    
    -- Use library function for base formatting
    local axes = {x = true, y = true}
    if zProbe then axes.z = true end
    local baseDescription = ProbeLib.UI.DatumSummary(action, axes)
    
    -- Build detailed description
    local description = ""
    if action == 1 then  -- Set Datum
        if zProbe then
            description = "Datum will be set to:\n• X0 Y0 at boss center\n• Z0 at top surface of boss"
        else
            description = "Datum will be set to:\n• X0 Y0 at boss center\n• Z unchanged"
        end
    else  -- Print Coords
        if zProbe then
            description = "Will print coordinates of:\n• Boss center (X, Y)\n• Boss top surface (Z)"
        else
            description = "Will print coordinates of:\n• Boss center (X, Y) only"
        end
    end
    datumText:SetLabel(description)
    
    -- Fix layout to prevent button squishing
    panel:Layout()
    mainSizer:Layout()  -- Ensure main sizer recalculates
    dlg:Fit()           -- Fit dialog to content
    dlg:Refresh()       -- Force visual update
end

-- Function to update Z field enable states
local function UpdateZFieldStates()
    local performZProbe = zProbeCheck:GetValue()
    
    -- Enable/disable probe depth (enabled when Z probe is checked)
    probeDepthInput:Enable(performZProbe)
    probeDepthLabel:SetForegroundColour(performZProbe and wx.wxBLACK or wx.wxColour(128, 128, 128))
    
    -- Enable/disable Z drop (enabled when Z probe is unchecked)
    dropInput:Enable(not performZProbe)
    dropLabel:SetForegroundColour(performZProbe and wx.wxColour(128, 128, 128) or wx.wxBLACK)
    
    UpdateDatumDescription()
    -- No need for extra Layout calls here since UpdateDatumDescription now handles it
end

-- Build the UI layout
-- Instructions
mainSizer:Add(instructText, 0, wx.wxALL, DIALOG_PADDING)

-- Boss parameters section
local paramBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Boss Parameters")
local paramGrid = wx.wxFlexGridSizer(4, 2, 5, 10)

-- Minimum radius input
minRadiusLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Min Radius:")
minRadiusInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastMinRadius))
minRadiusInput:SetToolTip("Starting radius for probe search")
paramGrid:Add(minRadiusLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
paramGrid:Add(minRadiusInput, 0, wx.wxEXPAND)

-- Maximum radius input
maxRadiusLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Max Radius:")
maxRadiusInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastMaxRadius))
maxRadiusInput:SetToolTip("Maximum radius before aborting")
paramGrid:Add(maxRadiusLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
paramGrid:Add(maxRadiusInput, 0, wx.wxEXPAND)

-- Probe depth input (for Z probing)
probeDepthLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Probe Depth:")
probeDepthInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastProbeDepth))
probeDepthInput:SetToolTip("Distance below surface for XY probing (when surface probed)")
paramGrid:Add(probeDepthLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
paramGrid:Add(probeDepthInput, 0, wx.wxEXPAND)

-- Z drop input (when not Z probing)
dropLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Z Drop:")
dropInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastZDrop))
dropInput:SetToolTip("Fixed Z drop distance for XY probing (positive value, moves down)")
paramGrid:Add(dropLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
paramGrid:Add(dropInput, 0, wx.wxEXPAND)

paramGrid:AddGrowableCol(1)
paramBox:Add(paramGrid, 0, wx.wxEXPAND + wx.wxALL, 5)
mainSizer:Add(paramBox, 0, wx.wxALL + wx.wxEXPAND, DIALOG_PADDING)

-- Options section
local optionsBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Options")

-- Add Z Probe checkbox
optionsBox:Add(zProbeCheck, 0, wx.wxALL, 5)

-- Add Probe Order radio box
optionsBox:Add(probeOrderRadio, 0, wx.wxEXPAND + wx.wxALL, 5)

-- Add Action radio box
optionsBox:Add(actionRadio, 0, wx.wxEXPAND + wx.wxALL, 5)

mainSizer:Add(optionsBox, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM + wx.wxEXPAND, DIALOG_PADDING)

-- Update controls when changed
zProbeCheck:Connect(wx.wxID_ANY, wx.wxEVT_COMMAND_CHECKBOX_CLICKED, function(event)
    UpdateZFieldStates()
end)

actionRadio:Connect(wx.wxID_ANY, wx.wxEVT_COMMAND_RADIOBOX_SELECTED, function(event)
    UpdateDatumDescription()
end)

-- Initial update
UpdateZFieldStates()
UpdateDatumDescription()

-- Add datum text at bottom
mainSizer:Add(datumText, 0, wx.wxALL + wx.wxALIGN_CENTER, DIALOG_PADDING)

-- Spacer
mainSizer:AddStretchSpacer()

-- Buttons
local buttonSizer = wx.wxStdDialogButtonSizer()
local okBtn = wx.wxButton(panel, wx.wxID_OK, "OK")
local cancelBtn = wx.wxButton(panel, wx.wxID_CANCEL, "Cancel")

okBtn:SetMinSize(wx.wxSize(BUTTON_WIDTH, BUTTON_HEIGHT))
cancelBtn:SetMinSize(wx.wxSize(BUTTON_WIDTH, BUTTON_HEIGHT))

buttonSizer:AddButton(okBtn)
buttonSizer:AddButton(cancelBtn)
buttonSizer:Realize()

mainSizer:Add(buttonSizer, 0, wx.wxALL + wx.wxALIGN_CENTER, 8)

-- Apply layout
panel:SetSizer(mainSizer)
mainSizer:Fit(panel)
dlg:Fit()
dlg:Centre()

-- ============================================
-- SHOW DIALOG AND PROCESS
-- ============================================
if dlg:ShowModal() == wx.wxID_OK then
    -- Get values
    local minRadius = tonumber(minRadiusInput:GetValue())
    local maxRadius = tonumber(maxRadiusInput:GetValue())
    local probeDepth = tonumber(probeDepthInput:GetValue())
    local zDrop = tonumber(dropInput:GetValue())
    local actionSel = actionRadio:GetSelection() + 1
    local performZProbe = zProbeCheck:GetValue()
    local probeOrder = probeOrderRadio:GetSelection()  -- 0=X first, 1=Y first
    
    -- Validate inputs
    if not minRadius or minRadius <= 0 then
        wx.wxMessageBox("Invalid minimum radius value", "Input Error", wx.wxOK + wx.wxICON_ERROR)
        dlg:Destroy()
        return
    end
    
    if not maxRadius or maxRadius <= minRadius then
        wx.wxMessageBox("Maximum radius must be greater than minimum radius", "Input Error", wx.wxOK + wx.wxICON_ERROR)
        dlg:Destroy()
        return
    end
    
    -- Validate Z parameters based on checkbox state
    if performZProbe then
        if not probeDepth or probeDepth <= 0 then
            wx.wxMessageBox("Invalid probe depth value", "Input Error", wx.wxOK + wx.wxICON_ERROR)
            dlg:Destroy()
            return
        end
    else
        if not zDrop or zDrop <= 0 then
            wx.wxMessageBox("Z Drop must be a positive value (downward distance)", "Input Error", wx.wxOK + wx.wxICON_ERROR)
            dlg:Destroy()
            return
        end
    end
    
    -- Save settings (using ProbeLib)
    settings:setFloat("MinRadius", minRadius)
    settings:setFloat("MaxRadius", maxRadius)
    settings:setFloat("ProbeDepth", probeDepth)
    settings:setFloat("ZDrop", zDrop)
    settings:setInt("ActionMode", actionSel)
    settings:setInt("PerformZProbe", performZProbe and 1 or 0)
    settings:setInt("ProbeOrder", probeOrder)
    
    dlg:Destroy()
    
    -- ============================================
    -- CLEANUP FUNCTION
    -- ============================================
    -- MAIN PROBE EXECUTION
    -- ============================================
    local function ExecuteBossProbe()
        -- Save state BEFORE any operations
        local startState = {
            -- Machine positions for ALL movements
            machX = mc.mcAxisGetMachinePos(inst, 0),
            machY = mc.mcAxisGetMachinePos(inst, 1),
            machZ = mc.mcAxisGetMachinePos(inst, 2),
            
            -- Work positions for display/logging ONLY
            workX = mc.mcAxisGetPos(inst, mc.X_AXIS),
            workY = mc.mcAxisGetPos(inst, mc.Y_AXIS),
            workZ = mc.mcAxisGetPos(inst, mc.Z_AXIS),
            
            -- Action mode
            actionMode = actionSel
        }
        
        -- Save critical pound variables for rollback
        local savedPoundVars = {
            [305] = mc.mcCntlGetPoundVar(inst, 305),  -- Max travel
            [388] = mc.mcCntlGetPoundVar(inst, 388),  -- Sentinel mode flag
            [395] = mc.mcCntlGetPoundVar(inst, 395),  -- Runtime storage
            [396] = mc.mcCntlGetPoundVar(inst, 396),  -- Runtime storage
            [397] = mc.mcCntlGetPoundVar(inst, 397)   -- Runtime storage
        }
        
        -- Main probe sequence variables
        local success = false
        local datumWasSet = false
        local errorMsg = nil
        
        -- Cleanup function that ALWAYS runs (defined here so variables are in scope)
        local function ProbeCleanup()
            -- Use ProbeLibrary cleanup with proper parameters
            ProbeLib.Cleanup.Standard(inst, success, errorMsg)
            
            -- Additional boss-specific cleanup
            if savedPoundVars then
                for var, value in pairs(savedPoundVars) do
                    if type(value) == "number" then
                        mc.mcCntlSetPoundVar(inst, var, value)
                    end
                end
            end
            -- Success messages are handled by main function
        end
        
        -- CRITICAL: Use xpcall for better error handling
        local ok, err = xpcall(
            function()
                -- Check if probe is already triggered
                if mc.mcSignalGetState(inst, PROBE_SIGNAL) == 1 then
                    local msg = "PROBE STUCK TRIGGERED\n\n" ..
                                "The probe is already triggered before starting.\n\n" ..
                                "Possible causes:\n" ..
                                "• Probe tip is touching something\n" ..
                                "• Probe cable fault or short circuit\n" ..
                                "• Probe needs to be reset\n\n" ..
                                "Clear the probe and retry."
                    wx.wxMessageBox(msg, "Probe Error", wx.wxOK + wx.wxICON_ERROR)
                    error("Probe already triggered at start")
                end
                
                -- Initialize probe log with dynamic profile name
                local profileName = mc.mcProfileGetName(inst)
                local probeLogPath = mc.mcCntlGetMachDir(inst) .. "\\Profiles\\" .. profileName .. "\\ProbeLog.csv"
                local logFile = io.open(probeLogPath, "a")
                if logFile then
                    -- Write header if file is new/empty
                    local fileSize = logFile:seek("end")
                    if fileSize == 0 then
                        logFile:write("Timestamp,Method,X,Y,Z\n")
                    end
                    logFile:close()
                end
                
                -- Helper function to log probe events
                local function LogProbeEvent(method, x, y, z)
                    local ok, err = pcall(function()
                        local logFile = io.open(probeLogPath, "a")
                        if logFile then
                            local timestamp = os.date("%Y-%m-%d %H:%M:%S")
                            local logEntry = string.format("%s,%s,%.4f,%.4f,%.4f\n",
                                timestamp, method, x, y, z)
                            logFile:write(logEntry)
                            logFile:close()
                        end
                    end)
                end
                
                -- Get probe parameters from pound variables
                local xProbeOffset = mc.mcCntlGetPoundVar(inst, 301)
                local yProbeOffset = mc.mcCntlGetPoundVar(inst, 302)
                local fastFeed = mc.mcCntlGetPoundVar(inst, 303)
                local slowFeed = mc.mcCntlGetPoundVar(inst, 304)
                local maxTravel = mc.mcCntlGetPoundVar(inst, 305)
                local liftHeight = mc.mcCntlGetPoundVar(inst, 321) or 1.0
                
                -- Validate and set defaults
                if type(xProbeOffset) ~= "number" then xProbeOffset = 0 end
                if type(yProbeOffset) ~= "number" then yProbeOffset = 0 end
                if type(fastFeed) ~= "number" or fastFeed <= 0 then fastFeed = 30 end
                if type(slowFeed) ~= "number" or slowFeed <= 0 then slowFeed = 5 end
                if type(maxTravel) ~= "number" or maxTravel <= 0 then maxTravel = 1.0 end
                if type(liftHeight) ~= "number" or liftHeight <= 0 then liftHeight = 1.0 end
                
                -- Check for uninitialized pound variables
                if xProbeOffset < -1e300 or yProbeOffset < -1e300 or fastFeed < -1e300 or 
                   slowFeed < -1e300 or maxTravel < -1e300 then
                    local msg = "PROBE CONFIGURATION ERROR\n\n" ..
                                "Probe parameters not initialized.\n\n" ..
                                "Please set pound variables:\n" ..
                                "#301 = X offset from spindle to probe\n" ..
                                "#302 = Y offset from spindle to probe\n" ..
                                "#303 = Fast probe feedrate\n" ..
                                "#304 = Slow probe feedrate\n" ..
                                "#305 = Maximum probe travel distance"
                    wx.wxMessageBox(msg, "Configuration Error", wx.wxOK + wx.wxICON_ERROR)
                    error("Probe parameters not initialized. Set #301-305")
                end
                
                -- Store machine coordinates for all movements
                local probeMachinePoints = {}
                local probeWorkPoints = {}  -- For display only
                local successfulRadii = {}  -- Track successful radius for each direction
                
                -- Track probe progress for error reporting
                local probeProgress = {
                    attempted = {},
                    completed = {},
                    failed = nil
                }
                
                -- ============================================
                -- PHASE 1: OPTIONAL Z PROBE
                -- ============================================
                local surfaceMachZ, safePlaneMachZ, probePlaneMachZ
                local surfaceWorkZ  -- For display only
                
                if performZProbe then
                 --   mc.mcCntlSetLastError(inst, "Probing surface...")
                    
                    -- Perform Z probe using ProbeLib (S5 = probe -Z direction)
                    local probeSuccess, surfaceWork, surfaceMach = ProbeLib.Movement.ExecuteProbe(inst, 5, "Z surface")
                    surfaceMachZ = surfaceMach
                    
                    if not probeSuccess then
                        local msg = string.format(
                            "Z PROBE FAILURE\n\n" ..
                            "The probe did not make contact within %.3f inches.\n\n" ..
                            "Possible causes:\n" ..
                            "• Probe not positioned over the boss\n" ..
                            "• Boss is lower than expected\n" ..
                            "• Probe cable disconnected\n\n" ..
                            "The probe sequence has stopped.",
                            maxTravel or 0.5)
                        
                        wx.wxMessageBox(msg, "Probe Failure", wx.wxOK + wx.wxICON_ERROR)
                        error("Z probe failed - no surface detected")
                    end
                    
                    -- Get work coordinate for display
                    surfaceWorkZ = surfaceWork
                    
                    -- Log the Z probe
                    LogProbeEvent("S5 M311", startState.workX, startState.workY, surfaceWorkZ)
                    
                    -- Calculate working planes in MACHINE coordinates
                    safePlaneMachZ = surfaceMachZ + liftHeight
                    probePlaneMachZ = surfaceMachZ - probeDepth
                    
                 --   mc.mcCntlSetLastError(inst, string.format("Surface at Z%.4f", surfaceWorkZ))
                else
                    -- No Z probe - use current MACHINE position and Z drop
                    surfaceMachZ = nil  -- No surface reference
                    safePlaneMachZ = startState.machZ  -- Current position is safe plane
                    probePlaneMachZ = startState.machZ - zDrop  -- Simple drop from current
                end
                
                -- Check if planes exceed Z soft limits using library function
                local maxUpTravel = ProbeLib.Movement.GetMaxSafeTravel(inst, mc.Z_AXIS, 1, SAFETY_BUFFER)
                local currentZ = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)
                local neededTravel = safePlaneMachZ - currentZ
                
                if neededTravel > 0 and neededTravel > maxUpTravel then
                    local msg = string.format(
                        "Z SOFT LIMIT ERROR\n\n" ..
                        "Safe plane (Z%.3f) would exceed soft limit.\n" ..
                        "Available travel: %.3f\"\n\n" ..
                        "Possible solutions:\n" ..
                        "• Lower the probe start position\n" ..
                        "• Reduce lift height (#321)\n" ..
                        "• Adjust Z soft limits if safe to do so",
                        safePlaneMachZ, maxUpTravel)
                    wx.wxMessageBox(msg, "Soft Limit Error", wx.wxOK + wx.wxICON_ERROR)
                    error(string.format("Safe plane would exceed Z soft limit"))
                end
                end
                
                -- Store for error recovery
                mc.mcCntlSetPoundVar(inst, 395, surfaceMachZ or -1e308)
                mc.mcCntlSetPoundVar(inst, 396, safePlaneMachZ)
                mc.mcCntlSetPoundVar(inst, 397, probePlaneMachZ)
                
                -- Move to safe plane if we performed Z probe
                if performZProbe then
                    mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Z%.4f", safePlaneMachZ))
                end
                
                -- ============================================
                -- PHASE 2: XY BOSS PROBING
                -- ============================================
                -- Define probe sequence based on user selection
                local directions = {
                    {name = "+X", x = 1, y = 0, probe = "S2 M311", axis = mc.X_AXIS},   -- Probe -X (inward)
                    {name = "-X", x = -1, y = 0, probe = "S1 M311", axis = mc.X_AXIS},  -- Probe +X (inward)
                    {name = "+Y", x = 0, y = 1, probe = "S4 M311", axis = mc.Y_AXIS},   -- Probe -Y (inward)
                    {name = "-Y", x = 0, y = -1, probe = "S3 M311", axis = mc.Y_AXIS}   -- Probe +Y (inward)
                }
                
                -- Apply probe order if Y first selected
                if probeOrder == 1 then  -- Y first
                    -- Swap X and Y pairs
                    local temp = {directions[1], directions[2]}
                    directions[1] = directions[3]
                    directions[2] = directions[4]
                    directions[3] = temp[1]
                    directions[4] = temp[2]
                end
                
                for i, dir in ipairs(directions) do
                    table.insert(probeProgress.attempted, dir.name)
                    
                    local currentRadius = minRadius
                    local centerSuccess = false
                    local attemptNum = 0
                    local maxAttempts = 10
                    
                    -- Center on the perpendicular axis if already probed (respects probe order)
                    local probeStartMachX = startState.machX
                    local probeStartMachY = startState.machY
                    
                    -- FIX: Respect probe order for centering logic
                    if probeOrder == 0 then  -- X first (default)
                        -- For Y probes, center on X if already measured
                        if (dir.name == "+Y" or dir.name == "-Y") and probeMachinePoints.xPlus and probeMachinePoints.xMinus then
                            probeStartMachX = (probeMachinePoints.xPlus + probeMachinePoints.xMinus) / 2.0
                            mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f", probeStartMachX))
                        end
                    else  -- Y first
                        -- For X probes, center on Y if already measured
                        if (dir.name == "+X" or dir.name == "-X") and probeMachinePoints.yPlus and probeMachinePoints.yMinus then
                            probeStartMachY = (probeMachinePoints.yPlus + probeMachinePoints.yMinus) / 2.0
                            mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Y%.4f", probeStartMachY))
                        end
                    end
                    
                    while not centerSuccess and currentRadius <= maxRadius and attemptNum < maxAttempts do
                        attemptNum = attemptNum + 1
                        
                        -- Check soft limits before moving
                        local currentMachPos = mc.mcAxisGetMachinePos(inst, dir.axis)
                        local maxSafeTravel = ProbeLib.Movement.GetMaxSafeTravel(inst, dir.axis, dir.x + dir.y)
                        
                        if maxSafeTravel < currentRadius then
                            local msg = string.format(
                                "%s SOFT LIMIT ERROR\n\n" ..
                                "Cannot reach minimum radius (%.3f\") due to soft limits.\n" ..
                                "Available travel: %.3f\"\n\n" ..
                                "Possible solutions:\n" ..
                                "• Move probe closer to the boss\n" ..
                                "• Reduce the minimum radius\n" ..
                                "• Adjust soft limits if safe to do so",
                                dir.name, currentRadius, maxSafeTravel)
                            wx.wxMessageBox(msg, "Soft Limit Error", wx.wxOK + wx.wxICON_ERROR)
                            error(string.format("Cannot reach minimum radius for %s due to soft limits", dir.name))
                        end
                        
                        -- 1. Move to radius position at safe plane using MACHINE coordinates
                        local targetMachX = probeStartMachX + (dir.x * currentRadius)
                        local targetMachY = probeStartMachY + (dir.y * currentRadius)
                        local moveCmd = string.format("G53 G0 X%.4f Y%.4f", targetMachX, targetMachY)
                        mc.mcCntlGcodeExecuteWait(inst, moveCmd)
                        
                        -- 2. Drop to probe plane with collision detection using MACHINE coordinates
                        local zProbeCmd = string.format("G53 G31.1 Z%.4f F%.1f", probePlaneMachZ, fastFeed)
                        mc.mcCntlGcodeExecuteWait(inst, zProbeCmd)
                        
                        -- Check if we hit something during Z drop
                        local actualMachZ = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)
                        if math.abs(actualMachZ - probePlaneMachZ) > POSITION_TOLERANCE then
                            -- Hit something - log the Z collision
                            LogProbeEvent("G31.1-Z", 
                                mc.mcAxisGetPos(inst, mc.X_AXIS),
                                mc.mcAxisGetPos(inst, mc.Y_AXIS),
                                mc.mcAxisGetPos(inst, mc.Z_AXIS))
                            
                            -- Return to safe plane using MACHINE coordinates
                            mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Z%.4f", safePlaneMachZ))
                            
                            -- Calculate smart retreat
                            local remainingDist = maxRadius - currentRadius
                            local retreat = ProbeLib.Movement.SmartRetreatSlice(maxTravel, remainingDist)
                            local nextRadius = currentRadius + retreat
                            
                            -- Check if we're stuck at the same position
                            if math.abs(nextRadius - currentRadius) < POSITION_TOLERANCE then
                                local msg = string.format(
                                    "%s PROBE BLOCKED\n\n" ..
                                    "Cannot extend probe beyond %.3f\" due to repeated collisions.\n" ..
                                    "Boss edge is beyond reachable distance.\n\n" ..
                                    "Possible solutions:\n" ..
                                    "• Move probe closer to the boss center\n" ..
                                    "• Verify probe is positioned above the boss\n" ..
                                    "• Check that boss size matches expectations",
                                    dir.name, currentRadius)
                                wx.wxMessageBox(msg, "Probe Blocked", wx.wxOK + wx.wxICON_ERROR)
                                error(string.format("%s probe blocked - cannot make progress", dir.name))
                            end
                            
                            currentRadius = nextRadius
                       --     mc.mcCntlSetLastError(inst, string.format("%s collision - retrying at %.3f", 
                       --                                              dir.name, currentRadius))
                        else
                            -- Z drop successful, proceed with probe
                            centerSuccess = true
                            successfulRadii[dir.name] = currentRadius
                            
                            -- 3. Enable sentinel mode and set values before probe
                            mc.mcCntlSetPoundVar(inst, 388, 1)  -- Set sentinel mode flag
                            mc.mcCntlSetPoundVar(inst, 389, SENTINEL_VALUE)
                            mc.mcCntlSetPoundVar(inst, 390, SENTINEL_VALUE)
                            mc.mcCntlSetPoundVar(inst, 391, SENTINEL_VALUE)
                            mc.mcCntlSetPoundVar(inst, 392, SENTINEL_VALUE)
                            
                            -- Probe inward
                            local rc = mc.mcCntlGcodeExecuteWait(inst, dir.probe)
                            
                            -- Clear sentinel mode flag
                            mc.mcCntlSetPoundVar(inst, 388, 0)
                            
                            -- Check for probe failure using sentinel
                            local edgeMachine = mc.mcCntlGetPoundVar(inst, 389)  -- Machine coordinate
                            local edgeWork = mc.mcCntlGetPoundVar(inst, 391)     -- Work coordinate for display
                            
                            if edgeMachine == SENTINEL_VALUE then
                                local msg = string.format(
                                    "%s PROBE FAILURE\n\n" ..
                                    "The probe did not make contact within %.3f inches.\n\n" ..
                                    "Possible causes:\n" ..
                                    "• Boss is smaller than minimum radius (%.3f\")\n" ..
                                    "• Probe not positioned over boss\n" ..
                                    "• Probe cable disconnected\n\n" ..
                                    "The probe sequence has stopped.",
                                    dir.name, maxTravel or 0.5, minRadius)
                                
                                wx.wxMessageBox(msg, "Probe Failure", wx.wxOK + wx.wxICON_ERROR)
                                error(string.format("%s probe failed", dir.name))
                            end
                            
                            -- Log the probe trigger
                            local logX = mc.mcAxisGetPos(inst, mc.X_AXIS)
                            local logY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
                            local logZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                            
                            if dir.name == "+X" or dir.name == "-X" then
                                logX = edgeWork
                            else
                                logY = edgeWork
                            end
                            
                            LogProbeEvent(dir.probe, logX, logY, logZ)
                            
                            -- Store BOTH machine and work coordinates
                            if dir.name == "+X" then
                                probeMachinePoints.xPlus = edgeMachine
                                probeWorkPoints.xPlus = edgeWork
                            elseif dir.name == "-X" then
                                probeMachinePoints.xMinus = edgeMachine
                                probeWorkPoints.xMinus = edgeWork
                            elseif dir.name == "+Y" then
                                probeMachinePoints.yPlus = edgeMachine
                                probeWorkPoints.yPlus = edgeWork
                            else
                                probeMachinePoints.yMinus = edgeMachine
                                probeWorkPoints.yMinus = edgeWork
                            end
                            
                            -- Record successful probe
                            table.insert(probeProgress.completed, dir.name)
                        end
                        
                        -- 4. Always return to safe plane using MACHINE coordinates
                        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Z%.4f", safePlaneMachZ))
                    end
                    
                    if not centerSuccess then
                        -- Record what failed and what succeeded
                        probeProgress.failed = dir.name
                        
                        local completedStr = "None"
                        if #probeProgress.completed > 0 then
                            completedStr = table.concat(probeProgress.completed, ", ")
                        end
                        
                        local msg = string.format(
                            "PROBE SEQUENCE ABORTED\n\n" ..
                            "Failed at: %s\n" ..
                            "Successfully completed: %s\n\n" ..
                            "NO DATUM HAS BEEN SET.\n" ..
                            "Machine stopped at current position.",
                            dir.name, completedStr)
                        
                        wx.wxMessageBox(msg, "Probe Sequence Aborted", wx.wxOK + wx.wxICON_ERROR)
                        error(string.format("Probe sequence aborted at %s - no datum set", dir.name))
                    end
                end
                
                -- ============================================
                -- PHASE 3: CALCULATE CENTER AND DIAMETERS (using ProbeLib)
                -- ============================================
                local centerMachX = ProbeLib.Calculations.GetCenter(probeMachinePoints.xPlus, probeMachinePoints.xMinus)
                local centerMachY = ProbeLib.Calculations.GetCenter(probeMachinePoints.yPlus, probeMachinePoints.yMinus)
                local centerWorkX = ProbeLib.Calculations.GetCenter(probeWorkPoints.xPlus, probeWorkPoints.xMinus)
                local centerWorkY = ProbeLib.Calculations.GetCenter(probeWorkPoints.yPlus, probeWorkPoints.yMinus)
                
                -- Calculate diameters
                local measuredDiamX = ProbeLib.Calculations.GetWidth(probeWorkPoints.xPlus, probeWorkPoints.xMinus)
                local measuredDiamY = ProbeLib.Calculations.GetWidth(probeWorkPoints.yPlus, probeWorkPoints.yMinus)
                
                -- Validate diameters are non-zero
                if math.abs(measuredDiamX) <= WIDTH_TOLERANCE then
                    local msg = "INVALID X MEASUREMENT\n\n" ..
                                "Both X probes contacted at the same point.\n" ..
                                "Measured width: ~0.0000\"\n\n" ..
                                "Possible causes:\n" ..
                                "• Probe is not over the boss\n" ..
                                "• Boss is missing or misaligned\n" ..
                                "• Minimum radius too large"
                    wx.wxMessageBox(msg, "Measurement Error", wx.wxOK + wx.wxICON_ERROR)
                    error("Invalid X measurement - probe hit same point")
                end
                
                if math.abs(measuredDiamY) <= WIDTH_TOLERANCE then
                    local msg = "INVALID Y MEASUREMENT\n\n" ..
                                "Both Y probes contacted at the same point.\n" ..
                                "Measured width: ~0.0000\"\n\n" ..
                                "Possible causes:\n" ..
                                "• Probe is not over the boss\n" ..
                                "• Boss is missing or misaligned\n" ..
                                "• Minimum radius too large"
                    wx.wxMessageBox(msg, "Measurement Error", wx.wxOK + wx.wxICON_ERROR)
                    error("Invalid Y measurement - probe hit same point")
                end
                
                -- ============================================
                -- PHASE 4: PERPENDICULARITY COMPENSATION
                -- ============================================
                -- Check if X measurement might be skewed (diameter ratio <= 95%)
                -- FIX: Changed < to <= for boundary case handling
                -- FIX: Added single re-probe limit flag
                local perpReprobePerformed = false
                
                if not ProbeLib.Calculations.CheckPerpendicularity(measuredDiamX, measuredDiamY, PERPENDICULARITY_RATIO) and not perpReprobePerformed then
                    mc.mcCntlSetLastError(inst, string.format("Perpendicularity check: X=%.4f <= Y=%.4f*0.95, re-probing X from Y center", 
                                                             measuredDiamX, measuredDiamY))
                    
                    -- Set flag to prevent multiple re-probe attempts
                    perpReprobePerformed = true
                    
                    -- Move to Y center at safe height using MACHINE coordinates
                    mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Y%.4f", centerMachY))
                    
                    -- Re-probe X axis from Y center
                    local xRecheckDirs = {
                        {name = "+X-Recheck", x = 1, y = 0, probe = "S2 M311", axis = mc.X_AXIS},
                        {name = "-X-Recheck", x = -1, y = 0, probe = "S1 M311", axis = mc.X_AXIS}
                    }
                    
                    for _, dir in ipairs(xRecheckDirs) do
                        local currentRadius = minRadius
                        local recheckSuccess = false
                        
                        while not recheckSuccess and currentRadius <= maxRadius do
                            -- Check soft limits
                            local currentMachPos = mc.mcAxisGetMachinePos(inst, dir.axis)
                            local maxSafeTravel = ProbeLib.Movement.GetMaxSafeTravel(inst, dir.axis, dir.x)
                            
                            if maxSafeTravel < currentRadius then
                                -- Can't reach, use original measurement
                                mc.mcCntlSetLastError(inst, string.format("%s limited by soft limits, keeping original", dir.name))
                                recheckSuccess = true  -- Skip this recheck
                                break
                            end
                            
                            -- Move to radius position using MACHINE coordinates
                            local targetMachX = centerMachX + (dir.x * currentRadius)
                            local targetMachY = centerMachY
                            local moveCmd = string.format("G53 G0 X%.4f Y%.4f", targetMachX, targetMachY)
                            mc.mcCntlGcodeExecuteWait(inst, moveCmd)
                            
                            -- Drop Z with collision detection
                            local zProbeCmd = string.format("G53 G31.1 Z%.4f F%.1f", probePlaneMachZ, fastFeed)
                            mc.mcCntlGcodeExecuteWait(inst, zProbeCmd)
                            
                            -- Check if we hit something during Z drop
                            local actualMachZ = mc.mcAxisGetMachinePos(inst, mc.Z_AXIS)
                            if math.abs(actualMachZ - probePlaneMachZ) > POSITION_TOLERANCE then
                                -- Hit something
                                LogProbeEvent("G31.1-Z", 
                                    mc.mcAxisGetPos(inst, mc.X_AXIS),
                                    mc.mcAxisGetPos(inst, mc.Y_AXIS),
                                    mc.mcAxisGetPos(inst, mc.Z_AXIS))
                                
                                -- Return to safe height
                                mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Z%.4f", safePlaneMachZ))
                                
                                -- Calculate next radius
                                local remainingDist = maxRadius - currentRadius
                                local retreat = ProbeLib.Movement.SmartRetreatSlice(maxTravel, remainingDist)
                                currentRadius = currentRadius + retreat
                                
                                if currentRadius > maxRadius then
                                    -- Use original measurement
                                    recheckSuccess = true
                                    break
                                end
                            else
                                -- Z drop successful, proceed with probe
                                recheckSuccess = true
                                
                                -- Enable sentinel mode
                                mc.mcCntlSetPoundVar(inst, 388, 1)
                                mc.mcCntlSetPoundVar(inst, 389, SENTINEL_VALUE)
                                mc.mcCntlSetPoundVar(inst, 390, SENTINEL_VALUE)
                                mc.mcCntlSetPoundVar(inst, 391, SENTINEL_VALUE)
                                mc.mcCntlSetPoundVar(inst, 392, SENTINEL_VALUE)
                                
                                -- Probe inward
                                local rc = mc.mcCntlGcodeExecuteWait(inst, dir.probe)
                                
                                -- Clear sentinel mode
                                mc.mcCntlSetPoundVar(inst, 388, 0)
                                
                                -- Check for failure
                                local edgeMachine = mc.mcCntlGetPoundVar(inst, 389)
                                local edgeWork = mc.mcCntlGetPoundVar(inst, 391)
                                
                                if edgeMachine ~= SENTINEL_VALUE then
                                    -- Update X probe points with new measurements
                                    if dir.name == "+X-Recheck" then
                                        probeMachinePoints.xPlus = edgeMachine
                                        probeWorkPoints.xPlus = edgeWork
                                    else
                                        probeMachinePoints.xMinus = edgeMachine
                                        probeWorkPoints.xMinus = edgeWork
                                    end
                                    
                                    LogProbeEvent(dir.probe, edgeWork, centerWorkY, mc.mcAxisGetPos(inst, mc.Z_AXIS))
                                end
                            end
                            
                            -- Return to safe Z
                            mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 Z%.4f", safePlaneMachZ))
                        end
                    end
                    
                    -- Recalculate with new X measurements (using ProbeLib)
                    centerMachX = ProbeLib.Calculations.GetCenter(probeMachinePoints.xPlus, probeMachinePoints.xMinus)
                    centerWorkX = ProbeLib.Calculations.GetCenter(probeWorkPoints.xPlus, probeWorkPoints.xMinus)
                    measuredDiamX = ProbeLib.Calculations.GetWidth(probeWorkPoints.xPlus, probeWorkPoints.xMinus)
                end
                
                mc.mcCntlSetLastError(inst, string.format("Boss diameter: X=%.4f Y=%.4f", 
                                                         measuredDiamX, measuredDiamY))
                
                -- ============================================
                -- PHASE 5: MOVE TO CENTER
                -- ============================================
                -- Move to measured center using MACHINE coordinates
                mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f Y%.4f", centerMachX, centerMachY))
                
                -- ============================================
                -- PHASE 6: SET DATUM OR PRINT
                -- ============================================
                if actionSel == 1 then  -- Set Datum
                    -- Get current work offset
                    local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
                    local currentOffset = 54  -- Default G54
                    if type(modalOffset) == "number" and modalOffset >= 54 and modalOffset <= 59 then
                        currentOffset = math.floor(modalOffset + 0.5)
                    end
                    
                    -- Work offset variable mapping
                    local workOffsetVars = {
                        [54] = {x = 5221, y = 5222, z = 5223},  -- G54
                        [55] = {x = 5241, y = 5242, z = 5243},  -- G55
                        [56] = {x = 5261, y = 5262, z = 5263},  -- G56
                        [57] = {x = 5281, y = 5282, z = 5283},  -- G57
                        [58] = {x = 5301, y = 5302, z = 5303},  -- G58
                        [59] = {x = 5321, y = 5322, z = 5323}   -- G59
                    }
                    
                    local offsets = workOffsetVars[currentOffset]
                    if offsets then
                        -- Prepare coordinates for library function
                        local offsetP = currentOffset - 53  -- G54=P1, G55=P2, etc.
                        local coords = {x = centerMachX, y = centerMachY}
                        
                        if performZProbe and surfaceMachZ then
                            -- Use TRUE surface from #394 if available (H-compensated)
                            local trueSurfaceZ = mc.mcCntlGetPoundVar(inst, 394)
                            
                            if type(trueSurfaceZ) == "number" and trueSurfaceZ > -1e300 then
                                -- M311 provided H-compensated surface
                                coords.z = trueSurfaceZ
                            else
                                -- Fallback: calculate compensation here
                                local currentTool = mc.mcToolGetCurrent(inst)
                                local currentH = mc.mcCntlGetPoundVar(inst, 4120)
                                local hOffset = 0
                                
                                -- Only apply H compensation if T90 with H90 is active
                                if currentTool == 90 and currentH == 90 then
                                    hOffset = mc.mcToolGetData(inst, mc.MTOOL_MILL_HEIGHT, 90)
                                    if type(hOffset) ~= "number" then hOffset = 0 end
                                end
                                coords.z = surfaceMachZ - hOffset
                            end
                        end
                        
                        ProbeLib.Core.ApplyOrPrint(inst, 1, coords, offsetP)
                        
                        -- Activate the work offset
                        local gcode = string.format("G%d", currentOffset)
                        mc.mcCntlGcodeExecuteWait(inst, gcode)
                        
                        if performZProbe and surfaceMachZ then
                            mc.mcCntlSetLastError(inst, string.format("Boss center set as %s X0 Y0 Z0", gcode))
                        else
                            mc.mcCntlSetLastError(inst, string.format("Boss center set as %s X0 Y0", gcode))
                        end
                        
                        datumWasSet = true
                    else
                        local msg = string.format(
                            "INVALID WORK OFFSET\n\n" ..
                            "Current work offset (G%d) is not valid.\n\n" ..
                            "Please select a valid work offset (G54-G59)\n" ..
                            "before running the probe routine.",
                            currentOffset or 0)
                        wx.wxMessageBox(msg, "Configuration Error", wx.wxOK + wx.wxICON_ERROR)
                        error("Invalid work offset")
                    end
                else  -- Print Coords
                    if performZProbe and surfaceWorkZ then
                        mc.mcCntlSetLastError(inst, string.format("Boss center: X%.4f Y%.4f, Top: Z%.4f", 
                                                                 centerWorkX, centerWorkY, surfaceWorkZ))
                    else
                        mc.mcCntlSetLastError(inst, string.format("Boss center: X%.4f Y%.4f", 
                                                                 centerWorkX, centerWorkY))
                    end
                end
                
                success = true
            end,
            debug.traceback  -- Get full stack trace on error
        )
        
        if not ok then
            errorMsg = tostring(err)
            success = false
        end
        
        -- ============================================
        -- CLEANUP - ALWAYS RUNS
        -- ============================================
        local cleanupOk, cleanupErr = xpcall(
            function()
                ProbeCleanup()
            end,
            debug.traceback
        )
        
        if not cleanupOk then
            -- Emergency cleanup failed - try minimal restoration
            pcall(function()
                mc.mcCntlSetPoundVar(inst, 388, 0)  -- Clear sentinel mode
                for var, value in pairs(savedPoundVars) do
                    if type(value) == "number" then
                        mc.mcCntlSetPoundVar(inst, var, value)
                    end
                end
            end)
            
            mc.mcCntlSetLastError(inst, "ERROR: Cleanup failed - " .. tostring(cleanupErr))
        end
        
        return success
    end
    
    -- Execute with error handling
    local success, result = pcall(ExecuteBossProbe)
    
    if not success then
        mc.mcCntlSetLastError(inst, "ERROR: " .. tostring(result))
        wx.wxMessageBox("Probe sequence failed:\n" .. tostring(result), 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
    elseif result == false then
        -- Probe failed with proper cleanup
        -- Message already set by cleanup function
    else
        -- Success - message already set by probe function
    end
else
    dlg:Destroy()
end