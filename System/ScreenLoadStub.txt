-- ScreenLoad GUI stub (silent unless error; lazy logging on failure only)
local ROOT = [[C:\Mach4Hobby\Profiles\BLP\Scripts]]
local SYS  = ROOT .. [[\System]]

local SRC = SYS .. [[\ScreenLoad.txt]]


-- One-time cache for this stub
local SL = rawget(_G, "__SL_STUB") or { log_path = nil }
_G.__SL_STUB = SL


local function now() return os.date("%Y-%m-%d %H:%M:%S") end


local function downloads_dir()
local up = os.getenv("USERPROFILE"); if up and #up > 0 then return (up .. "\\Downloads") end
local pub = os.getenv("PUBLIC"); if pub and #pub > 0 then return (pub .. "\\Downloads") end
return ROOT
end


local function ensure_log()
if SL.log_path then return SL.log_path end
local stamp = os.date("%Y-%m-%d_%H-%M-%S")
SL.log_path = (downloads_dir() .. "\\Mach4_ScreenLoad_Errors_" .. stamp .. ".txt"):gsub("/", "\\")
local ok, f = pcall(io.open, SL.log_path, "w")
if ok and f then
f:write(("==== ScreenLoad Stub Errors @ %s ====\r\nROOT=%s\r\nSYS=%s\r\nSRC=%s\r\n"):format(now(), ROOT, SYS, SRC))
f:flush(); f:close()
else
SL.log_path = nil
end
return SL.log_path
end


local function slog(...)
local path = ensure_log(); if not path then return end
local ok, f = pcall(io.open, path, "a"); if not ok or not f then return end
for i = 1, select("#", ...) do f:write(tostring(select(i, ...))) end
f:write("\r\n"); f:flush(); f:close()
end


local function errh(e)
return ("%s\n%s"):format(tostring(e), debug.traceback("", 2))
end


-- Expose a reload helper for a dev button
function _G.Reload_ScreenLoad()
local chunk, lerr = loadfile(SRC)
if not chunk then
slog(("!! %s LOAD ERROR: %s"):format(now(), tostring(lerr)))
error(lerr)
end
local ok, perr = xpcall(chunk, errh)
if not ok then
slog(("!! %s RUNTIME ERROR:\r\n%s"):format(now(), perr))
error(perr)
end
end


-- Initial run (silent on success)
local ok, perr = pcall(_G.Reload_ScreenLoad)
if not ok then
  -- get a handle inline so we never depend on a later 'inst'
  pcall(mc.mcCntlSetLastError, mc.mcGetInstance(), "ScreenLoad error (see log)")
end
