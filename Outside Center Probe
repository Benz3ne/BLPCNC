-- Outside Center Probe - Button Left-Down Script for Mach4
-- Version 2.0 - CORRECTED work offset mapping and spindle offset direction
--
-- Required Pound Variables:
-- #301 = X offset from spindle center to probe tip
-- #302 = Y offset from spindle center to probe tip  
-- #303 = Fast feedrate for probing
-- #304 = Slow feedrate for final probe
-- #305 = Maximum probe travel distance
-- #391 = M311 output: Edge position (adjusted for probe radius)
--
-- Required Macro:
-- m311.mcs must exist in your profile's Macros folder
-- IMPORTANT: M311 must have corrected probe radius compensation

local inst = mc.mcGetInstance()
if not inst then 
    return 
end

-- Helper functions for profile storage
local function ProfileGetInt(section, key, default)
    local strValue = mc.mcProfileGetString(inst, section, key, tostring(default))
    return tonumber(strValue) or default
end

local function ProfileGetFloat(section, key, default)
    local strValue = mc.mcProfileGetString(inst, section, key, tostring(default))
    return tonumber(strValue) or default
end

local function ProfileSetInt(section, key, value)
    return mc.mcProfileWriteString(inst, section, key, tostring(value))
end

local function ProfileSetFloat(section, key, value)
    return mc.mcProfileWriteString(inst, section, key, tostring(value))
end

-- Load saved settings
local lastAxisMode = ProfileGetInt("OutsideCenter", "AxisMode", 3)  -- 1=X, 2=Y, 3=Both
local lastPlusXMin = ProfileGetFloat("OutsideCenter", "PlusXMin", 0.5)
local lastMinusXMin = ProfileGetFloat("OutsideCenter", "MinusXMin", 0.5)
local lastPlusYMin = ProfileGetFloat("OutsideCenter", "PlusYMin", 0.5)
local lastMinusYMin = ProfileGetFloat("OutsideCenter", "MinusYMin", 0.5)
local lastTolerance = ProfileGetFloat("OutsideCenter", "Tolerance", 1.0)
local lastZDrop = ProfileGetFloat("OutsideCenter", "ZDrop", 0.5)
local lastAction = ProfileGetInt("OutsideCenter", "ActionMode", 1)
local lastOffset = ProfileGetInt("OutsideCenter", "OffsetMode", 1)
local lastAutoCenter = ProfileGetInt("OutsideCenter", "AutoCenter", 0)

-- Declare saved value variables BEFORE any usage
local savedPlusX = lastPlusXMin
local savedMinusX = lastMinusXMin
local savedPlusY = lastPlusYMin
local savedMinusY = lastMinusYMin

-- Declare UI elements that will be used in functions
local xCenterRangeText, yCenterRangeText

-- Determine parent window
local parent = wx.NULL
local app = wx.wxGetApp()
if app then
    local ok, top = pcall(function() return app:GetTopWindow() end)
    if ok and top then parent = top end
end

-- Dialog dimensions
local dlgW, dlgH = 560, 520
local sw = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_X) or 1024
local sh = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_Y) or 768
local posX = math.floor((sw - dlgW) / 2)
local posY = math.floor((sh - dlgH) / 2)

-- Create main dialog
local dlg = wx.wxDialog(parent, wx.wxID_ANY,
    "Outside Center Probe Setup",
    wx.wxPoint(posX, posY), wx.wxSize(dlgW, dlgH),
    wx.wxDEFAULT_DIALOG_STYLE)

-- Main panel
local panel = wx.wxPanel(dlg, wx.wxID_ANY)
local mainSizer = wx.wxBoxSizer(wx.wxVERTICAL)

-- Instructions text (no box, just text at top)
local instructText = wx.wxStaticText(panel, wx.wxID_ANY,
    "Position the probe above the rectangular feature before starting:\n" ..
    "â€¢ Probe will move outward, descend, then probe inward")
instructText:SetFont(wx.wxFont(9, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_NORMAL, wx.wxFONTWEIGHT_NORMAL))
mainSizer:Add(instructText, 0, wx.wxALL, 10)

-- Axis selection
local axisBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Axis Selection")
local axisChoices = {"X Axis Only", "Y Axis Only", "Both Axes"}
local axisRadio = wx.wxRadioBox(panel, wx.wxID_ANY,
    "Probe Axes", wx.wxDefaultPosition, wx.wxDefaultSize,
    axisChoices, 3, wx.wxRA_SPECIFY_COLS)
axisRadio:SetSelection(lastAxisMode - 1)
axisBox:Add(axisRadio, 0, wx.wxEXPAND + wx.wxALL, 5)
mainSizer:Add(axisBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Distance parameters section
local paramBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Distance Parameters")
local paramSizer = wx.wxBoxSizer(wx.wxVERTICAL)

-- Auto-center checkbox
local autoCenterCheck = wx.wxCheckBox(panel, wx.wxID_ANY, "Start From Center Mode (enter total width/height)")
autoCenterCheck:SetValue(lastAutoCenter == 1)
paramSizer:Add(autoCenterCheck, 0, wx.wxALL, 5)

-- Note about distances
local noteText = wx.wxStaticText(panel, wx.wxID_ANY, 
    "Min distances: starting search distance from current position")
noteText:SetFont(wx.wxFont(8, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_ITALIC, wx.wxFONTWEIGHT_NORMAL))
paramSizer:Add(noteText, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM, 5)

-- X axis inputs on one line
local xSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)

local minusXLabel = wx.wxStaticText(panel, wx.wxID_ANY, "-X Travel:")
xSizer:Add(minusXLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxRIGHT, 5)
local minusXInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastMinusXMin),
                                 wx.wxDefaultPosition, wx.wxSize(70, -1))
minusXInput:SetToolTip("Minimum distance to move in -X")
xSizer:Add(minusXInput, 0, wx.wxRIGHT, 10)

local plusXLabel = wx.wxStaticText(panel, wx.wxID_ANY, "+X Travel:")
xSizer:Add(plusXLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxRIGHT, 5)
local plusXInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastPlusXMin), 
                                wx.wxDefaultPosition, wx.wxSize(70, -1))
plusXInput:SetToolTip("Minimum distance to move in +X")
xSizer:Add(plusXInput, 0, wx.wxRIGHT, 10)

paramSizer:Add(xSizer, 0, wx.wxEXPAND + wx.wxALL, 5)

-- X range display (below the inputs)
local xMaxText = wx.wxStaticText(panel, wx.wxID_ANY, "")
xMaxText:SetForegroundColour(wx.wxColour(64, 64, 64))
xMaxText:SetFont(wx.wxFont(8, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_ITALIC, wx.wxFONTWEIGHT_NORMAL))
paramSizer:Add(xMaxText, 0, wx.wxLEFT + wx.wxRIGHT, 10)

-- X width input for center mode (initially hidden)
local xWidthSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
local xWidthLabel = wx.wxStaticText(panel, wx.wxID_ANY, "X Width:")
xWidthSizer:Add(xWidthLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxRIGHT, 5)
local xWidthInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastPlusXMin + lastMinusXMin),
                                 wx.wxDefaultPosition, wx.wxSize(100, -1))
xWidthInput:SetToolTip("Total width of the feature in X")
xWidthSizer:Add(xWidthInput, 0, wx.wxRIGHT, 10)
xWidthSizer:AddStretchSpacer()  -- Push content to the left

-- Initially hide the width sizer
xWidthLabel:Hide()
xWidthInput:Hide()

paramSizer:Add(xWidthSizer, 0, wx.wxEXPAND + wx.wxALL, 5)

-- X range display for center mode (below the width input)
xCenterRangeText = wx.wxStaticText(panel, wx.wxID_ANY, "")
xCenterRangeText:SetForegroundColour(wx.wxColour(64, 64, 64))
xCenterRangeText:SetFont(wx.wxFont(8, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_ITALIC, wx.wxFONTWEIGHT_NORMAL))
xCenterRangeText:Hide()
paramSizer:Add(xCenterRangeText, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM, 10)

-- Y axis inputs on one line
local ySizer = wx.wxBoxSizer(wx.wxHORIZONTAL)

local minusYLabel = wx.wxStaticText(panel, wx.wxID_ANY, "-Y Travel:")
ySizer:Add(minusYLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxRIGHT, 5)
local minusYInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastMinusYMin),
                                 wx.wxDefaultPosition, wx.wxSize(70, -1))
minusYInput:SetToolTip("Minimum distance to move in -Y")
ySizer:Add(minusYInput, 0, wx.wxRIGHT, 10)

local plusYLabel = wx.wxStaticText(panel, wx.wxID_ANY, "+Y Travel:")
ySizer:Add(plusYLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxRIGHT, 5)
local plusYInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastPlusYMin),
                                wx.wxDefaultPosition, wx.wxSize(70, -1))
plusYInput:SetToolTip("Minimum distance to move in +Y")
ySizer:Add(plusYInput, 0, wx.wxRIGHT, 10)

paramSizer:Add(ySizer, 0, wx.wxEXPAND + wx.wxALL, 5)

-- Y range display (below the inputs)
local yMaxText = wx.wxStaticText(panel, wx.wxID_ANY, "")
yMaxText:SetForegroundColour(wx.wxColour(64, 64, 64))
yMaxText:SetFont(wx.wxFont(8, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_ITALIC, wx.wxFONTWEIGHT_NORMAL))
paramSizer:Add(yMaxText, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM, 10)

-- Y height input for center mode (initially hidden)
local yHeightSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
local yHeightLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Y Height:")
yHeightSizer:Add(yHeightLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxRIGHT, 5)
local yHeightInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastPlusYMin + lastMinusYMin),
                                  wx.wxDefaultPosition, wx.wxSize(100, -1))
yHeightInput:SetToolTip("Total height of the feature in Y")
yHeightSizer:Add(yHeightInput, 0, wx.wxRIGHT, 10)
yHeightSizer:AddStretchSpacer()  -- Push content to the left

-- Initially hide the height sizer
yHeightLabel:Hide()
yHeightInput:Hide()

paramSizer:Add(yHeightSizer, 0, wx.wxEXPAND + wx.wxALL, 5)

-- Y range display for center mode (below the height input)
yCenterRangeText = wx.wxStaticText(panel, wx.wxID_ANY, "")
yCenterRangeText:SetForegroundColour(wx.wxColour(64, 64, 64))
yCenterRangeText:SetFont(wx.wxFont(8, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_ITALIC, wx.wxFONTWEIGHT_NORMAL))
yCenterRangeText:Hide()
paramSizer:Add(yCenterRangeText, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM, 10)

-- Offset and Z drop in separate grid
local commonGrid = wx.wxFlexGridSizer(2, 2, 5, 10)

-- Offset input
local offsetLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Offset:")
local offsetInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastTolerance))
offsetInput:SetToolTip("Added to all min distances to get max search distance")
commonGrid:Add(offsetLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
commonGrid:Add(offsetInput, 0, wx.wxEXPAND)

-- Z drop input
local dropLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Z Drop:")
local dropInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastZDrop))
dropInput:SetToolTip("How far to descend before probing")
commonGrid:Add(dropLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
commonGrid:Add(dropInput, 0, wx.wxEXPAND)

commonGrid:AddGrowableCol(1)
paramSizer:Add(commonGrid, 0, wx.wxEXPAND + wx.wxALL, 5)

paramBox:Add(paramSizer, 0, wx.wxEXPAND + wx.wxALL, 0)
mainSizer:Add(paramBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Options section - Action and Datum side by side
local optionsBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Probe Options")
local optionsSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)

-- Action on the left
local actionChoices = {"Set Datum", "Print Coords"}
local actionRadio = wx.wxRadioBox(panel, wx.wxID_ANY,
    "Action", wx.wxDefaultPosition, wx.wxDefaultSize,
    actionChoices, 2, wx.wxRA_SPECIFY_COLS)
actionRadio:SetSelection(lastAction - 1)
optionsSizer:Add(actionRadio, 1, wx.wxEXPAND + wx.wxRIGHT, 10)

-- Datum position on the right
local datumChoices = {"Probe", "Spindle"}
local datumRadio = wx.wxRadioBox(panel, wx.wxID_ANY,
    "Datum Position", wx.wxDefaultPosition, wx.wxDefaultSize,
    datumChoices, 2, wx.wxRA_SPECIFY_COLS)
datumRadio:SetSelection(lastOffset - 1)
optionsSizer:Add(datumRadio, 1, wx.wxEXPAND)

optionsBox:Add(optionsSizer, 0, wx.wxEXPAND + wx.wxALL, 5)
mainSizer:Add(optionsBox, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM + wx.wxEXPAND, 10)

-- Define functions before using them in event connections

-- Function to update max distance display
local function UpdateMaxDisplay()
    local offset = tonumber(offsetInput:GetValue()) or 0
    
    if autoCenterCheck:GetValue() then
        -- Auto-center mode - show ranges from center
        local xWidth = tonumber(xWidthInput:GetValue()) or 0
        local yHeight = tonumber(yHeightInput:GetValue()) or 0
        local axisSel = axisRadio:GetSelection() + 1
        
        -- Update X range for center mode
        if (axisSel == 1 or axisSel == 3) and xWidth > 0 and offset > 0 then
            local halfX = xWidth / 2
            xCenterRangeText:SetLabel(string.format("X Range: Â±%.3f to Â±%.3f from center", 
                                   halfX, halfX + offset))
        else
            xCenterRangeText:SetLabel("")
        end
        
        -- Update Y range for center mode
        if (axisSel == 2 or axisSel == 3) and yHeight > 0 and offset > 0 then
            local halfY = yHeight / 2
            yCenterRangeText:SetLabel(string.format("Y Range: Â±%.3f to Â±%.3f from center", 
                                               halfY, halfY + offset))
        else
            yCenterRangeText:SetLabel("")
        end
        
        xMaxText:SetLabel("")  -- Clear individual displays
        yMaxText:SetLabel("")
    else
        -- Normal mode - clear center mode displays
        xCenterRangeText:SetLabel("")
        yCenterRangeText:SetLabel("")
        
        -- Show individual ranges
        local plusXMin = tonumber(plusXInput:GetValue()) or 0
        local minusXMin = tonumber(minusXInput:GetValue()) or 0
        if plusXMin >= 0 and minusXMin >= 0 and offset > 0 then
            xMaxText:SetLabel(string.format("Range: Â±X %.3f-%.3f, Â±X %.3f-%.3f", 
                             plusXMin, plusXMin + offset,
                             minusXMin, minusXMin + offset))
        else
            xMaxText:SetLabel("")
        end
        
        local plusYMin = tonumber(plusYInput:GetValue()) or 0
        local minusYMin = tonumber(minusYInput:GetValue()) or 0
        if plusYMin >= 0 and minusYMin >= 0 and offset > 0 then
            yMaxText:SetLabel(string.format("Range: Â±Y %.3f-%.3f, Â±Y %.3f-%.3f", 
                             plusYMin, plusYMin + offset,
                             minusYMin, minusYMin + offset))
        else
            yMaxText:SetLabel("")
        end
    end
end

-- Function to update visibility based on axis selection
local function UpdateVisibility()
    local axisSel = axisRadio:GetSelection() + 1
    local isAutoCenter = autoCenterCheck:GetValue()
    
    -- Show/hide X inputs
    local showX = (axisSel == 1 or axisSel == 3)
    
    -- Individual mode controls
    minusXLabel:Show(showX and not isAutoCenter)
    minusXInput:Show(showX and not isAutoCenter)
    plusXLabel:Show(showX and not isAutoCenter)
    plusXInput:Show(showX and not isAutoCenter)
    xMaxText:Show(showX and not isAutoCenter)  -- Show range below inputs in individual mode
    
    -- Center mode controls
    xWidthLabel:Show(showX and isAutoCenter)
    xWidthInput:Show(showX and isAutoCenter)
    xCenterRangeText:Show(showX and isAutoCenter)  -- Show X range for center mode
    
    -- Show/hide Y inputs
    local showY = (axisSel == 2 or axisSel == 3)
    
    -- Individual mode controls
    minusYLabel:Show(showY and not isAutoCenter)
    minusYInput:Show(showY and not isAutoCenter)
    plusYLabel:Show(showY and not isAutoCenter)
    plusYInput:Show(showY and not isAutoCenter)
    yMaxText:Show(showY and not isAutoCenter)  -- Show range below inputs in individual mode
    
    -- Center mode controls
    yHeightLabel:Show(showY and isAutoCenter)
    yHeightInput:Show(showY and isAutoCenter)
    yCenterRangeText:Show(showY and isAutoCenter)  -- Show Y range for center mode
    
    -- Update max displays
    UpdateMaxDisplay()
    
    -- Refresh layout
    panel:Layout()
    dlg:Fit()
end

-- Function to handle auto-center mode
local function UpdateAutoCenter()
    local isChecked = autoCenterCheck:GetValue()
    
    if isChecked then
        -- Save current individual values before hiding
        savedPlusX = tonumber(plusXInput:GetValue()) or 0
        savedMinusX = tonumber(minusXInput:GetValue()) or 0
        savedPlusY = tonumber(plusYInput:GetValue()) or 0
        savedMinusY = tonumber(minusYInput:GetValue()) or 0
        
        -- Update width/height fields with totals
        xWidthInput:SetValue(string.format("%.4f", savedPlusX + savedMinusX))
        yHeightInput:SetValue(string.format("%.4f", savedPlusY + savedMinusY))
    else
        -- Restore individual values when unchecking
        if savedPlusX and savedMinusX and savedPlusY and savedMinusY then
            plusXInput:SetValue(string.format("%.4f", savedPlusX))
            minusXInput:SetValue(string.format("%.4f", savedMinusX))
            plusYInput:SetValue(string.format("%.4f", savedPlusY))
            minusYInput:SetValue(string.format("%.4f", savedMinusY))
        else
            -- Fallback: split width/height evenly if no saved values
            local xWidth = tonumber(xWidthInput:GetValue()) or 0
            local yHeight = tonumber(yHeightInput:GetValue()) or 0
            
            plusXInput:SetValue(string.format("%.4f", xWidth / 2))
            minusXInput:SetValue(string.format("%.4f", xWidth / 2))
            plusYInput:SetValue(string.format("%.4f", yHeight / 2))
            minusYInput:SetValue(string.format("%.4f", yHeight / 2))
        end
    end
    
    UpdateVisibility()
end

-- If auto-center was previously checked, set up the UI accordingly
if lastAutoCenter == 1 then
    -- Width/height fields already have the correct values from initialization
    local axisSel = axisRadio:GetSelection() + 1
    local showX = (axisSel == 1 or axisSel == 3)
    local showY = (axisSel == 2 or axisSel == 3)
    
    -- Hide the individual fields
    minusXLabel:Hide()
    minusXInput:Hide()
    plusXLabel:Hide()
    plusXInput:Hide()
    minusYLabel:Hide()
    minusYInput:Hide()
    plusYLabel:Hide()
    plusYInput:Hide()
    xMaxText:Hide()
    yMaxText:Hide()
    
    -- Show the width/height fields based on axis selection
    xWidthLabel:Show(showX)
    xWidthInput:Show(showX)
    xCenterRangeText:Show(showX)
    yHeightLabel:Show(showY)
    yHeightInput:Show(showY)
    yCenterRangeText:Show(showY)
end

-- Connect events
axisRadio:Connect(wx.wxEVT_COMMAND_RADIOBOX_SELECTED, UpdateVisibility)
plusXInput:Connect(wx.wxEVT_COMMAND_TEXT_UPDATED, UpdateMaxDisplay)
minusXInput:Connect(wx.wxEVT_COMMAND_TEXT_UPDATED, UpdateMaxDisplay)
plusYInput:Connect(wx.wxEVT_COMMAND_TEXT_UPDATED, UpdateMaxDisplay)
minusYInput:Connect(wx.wxEVT_COMMAND_TEXT_UPDATED, UpdateMaxDisplay)
xWidthInput:Connect(wx.wxEVT_COMMAND_TEXT_UPDATED, UpdateMaxDisplay)
yHeightInput:Connect(wx.wxEVT_COMMAND_TEXT_UPDATED, UpdateMaxDisplay)
offsetInput:Connect(wx.wxEVT_COMMAND_TEXT_UPDATED, UpdateMaxDisplay)
autoCenterCheck:Connect(wx.wxEVT_COMMAND_CHECKBOX_CLICKED, UpdateAutoCenter)

-- Initial visibility update
UpdateVisibility()
UpdateMaxDisplay()

-- Spacer - Add fixed size spacer instead of stretch spacer to prevent button squishing
mainSizer:Add(0, 20, 0, wx.wxEXPAND)

-- Buttons
local buttonSizer = wx.wxStdDialogButtonSizer()
local okBtn = wx.wxButton(panel, wx.wxID_OK, "OK")
local cancelBtn = wx.wxButton(panel, wx.wxID_CANCEL, "Cancel")

okBtn:SetMinSize(wx.wxSize(90, 28))
cancelBtn:SetMinSize(wx.wxSize(90, 28))

buttonSizer:AddButton(okBtn)
buttonSizer:AddButton(cancelBtn)
buttonSizer:Realize()

mainSizer:Add(buttonSizer, 0, wx.wxALL + wx.wxALIGN_CENTER, 8)

-- Apply layout
panel:SetSizer(mainSizer)
mainSizer:Fit(panel)
dlg:Fit()
dlg:Centre()

-- Show dialog
if dlg:ShowModal() == wx.wxID_OK then
    -- Get values
    local axisSel = axisRadio:GetSelection() + 1
    local isAutoCenter = autoCenterCheck:GetValue()  -- CAPTURE THIS BEFORE DESTROYING DIALOG
    local offset = tonumber(offsetInput:GetValue())
    local zDrop = tonumber(dropInput:GetValue())
    local offsetSel = datumRadio:GetSelection() + 1
    local actionSel = actionRadio:GetSelection() + 1
    
    -- Handle auto-center mode
    local plusXMin, minusXMin, plusYMin, minusYMin
    
    if isAutoCenter then
        -- In auto-center mode, the input is total width/height
        local xWidth = tonumber(xWidthInput:GetValue()) or 0
        local yHeight = tonumber(yHeightInput:GetValue()) or 0
        plusXMin = xWidth / 2
        minusXMin = xWidth / 2
        plusYMin = yHeight / 2
        minusYMin = yHeight / 2
    else
        -- Normal mode - read all values
        plusXMin = tonumber(plusXInput:GetValue())
        minusXMin = tonumber(minusXInput:GetValue())
        plusYMin = tonumber(plusYInput:GetValue())
        minusYMin = tonumber(minusYInput:GetValue())
    end
    
    -- Validate inputs based on axis selection
    if axisSel == 1 or axisSel == 3 then  -- X or Both
        if not plusXMin or plusXMin < 0 then
            wx.wxMessageBox("Invalid +X minimum distance", "Input Error", wx.wxOK + wx.wxICON_ERROR)
            dlg:Destroy()
            return
        end
        if not minusXMin or minusXMin < 0 then
            wx.wxMessageBox("Invalid -X minimum distance", "Input Error", wx.wxOK + wx.wxICON_ERROR)
            dlg:Destroy()
            return
        end
    end
    
    if axisSel == 2 or axisSel == 3 then  -- Y or Both
        if not plusYMin or plusYMin < 0 then
            wx.wxMessageBox("Invalid +Y minimum distance", "Input Error", wx.wxOK + wx.wxICON_ERROR)
            dlg:Destroy()
            return
        end
        if not minusYMin or minusYMin < 0 then
            wx.wxMessageBox("Invalid -Y minimum distance", "Input Error", wx.wxOK + wx.wxICON_ERROR)
            dlg:Destroy()
            return
        end
    end
    
    if not offset or offset <= 0 then
        wx.wxMessageBox("Invalid offset value", "Input Error", wx.wxOK + wx.wxICON_ERROR)
        dlg:Destroy()
        return
    end
    
    if not zDrop or zDrop <= 0 then
        wx.wxMessageBox("Invalid Z drop value", "Input Error", wx.wxOK + wx.wxICON_ERROR)
        dlg:Destroy()
        return
    end
    
    -- Save settings
    ProfileSetInt("OutsideCenter", "AxisMode", axisSel)
    ProfileSetInt("OutsideCenter", "AutoCenter", isAutoCenter and 1 or 0)
    
    -- Always save the actual min values (not the converted width/height)
    if savedPlusX and savedMinusX and savedPlusY and savedMinusY and isAutoCenter then
        -- If in auto-center mode, save the stored individual values
        ProfileSetFloat("OutsideCenter", "PlusXMin", savedPlusX)
        ProfileSetFloat("OutsideCenter", "MinusXMin", savedMinusX)
        ProfileSetFloat("OutsideCenter", "PlusYMin", savedPlusY)
        ProfileSetFloat("OutsideCenter", "MinusYMin", savedMinusY)
    else
        -- Otherwise save the current values
        ProfileSetFloat("OutsideCenter", "PlusXMin", plusXMin or 0.5)
        ProfileSetFloat("OutsideCenter", "MinusXMin", minusXMin or 0.5)
        ProfileSetFloat("OutsideCenter", "PlusYMin", plusYMin or 0.5)
        ProfileSetFloat("OutsideCenter", "MinusYMin", minusYMin or 0.5)
    end
    
    ProfileSetFloat("OutsideCenter", "Tolerance", offset)  -- Keep as Tolerance for backward compatibility
    ProfileSetFloat("OutsideCenter", "ZDrop", zDrop)
    ProfileSetInt("OutsideCenter", "OffsetMode", offsetSel)
    ProfileSetInt("OutsideCenter", "ActionMode", actionSel)
    
    dlg:Destroy()
    
    -- Execute probe sequence
    local function ExecuteOutsideCenterProbe()
        -- Check if probe is already triggered
        if mc.mcSignalGetState(inst, mc.ISIG_PROBE) == 1 then
            wx.wxMessageBox("Probe is already triggered!", "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        
        -- Initialize probe log
        local profileName = mc.mcProfileGetName(inst)
        local probeLogPath = mc.mcCntlGetMachDir(inst) .. "\\Profiles\\" .. profileName .. "\\ProbeLog.csv"
        local logFile = io.open(probeLogPath, "a")
        if logFile then
            -- Write header if file is new/empty
            local fileSize = logFile:seek("end")
            if fileSize == 0 then
                logFile:write("Timestamp,Method,X,Y,Z\n")
            end
            logFile:close()
        end
        
        -- Helper function to log probe events
        local function LogProbeEvent(method, x, y, z)
            local ok, err = pcall(function()
                local logFile = io.open(probeLogPath, "a")
                if logFile then
                    local timestamp = os.date("%Y-%m-%d %H:%M:%S")
                    local logEntry = string.format("%s,%s,%.4f,%.4f,%.4f\n",
                        timestamp, method, x, y, z)
                    logFile:write(logEntry)
                    logFile:close()
                end
            end)
            -- Silent fail on logging errors - don't interrupt probe operation
        end
        
        -- Get probe parameters from pound variables
        local xProbeOffset = mc.mcCntlGetPoundVar(inst, 301)
        local yProbeOffset = mc.mcCntlGetPoundVar(inst, 302)
        local fastFeed = mc.mcCntlGetPoundVar(inst, 303)
        local slowFeed = mc.mcCntlGetPoundVar(inst, 304)
        local maxTravel = mc.mcCntlGetPoundVar(inst, 305)
        
        -- Validate and set defaults
        if type(xProbeOffset) ~= "number" then xProbeOffset = 0 end
        if type(yProbeOffset) ~= "number" then yProbeOffset = 0 end
        if type(fastFeed) ~= "number" or fastFeed <= 0 then fastFeed = 30 end
        if type(slowFeed) ~= "number" or slowFeed <= 0 then slowFeed = 5 end
        if type(maxTravel) ~= "number" or maxTravel <= 0 then maxTravel = 1.0 end
        
        -- Check for uninitialized pound variables
        if xProbeOffset < -1e300 or yProbeOffset < -1e300 or fastFeed < -1e300 or 
           slowFeed < -1e300 or maxTravel < -1e300 then
            mc.mcCntlSetLastError(inst, "ERROR: Probe parameters not initialized. Set #301-305")
            wx.wxMessageBox("Probe parameters not initialized!\n\nPlease set pound variables:\n" ..
                          "#301 = X offset\n#302 = Y offset\n#303 = Fast feed\n" ..
                          "#304 = Slow feed\n#305 = Max travel", 
                          "Configuration Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        
        -- Calculate step increment (90% of max probe travel)
        local stepIncrement = maxTravel * 0.9
        
        -- Store starting position
        local startX = mc.mcAxisGetPos(inst, mc.X_AXIS)
        local startY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        local startZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
        
        -- Show initial status with mode info
        local modeStr = isAutoCenter and "Start From Center" or "Individual distances"
        mc.mcCntlSetLastError(inst, string.format("Outside center probe starting (%s mode)", modeStr))
        
        -- Store probe results
        local probePoints = {}
        
        -- Define probe directions based on axis selection
        local directions = {}
        
        if axisSel == 1 or axisSel == 3 then  -- X or Both
            table.insert(directions, {name = "+X", x = 1, y = 0, probe = "S2 M311",  -- Move +X, probe -X inward
                                    minDist = plusXMin, maxDist = plusXMin + offset})
            table.insert(directions, {name = "-X", x = -1, y = 0, probe = "S1 M311",  -- Move -X, probe +X inward
                                    minDist = minusXMin, maxDist = minusXMin + offset})
        end
        
        if axisSel == 2 or axisSel == 3 then  -- Y or Both
            table.insert(directions, {name = "+Y", x = 0, y = 1, probe = "S4 M311",  -- Move +Y, probe -Y inward
                                    minDist = plusYMin, maxDist = plusYMin + offset})
            table.insert(directions, {name = "-Y", x = 0, y = -1, probe = "S3 M311",  -- Move -Y, probe +Y inward
                                    minDist = minusYMin, maxDist = minusYMin + offset})
        end
        
        -- Probe each direction
        for i, dir in ipairs(directions) do
            local currentDist = dir.minDist
            local success = false
            
            -- For Y-axis probes, start from X center if we already have X measurements
            local probeStartX = startX
            local probeStartY = startY
            
            if (dir.name == "+Y" or dir.name == "-Y") and probePoints.xPlus and probePoints.xMinus then
                -- We've already probed X, so center on X for Y probes
                probeStartX = (probePoints.xPlus + probePoints.xMinus) / 2.0
                -- Move to X center at safe height
                mc.mcCntlGcodeExecuteWait(inst, string.format("G0 X%.4f", probeStartX))
            elseif (dir.name == "+X" or dir.name == "-X") and probePoints.yPlus and probePoints.yMinus then
                -- If probing X after Y, center on Y
                probeStartY = (probePoints.yPlus + probePoints.yMinus) / 2.0
                mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Y%.4f", probeStartY))
            end
            
            while not success and currentDist <= dir.maxDist do
                -- 1. Move to distance position (RAPID)
                local targetX = probeStartX + (dir.x * currentDist)
                local targetY = probeStartY + (dir.y * currentDist)
                local moveCmd = string.format("G0 X%.4f Y%.4f", targetX, targetY)
                mc.mcCntlGcodeExecuteWait(inst, moveCmd)
                
                -- 2. Drop Z with collision detection
                local targetZ = startZ - zDrop
                local zProbeCmd = string.format("G31.1 Z%.4f F%.1f", targetZ, fastFeed)
                mc.mcCntlGcodeExecuteWait(inst, zProbeCmd)
                
                -- Check if we hit something during Z drop
                local actualZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                if math.abs(actualZ - targetZ) > 0.001 then
                    -- Hit something - log the Z collision
                    LogProbeEvent("G31.1-Z", 
                        mc.mcAxisGetPos(inst, mc.X_AXIS),
                        mc.mcAxisGetPos(inst, mc.Y_AXIS),
                        actualZ)
                    
                    -- Return to safe height
                    mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                    
                    -- Calculate next distance
                    local nextDist = currentDist + stepIncrement
                    
                    -- If step would exceed max, just go to max
                    if nextDist > dir.maxDist and currentDist < dir.maxDist then
                        currentDist = dir.maxDist
                    else
                        currentDist = nextDist
                    end
                    
                    -- Check if we've exceeded max distance
                    if currentDist > dir.maxDist then
                        mc.mcCntlSetLastError(inst, string.format("ERROR: Exceeded max distance at %s", dir.name))
                        return false
                    end
                else
                    -- Z drop successful, proceed with probe
                    success = true
                    
                    -- 3. Probe inward
                    local rc = mc.mcCntlGcodeExecuteWait(inst, dir.probe)
                    
                    if rc ~= mc.MERROR_NOERROR then
                        mc.mcCntlSetLastError(inst, string.format("ERROR: %s probe failed with code: %s", 
                                                                 dir.name, tostring(rc)))
                        -- Return to safe position
                        mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                        return false
                    end
                    
                    -- Get edge position from M311 (already adjusted for probe radius)
                    local edge = mc.mcCntlGetPoundVar(inst, 391)
                    if type(edge) ~= "number" or edge < -1e300 then
                        mc.mcCntlSetLastError(inst, string.format("ERROR: %s probe no contact", dir.name))
                        mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                        return false
                    end
                    
                    -- Log the probe trigger at edge position
                    local logX = mc.mcAxisGetPos(inst, mc.X_AXIS)
                    local logY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
                    local logZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                    
                    -- For the probed axis, use the edge position
                    if dir.name == "+X" or dir.name == "-X" then
                        logX = edge
                    else
                        logY = edge
                    end
                    
                    LogProbeEvent(dir.probe, logX, logY, logZ)
                    
                    -- Store the edge position
                    if dir.name == "+X" then
                        probePoints.xPlus = edge
                    elseif dir.name == "-X" then
                        probePoints.xMinus = edge
                    elseif dir.name == "+Y" then
                        probePoints.yPlus = edge
                    else
                        probePoints.yMinus = edge
                    end
                end
                
                -- 4. Always return to safe Z before next position
                mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
            end
            
            if not success then
                mc.mcCntlSetLastError(inst, string.format("ERROR: Unable to probe %s within distance range", dir.name))
                return false
            end
        end
        
        -- 5. Calculate center based on what was probed
        local centerX, centerY
        local widthX, widthY
        
        if probePoints.xPlus and probePoints.xMinus then
            centerX = (probePoints.xPlus + probePoints.xMinus) / 2.0
            widthX = probePoints.xPlus - probePoints.xMinus
        else
            centerX = startX  -- Keep original X if not probed
        end
        
        if probePoints.yPlus and probePoints.yMinus then
            centerY = (probePoints.yPlus + probePoints.yMinus) / 2.0
            widthY = probePoints.yPlus - probePoints.yMinus
        else
            centerY = startY  -- Keep original Y if not probed
        end
        
        -- Final dimension report
        local dimMsg = "Rectangle dimensions:"
        if widthX then dimMsg = dimMsg .. string.format(" X=%.4f", widthX) end
        if widthY then dimMsg = dimMsg .. string.format(" Y=%.4f", widthY) end
        mc.mcCntlSetLastError(inst, dimMsg)
        
        -- 6. Move PROBE to measured center (only axes that were probed)
        local moveCmd = "G0"
        if probePoints.xPlus and probePoints.xMinus then
            moveCmd = moveCmd .. string.format(" X%.4f", centerX)
        end
        if probePoints.yPlus and probePoints.yMinus then
            moveCmd = moveCmd .. string.format(" Y%.4f", centerY)
        end
        if moveCmd ~= "G0" then
            mc.mcCntlGcodeExecuteWait(inst, moveCmd)
        end
        
        -- 7. Set datum or print results
        if actionSel == 1 then  -- Set Datum
            -- Get current work offset
            local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
            local currentOffset = 54  -- Default G54
            if type(modalOffset) == "number" and modalOffset >= 54 and modalOffset <= 59 then
                currentOffset = math.floor(modalOffset + 0.5)
            end
            
            -- CORRECTED Work offset variable mapping (verified by tests)
            local workOffsetVars = {
                [54] = {x = 5221, y = 5222, z = 5223},  -- G54 CORRECT
                [55] = {x = 5241, y = 5242, z = 5243},  -- G55 CORRECT
                [56] = {x = 5261, y = 5262, z = 5263},  -- G56 CORRECT
                [57] = {x = 5281, y = 5282, z = 5283},  -- G57 CORRECT
                [58] = {x = 5301, y = 5302, z = 5303},  -- G58 CORRECT
                [59] = {x = 5321, y = 5322, z = 5323}   -- G59 CORRECT
            }
            
            local offsets = workOffsetVars[currentOffset]
            if offsets then
                -- Get ACTUAL machine position where we want work zero to be
                local centerMachX = nil
                local centerMachY = nil
                
                -- Only set machine coordinates for axes that were probed
                if probePoints.xPlus and probePoints.xMinus then
                    centerMachX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
                    -- If spindle offset is selected, adjust for spindle position
                    -- Probe offset is FROM spindle TO probe, so subtract to get spindle position
                    if offsetSel == 2 then
                        centerMachX = centerMachX - xProbeOffset
                    end
                end
                
                if probePoints.yPlus and probePoints.yMinus then
                    centerMachY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
                    -- If spindle offset is selected, adjust for spindle position
                    -- Probe offset is FROM spindle TO probe, so subtract to get spindle position
                    if offsetSel == 2 then
                        centerMachY = centerMachY - yProbeOffset
                    end
                end
                
                -- Set new work offset values for probed axes only
                if centerMachX then
                    mc.mcCntlSetPoundVar(inst, offsets.x, centerMachX)
                end
                if centerMachY then
                    mc.mcCntlSetPoundVar(inst, offsets.y, centerMachY)
                end
                
                -- Keep the Z offset unchanged
                local currentZOffset = mc.mcCntlGetPoundVar(inst, offsets.z)
                mc.mcCntlSetPoundVar(inst, offsets.z, currentZOffset)
                
                -- Force work offset update by executing G10 L2
                local offsetP = currentOffset - 53  -- G54=P1, G55=P2, etc.
                local g10Command = string.format("G10 L2 P%d", offsetP)
                
                if centerMachX then
                    g10Command = g10Command .. string.format(" X%.4f", centerMachX)
                end
                if centerMachY then
                    g10Command = g10Command .. string.format(" Y%.4f", centerMachY)
                end
                
                mc.mcCntlGcodeExecuteWait(inst, g10Command)
                
                -- Now activate the work offset
                local gcode = string.format("G%d", currentOffset)
                mc.mcCntlGcodeExecuteWait(inst, gcode)
                
                -- Report what was set
                local setMsg = string.format("Rectangle center set as %s", gcode)
                if centerMachX and centerMachY then
                    setMsg = setMsg .. " X0 Y0"
                elseif centerMachX then
                    setMsg = setMsg .. " X0"
                elseif centerMachY then
                    setMsg = setMsg .. " Y0"
                end
                mc.mcCntlSetLastError(inst, setMsg)
            else
                mc.mcCntlSetLastError(inst, "ERROR: Invalid work offset")
            end
        else  -- Print Coords
            -- For printing, get the actual machine position
            local machX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
            local machY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
            
            -- Build coordinate message based on what was probed
            local coordMsg = "Rectangle center (machine):"
            
            if probePoints.xPlus and probePoints.xMinus then
                local displayX = machX
                if offsetSel == 2 then  -- Adjust for spindle if needed
                    displayX = machX - xProbeOffset
                end
                coordMsg = coordMsg .. string.format(" X%.4f", displayX)
            end
            
            if probePoints.yPlus and probePoints.yMinus then
                local displayY = machY
                if offsetSel == 2 then  -- Adjust for spindle if needed
                    displayY = machY - yProbeOffset
                end
                coordMsg = coordMsg .. string.format(" Y%.4f", displayY)
            end
            
            mc.mcCntlSetLastError(inst, coordMsg)
        end
        
        return true
    end
    
    -- Execute with error handling
    local success, result = pcall(ExecuteOutsideCenterProbe)
    
    if not success then
        mc.mcCntlSetLastError(inst, "ERROR: " .. tostring(result))
        wx.wxMessageBox("Probe sequence failed:\n" .. tostring(result), 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
    elseif result == false then
        wx.wxMessageBox("Probe sequence failed!\n\nCheck status bar for details.", 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
    else
        mc.mcCntlSetLastError(inst, "Outside center probe completed successfully")
    end
else
    dlg:Destroy()
end
