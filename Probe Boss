-- Probe Boss - Button Left-Down Script for Mach4

-- Required Pound Variables:
-- #301 = X offset from spindle center to probe tip
-- #302 = Y offset from spindle center to probe tip  
-- #303 = Fast feedrate for probing
-- #304 = Slow feedrate for final probe
-- #305 = Maximum probe travel distance
-- #391 = M311 output: Edge position (adjusted for probe radius)
--
-- Required Macro:
-- m311.mcs must exist in your profile's Macros folder

local inst = mc.mcGetInstance()
if not inst then 
    return 
end

-- Helper functions for profile storage
local function ProfileGetInt(section, key, default)
    local strValue = mc.mcProfileGetString(inst, section, key, tostring(default))
    return tonumber(strValue) or default
end

local function ProfileGetFloat(section, key, default)
    local strValue = mc.mcProfileGetString(inst, section, key, tostring(default))
    return tonumber(strValue) or default
end

local function ProfileSetInt(section, key, value)
    return mc.mcProfileWriteString(inst, section, key, tostring(value))
end

local function ProfileSetFloat(section, key, value)
    return mc.mcProfileWriteString(inst, section, key, tostring(value))
end

-- Load saved settings
local lastMinRadius = ProfileGetFloat("BossProbe", "MinRadius", 0.5)
local lastMaxRadius = ProfileGetFloat("BossProbe", "MaxRadius", 2.0)
local lastZDrop = ProfileGetFloat("BossProbe", "ZDrop", 0.5)
local lastAction = ProfileGetInt("BossProbe", "ActionMode", 1)
local lastOffset = ProfileGetInt("BossProbe", "OffsetMode", 1)

-- Determine parent window
local parent = wx.NULL
local app = wx.wxGetApp()
if app then
    local ok, top = pcall(function() return app:GetTopWindow() end)
    if ok and top then parent = top end
end

-- Dialog dimensions
local dlgW, dlgH = 340, 380
local sw = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_X) or 1024
local sh = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_Y) or 768
local posX = math.floor((sw - dlgW) / 2)
local posY = math.floor((sh - dlgH) / 2)

-- Create main dialog
local dlg = wx.wxDialog(parent, wx.wxID_ANY,
    "Boss Probe Setup",
    wx.wxPoint(posX, posY), wx.wxSize(dlgW, dlgH),
    wx.wxDEFAULT_DIALOG_STYLE)

-- Main panel
local panel = wx.wxPanel(dlg, wx.wxID_ANY)
local mainSizer = wx.wxBoxSizer(wx.wxVERTICAL)

-- Instructions text
local instructBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Starting Position")
local instructText = wx.wxStaticText(panel, wx.wxID_ANY,
    "Position the probe above the circular boss before starting:\n" ..
    "• Roughly centered over the boss\n" ..
    "• High enough to clear the top surface\n" ..
    "• Probe will move outward, descend, then probe inward")
instructText:SetFont(wx.wxFont(9, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_NORMAL, wx.wxFONTWEIGHT_NORMAL))
instructBox:Add(instructText, 0, wx.wxALL, 5)
mainSizer:Add(instructBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Boss parameters section
local paramBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Boss Parameters")
local paramGrid = wx.wxFlexGridSizer(3, 2, 5, 10)

-- Minimum radius input
local minRadiusLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Min Radius:")
local minRadiusInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastMinRadius))
minRadiusInput:SetToolTip("Starting radius for probe search")
paramGrid:Add(minRadiusLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
paramGrid:Add(minRadiusInput, 0, wx.wxEXPAND)

-- Maximum radius input
local maxRadiusLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Max Radius:")
local maxRadiusInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastMaxRadius))
maxRadiusInput:SetToolTip("Maximum radius before aborting")
paramGrid:Add(maxRadiusLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
paramGrid:Add(maxRadiusInput, 0, wx.wxEXPAND)

-- Z drop input
local dropLabel = wx.wxStaticText(panel, wx.wxID_ANY, "Z Drop:")
local dropInput = wx.wxTextCtrl(panel, wx.wxID_ANY, string.format("%.4f", lastZDrop))
dropInput:SetToolTip("How far to descend before probing")
paramGrid:Add(dropLabel, 0, wx.wxALIGN_CENTER_VERTICAL + wx.wxALIGN_RIGHT)
paramGrid:Add(dropInput, 0, wx.wxEXPAND)

paramGrid:AddGrowableCol(1)
paramBox:Add(paramGrid, 0, wx.wxEXPAND + wx.wxALL, 5)
mainSizer:Add(paramBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Options section
local optionsBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Probe Options")

-- Datum position
local datumChoices = {"Probe Position", "Spindle Center"}
local datumRadio = wx.wxRadioBox(panel, wx.wxID_ANY,
    "Datum Position", wx.wxDefaultPosition, wx.wxDefaultSize,
    datumChoices, 2, wx.wxRA_SPECIFY_COLS)
datumRadio:SetSelection(lastOffset - 1)
optionsBox:Add(datumRadio, 0, wx.wxEXPAND + wx.wxALL, 5)

-- Action
local actionChoices = {"Set Datum", "Print Coords"}
local actionRadio = wx.wxRadioBox(panel, wx.wxID_ANY,
    "Action", wx.wxDefaultPosition, wx.wxDefaultSize,
    actionChoices, 2, wx.wxRA_SPECIFY_COLS)
actionRadio:SetSelection(lastAction - 1)
optionsBox:Add(actionRadio, 0, wx.wxEXPAND + wx.wxALL, 5)

mainSizer:Add(optionsBox, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM + wx.wxEXPAND, 10)

-- Info text
local infoText = wx.wxStaticText(panel, wx.wxID_ANY, 
    "Position spindle above boss center before starting.\n" ..
    "Step increment = 90% of max probe travel (#305).\n" ..
    "Will search from min to max radius.")
infoText:SetForegroundColour(wx.wxColour(64, 64, 64))
mainSizer:Add(infoText, 0, wx.wxALL + wx.wxALIGN_CENTER, 10)

-- Spacer
mainSizer:AddStretchSpacer()

-- Buttons
local buttonSizer = wx.wxStdDialogButtonSizer()
local okBtn = wx.wxButton(panel, wx.wxID_OK, "OK")
local cancelBtn = wx.wxButton(panel, wx.wxID_CANCEL, "Cancel")

okBtn:SetMinSize(wx.wxSize(90, 28))
cancelBtn:SetMinSize(wx.wxSize(90, 28))

buttonSizer:AddButton(okBtn)
buttonSizer:AddButton(cancelBtn)
buttonSizer:Realize()

mainSizer:Add(buttonSizer, 0, wx.wxALL + wx.wxALIGN_CENTER, 8)

-- Apply layout
panel:SetSizer(mainSizer)
mainSizer:Fit(panel)
dlg:Fit()
dlg:Centre()

-- Show dialog
if dlg:ShowModal() == wx.wxID_OK then
    -- Get values
    local minRadius = tonumber(minRadiusInput:GetValue())
    local maxRadius = tonumber(maxRadiusInput:GetValue())
    local zDrop = tonumber(dropInput:GetValue())
    local offsetSel = datumRadio:GetSelection() + 1
    local actionSel = actionRadio:GetSelection() + 1
    
    -- Validate inputs
    if not minRadius or minRadius <= 0 then
        wx.wxMessageBox("Invalid minimum radius value", "Input Error", wx.wxOK + wx.wxICON_ERROR)
        dlg:Destroy()
        return
    end
    
    if not maxRadius or maxRadius <= minRadius then
        wx.wxMessageBox("Maximum radius must be greater than minimum radius", "Input Error", wx.wxOK + wx.wxICON_ERROR)
        dlg:Destroy()
        return
    end
    
    if not zDrop or zDrop <= 0 then
        wx.wxMessageBox("Invalid Z drop value", "Input Error", wx.wxOK + wx.wxICON_ERROR)
        dlg:Destroy()
        return
    end
    
    -- Save settings
    ProfileSetFloat("BossProbe", "MinRadius", minRadius)
    ProfileSetFloat("BossProbe", "MaxRadius", maxRadius)
    ProfileSetFloat("BossProbe", "ZDrop", zDrop)
    ProfileSetInt("BossProbe", "OffsetMode", offsetSel)
    ProfileSetInt("BossProbe", "ActionMode", actionSel)
    
    dlg:Destroy()
    
    -- Execute probe sequence
    local function ExecuteBossProbe()
        -- Check if probe is already triggered
        if mc.mcSignalGetState(inst, mc.ISIG_PROBE) == 1 then
            wx.wxMessageBox("Probe is already triggered!", "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        
        -- Initialize probe log
        local probeLogPath = mc.mcCntlGetMachDir(inst) .. "\\Profiles\\Mach4Hobby\\ProbeLog.csv"
        local logFile = io.open(probeLogPath, "a")
        if logFile then
            -- Write header if file is new/empty
            local fileSize = logFile:seek("end")
            if fileSize == 0 then
                logFile:write("Timestamp,Method,X,Y,Z\n")
            end
            logFile:close()
        end
        
        -- Helper function to log probe events
        local function LogProbeEvent(method, x, y, z)
            local logFile = io.open(probeLogPath, "a")
            if logFile then
                local timestamp = os.date("%Y-%m-%d %H:%M:%S")
                local logEntry = string.format("%s,%s,%.4f,%.4f,%.4f\n",
                    timestamp, method, x, y, z)
                logFile:write(logEntry)
                logFile:close()
            end
        end
        
        -- Get probe parameters from pound variables
        local xProbeOffset = mc.mcCntlGetPoundVar(inst, 301)
        local yProbeOffset = mc.mcCntlGetPoundVar(inst, 302)
        local fastFeed = mc.mcCntlGetPoundVar(inst, 303)
        local slowFeed = mc.mcCntlGetPoundVar(inst, 304)
        local maxTravel = mc.mcCntlGetPoundVar(inst, 305)
        
        -- Validate and set defaults
        if type(xProbeOffset) ~= "number" then xProbeOffset = 0 end
        if type(yProbeOffset) ~= "number" then yProbeOffset = 0 end
        if type(fastFeed) ~= "number" or fastFeed <= 0 then fastFeed = 30 end
        if type(slowFeed) ~= "number" or slowFeed <= 0 then slowFeed = 5 end
        if type(maxTravel) ~= "number" or maxTravel <= 0 then maxTravel = 1.0 end
        
        -- Calculate step increment (90% of max probe travel)
        local stepIncrement = maxTravel * 0.9
        
        -- Store starting position (should be above boss center)
        local startX = mc.mcAxisGetPos(inst, mc.X_AXIS)
        local startY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        local startZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
        
        -- Store probe results
        local probePoints = {}
        local successfulRadii = {}  -- Track successful radius for each direction
        
        -- Define probe sequence: move out, drop, probe in
        local directions = {
            {name = "+X", x = 1, y = 0, probe = "S2 M311"},   -- Probe -X (inward)
            {name = "-X", x = -1, y = 0, probe = "S1 M311"},  -- Probe +X (inward)
            {name = "+Y", x = 0, y = 1, probe = "S4 M311"},   -- Probe -Y (inward)
            {name = "-Y", x = 0, y = -1, probe = "S3 M311"}   -- Probe +Y (inward)
        }
        
        for i, dir in ipairs(directions) do
            local currentRadius = minRadius
            local success = false
            
            -- For Y-axis probes, start from X center if we already have X measurements
            local probeStartX = startX
            local probeStartY = startY
            
            if (dir.name == "+Y" or dir.name == "-Y") and probePoints.xPlus and probePoints.xMinus then
                -- We've already probed X, so center on X for Y probes
                probeStartX = (probePoints.xPlus + probePoints.xMinus) / 2.0
                -- Move to X center at safe height
                mc.mcCntlGcodeExecuteWait(inst, string.format("G0 X%.4f", probeStartX))
            end
            
            while not success and currentRadius <= maxRadius do
                -- 1. Move to radius position (RAPID)
                local targetX = probeStartX + (dir.x * currentRadius)
                local targetY = probeStartY + (dir.y * currentRadius)
                local moveCmd = string.format("G0 X%.4f Y%.4f", targetX, targetY)
                mc.mcCntlGcodeExecuteWait(inst, moveCmd)
                
                -- 2. Drop Z with collision detection
                local targetZ = startZ - zDrop
                local zProbeCmd = string.format("G31.1 Z%.4f F%.1f", targetZ, fastFeed)
                mc.mcCntlGcodeExecuteWait(inst, zProbeCmd)
                
                -- Check if we hit something during Z drop
                local actualZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                if math.abs(actualZ - targetZ) > 0.001 then
                    -- Hit something - log the Z collision
                    LogProbeEvent("G31.1-Z", 
                        mc.mcAxisGetPos(inst, mc.X_AXIS),
                        mc.mcAxisGetPos(inst, mc.Y_AXIS),
                        actualZ)
                    
                    -- Return to safe height
                    mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                    
                    -- Calculate next radius
                    local nextRadius = currentRadius + stepIncrement
                    
                    -- If step would exceed max, just go to max
                    if nextRadius > maxRadius and currentRadius < maxRadius then
                        currentRadius = maxRadius
                    else
                        currentRadius = nextRadius
                    end
                    
                    -- Check if we've exceeded max radius
                    if currentRadius > maxRadius then
                        mc.mcCntlSetLastError(inst, string.format("ERROR: Exceeded max radius at %s", dir.name))
                        return false
                    end
                else
                    -- Z drop successful, proceed with probe
                    success = true
                    successfulRadii[dir.name] = currentRadius
                    
                    -- 3. Probe inward
                    local rc = mc.mcCntlGcodeExecuteWait(inst, dir.probe)
                    
                    if rc ~= mc.MERROR_NOERROR then
                        mc.mcCntlSetLastError(inst, string.format("ERROR: %s probe failed with code: %s", 
                                                                 dir.name, tostring(rc)))
                        -- Return to safe position
                        mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                        return false
                    end
                    
                    -- Get edge position from M311 (already adjusted for probe radius)
                    local edge = mc.mcCntlGetPoundVar(inst, 391)
                    if type(edge) ~= "number" or edge < -1e300 then
                        mc.mcCntlSetLastError(inst, string.format("ERROR: %s probe no contact", dir.name))
                        mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                        return false
                    end
                    
                    -- Log the probe trigger at edge position
                    local logX = mc.mcAxisGetPos(inst, mc.X_AXIS)
                    local logY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
                    local logZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                    
                    -- For the probed axis, use the edge position
                    if dir.name == "+X" or dir.name == "-X" then
                        logX = edge
                    else
                        logY = edge
                    end
                    
                    LogProbeEvent(dir.probe, logX, logY, logZ)
                    
                    -- Store the edge position
                    if dir.name == "+X" then
                        probePoints.xPlus = edge
                    elseif dir.name == "-X" then
                        probePoints.xMinus = edge
                    elseif dir.name == "+Y" then
                        probePoints.yPlus = edge
                    else
                        probePoints.yMinus = edge
                    end
                end
                
                -- 4. Always return to safe Z before next position
                mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
            end
            
            if not success then
                mc.mcCntlSetLastError(inst, string.format("ERROR: Unable to probe %s within radius range", dir.name))
                return false
            end
        end
        
        -- 5. Calculate center and check for perpendicularity issue
        local centerX = (probePoints.xPlus + probePoints.xMinus) / 2.0
        local centerY = (probePoints.yPlus + probePoints.yMinus) / 2.0
        
        -- Calculate diameters
        local measuredDiamX = probePoints.xPlus - probePoints.xMinus
        local measuredDiamY = probePoints.yPlus - probePoints.yMinus
        
        -- Check if X measurement might be skewed (diameter ratio < 95%)
        if measuredDiamX < (measuredDiamY * 0.95) then
            -- Store original X measurements
            local originalXPlus = probePoints.xPlus
            local originalXMinus = probePoints.xMinus
            
            -- Move to Y center at safe height
            mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Y%.4f", centerY))
            
            -- Re-probe X axis from Y center
            local xDirections = {
                {name = "+X-Recheck", x = 1, y = 0, probe = "S2 M311"},
                {name = "-X-Recheck", x = -1, y = 0, probe = "S1 M311"}
            }
            
            for _, dir in ipairs(xDirections) do
                local currentRadius = minRadius
                local success = false
                
                while not success and currentRadius <= maxRadius do
                    -- Move to radius position
                    local targetX = centerX + (dir.x * currentRadius)  -- Use X center as starting point
                    local targetY = centerY  -- Stay at Y center
                    local moveCmd = string.format("G0 X%.4f Y%.4f", targetX, targetY)
                    mc.mcCntlGcodeExecuteWait(inst, moveCmd)
                    
                    -- Drop Z with collision detection
                    local targetZ = startZ - zDrop
                    local zProbeCmd = string.format("G31.1 Z%.4f F%.1f", targetZ, fastFeed)
                    mc.mcCntlGcodeExecuteWait(inst, zProbeCmd)
                    
                    -- Check if we hit something during Z drop
                    local actualZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
                    if math.abs(actualZ - targetZ) > 0.001 then
                        -- Hit something - log and retry
                        LogProbeEvent("G31.1-Z", 
                            mc.mcAxisGetPos(inst, mc.X_AXIS),
                            mc.mcAxisGetPos(inst, mc.Y_AXIS),
                            actualZ)
                        
                        -- Return to safe height
                        mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                        
                        -- Calculate next radius
                        local nextRadius = currentRadius + stepIncrement
                        if nextRadius > maxRadius and currentRadius < maxRadius then
                            currentRadius = maxRadius
                        else
                            currentRadius = nextRadius
                        end
                        
                        if currentRadius > maxRadius then
                            mc.mcCntlSetLastError(inst, string.format("ERROR: Exceeded max radius at %s", dir.name))
                            return false
                        end
                    else
                        -- Z drop successful, proceed with probe
                        success = true
                        
                        -- Probe inward
                        local rc = mc.mcCntlGcodeExecuteWait(inst, dir.probe)
                        
                        if rc ~= mc.MERROR_NOERROR then
                            mc.mcCntlSetLastError(inst, string.format("ERROR: %s probe failed", dir.name))
                            mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                            return false
                        end
                        
                        -- Get edge position
                        local edge = mc.mcCntlGetPoundVar(inst, 391)
                        if type(edge) ~= "number" or edge < -1e300 then
                            mc.mcCntlSetLastError(inst, string.format("ERROR: %s probe no contact", dir.name))
                            mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                            return false
                        end
                        
                        -- Log the probe
                        LogProbeEvent(dir.probe, edge, centerY, actualZ)
                        
                        -- Update X probe points with new measurements
                        if dir.name == "+X-Recheck" then
                            probePoints.xPlus = edge
                        else
                            probePoints.xMinus = edge
                        end
                    end
                    
                    -- Return to safe Z
                    mc.mcCntlGcodeExecuteWait(inst, string.format("G0 Z%.4f", startZ))
                end
            end
            
            -- Recalculate with new X measurements
            centerX = (probePoints.xPlus + probePoints.xMinus) / 2.0
            measuredDiamX = probePoints.xPlus - probePoints.xMinus
        end
        
        mc.mcCntlSetLastError(inst, string.format("Boss diameter: X=%.4f Y=%.4f", 
                                                  measuredDiamX, measuredDiamY))
        
        -- 6. Move PROBE to measured center
        mc.mcCntlGcodeExecuteWait(inst, string.format("G0 X%.4f Y%.4f", centerX, centerY))
        
        -- 7. Set datum or print results
        if actionSel == 1 then  -- Set Datum
            -- Get current work offset
            local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
            local currentOffset = 54  -- Default G54
            if type(modalOffset) == "number" and modalOffset >= 54 and modalOffset <= 59 then
                currentOffset = math.floor(modalOffset + 0.5)
            end
            
            -- CORRECTED Work offset variable mapping (verified by tests)
            local workOffsetVars = {
                [54] = {x = 5221, y = 5222, z = 5223},  -- G54 CORRECT
                [55] = {x = 5241, y = 5242, z = 5243},  -- G55 CORRECT
                [56] = {x = 5261, y = 5262, z = 5263},  -- G56 CORRECT
                [57] = {x = 5281, y = 5282, z = 5283},  -- G57 CORRECT
                [58] = {x = 5301, y = 5302, z = 5303},  -- G58 CORRECT
                [59] = {x = 5321, y = 5322, z = 5323}   -- G59 CORRECT
            }
            
            local offsets = workOffsetVars[currentOffset]
            if offsets then
                -- Get ACTUAL machine position where we want work zero to be
                local centerMachX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
                local centerMachY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
                
                -- If spindle offset is selected, adjust the machine position
                -- Probe offset is FROM spindle TO probe, so subtract to get spindle position
                if offsetSel == 2 then
                    centerMachX = centerMachX - xProbeOffset
                    centerMachY = centerMachY - yProbeOffset
                end
                
                -- Set new work offset values
                mc.mcCntlSetPoundVar(inst, offsets.x, centerMachX)
                mc.mcCntlSetPoundVar(inst, offsets.y, centerMachY)
                
                -- Keep the Z offset unchanged
                local currentZOffset = mc.mcCntlGetPoundVar(inst, offsets.z)
                mc.mcCntlSetPoundVar(inst, offsets.z, currentZOffset)
                
                -- Force work offset update by executing G10 L2
                -- G10 L2 P[offset] X[value] Y[value] sets work offset
                local offsetP = currentOffset - 53  -- G54=P1, G55=P2, etc.
                local g10Command = string.format("G10 L2 P%d X%.4f Y%.4f", 
                                               offsetP, centerMachX, centerMachY)
                mc.mcCntlGcodeExecuteWait(inst, g10Command)
                
                -- Now activate the work offset
                local gcode = string.format("G%d", currentOffset)
                mc.mcCntlGcodeExecuteWait(inst, gcode)
                
                mc.mcCntlSetLastError(inst, string.format("Boss center set as %s X0 Y0", gcode))
            else
                mc.mcCntlSetLastError(inst, "ERROR: Invalid work offset")
            end
        else  -- Print Coords
            -- For printing, get the actual machine position
            local machX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
            local machY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
            
            if offsetSel == 2 then  -- Adjust for spindle if needed
                -- Probe offset is FROM spindle TO probe, so subtract to get spindle position
                machX = machX + xProbeOffset
                machY = machY + yProbeOffset
            end
            
            mc.mcCntlSetLastError(inst, string.format("Boss center (machine): X%.4f Y%.4f", machX, machY))
        end
        
        return true
    end
    
    -- Execute with error handling
    local success, result = pcall(ExecuteBossProbe)
    
    if not success then
        mc.mcCntlSetLastError(inst, "ERROR: " .. tostring(result))
        wx.wxMessageBox("Probe sequence failed:\n" .. tostring(result), 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
    elseif result == false then
        wx.wxMessageBox("Probe sequence failed!\n\nCheck status bar for details.", 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
    else
        mc.mcCntlSetLastError(inst, "Boss probe completed successfully")
    end
else
    dlg:Destroy()
end
