--[[
Outputs_FullAutoDiag.txt  — one‑shot, self‑contained diagnostic
Goal: Do EVERYTHING automatically. No extra commands.

What it does (per device: dust/boot/vacRear/vacFront):
  1) Snapshot current OSIG + AUTO/TGT PVs.
  2) Freeze AuxLib’s writer (temporary wrapper) and force OFF → watch 1s →
     • If any comes back ON while frozen ⇒ EXTERNAL_REASSERT (plugin/hardware mapping)
  3) Unfreeze and test Aux logic deterministically (no guessing):
     • Manual path: AUTO=0; TGT=1 ⇒ expect ON; TGT=0 ⇒ expect OFF
     • Auto path:   AUTO=1; TGT=0 ⇒ observe what Aux drives (classify)
  4) Live “direct OSIG” test with Aux active: write 0, sample 200/1000ms ⇒ detect AUX_REASSERT.
  5) Restore all PVs and outputs to the pre‑test snapshot.
  6) Save a clean report here:
       C:\Mach4Hobby\Profiles\<Profile>\Reports\Outputs_FullAutoDiag-YYYYMMDD-HHMMSS.log
(Also mirrors key lines to the status bar.)

How to run: paste into the Lua editor (Operator ▸ Edit/Debug Scripts) and Run.
Or save in your Scripts folder and call via SystemLib.RunProfileScript.
]]

local mc = mc
local wx = require("wx")

-- ===== helpers ================================================================
local function profDir(inst) local mach=mc.mcCntlGetMachDir(inst); local ok,p=pcall(mc.mcProfileGetName,inst); return (mach.."\\Profiles\\"..(ok and p or "BLP")) end
local function utcStamp() local t=os.date("!*t"); return string.format("%04d%02d%02d-%02d%02d%02d",t.year,t.month,t.day,t.hour,t.min,t.sec) end
local function ensureDir(p) os.execute(string.format('if not exist "%s" mkdir "%s"', p, p)) end
local function sleep(ms) wx.wxMilliSleep(ms) end
local function nowhms() return os.date("%H:%M:%S") end

local function newLog(inst)
  local base = profDir(inst).."\\Reports"; ensureDir(base)
  local file = base.."\\Outputs_FullAutoDiag-"..utcStamp()..".log"
  local f = assert(io.open(file, "w"))
  local function log(fmt, ...)
    local s = (select('#',...)>0) and string.format(fmt, ...) or tostring(fmt)
    f:write(nowhms()," ",s,"\n"); f:flush(); mc.mcCntlSetLastError(inst, s)
  end
  return {file=file, log=log, close=function() f:close() end}
end

local function sigH(inst, id) local ok,h=pcall(mc.mcSignalGetHandle,inst,id); return ok and h or nil end
local function sigR(h) local ok,s=pcall(mc.mcSignalGetState,h); return ok and (s==1 and 1 or 0) or -1 end
local function sigW(h,v) pcall(mc.mcSignalSetState,h,(v and 1 or 0)) end
local function pvG(inst,n) local ok,v=pcall(mc.mcCntlGetPoundVar,inst,n); return ok and tonumber(v) or 0 end
local function pvS(inst,n,v) pcall(mc.mcCntlSetPoundVar,inst,n,tonumber(v) or 0) end

local DEV = {
  { key="dust",     name="Dust Collect", osig=mc.OSIG_OUTPUT4, autoPV=400, tgtPV=404 },
  { key="boot",     name="Dust Boot",    osig=mc.OSIG_OUTPUT3, autoPV=402, tgtPV=403 },
  { key="vacRear",  name="Vac Rear",     osig=mc.OSIG_OUTPUT5, autoPV=401, tgtPV=411 },
  { key="vacFront", name="Vac Front",    osig=mc.OSIG_OUTPUT6, autoPV=401, tgtPV=412 },
}

-- ===== temporary freeze wrapper around AuxLib.Update ==========================
local function installFreezeGate(inst, LOG)
  local AuxLib = rawget(_G, "AuxLib")
  if not AuxLib or type(AuxLib.Update) ~= "function" then
    LOG.log("WARNING: AuxLib.Update not found; freeze gate skipped")
    return {active=false}
  end
  local ORIG = AuxLib.Update
  local state = {active=true, orig=ORIG}
  AuxLib.Update = function(i,...)
    if pvG(i or inst, 4991) == 1 then return true end
    return ORIG(i or inst, ...)
  end
  LOG.log("Installed Aux freeze gate (#4991)")
  return state
end

local function removeFreezeGate(state)
  local AuxLib = rawget(_G, "AuxLib")
  if AuxLib and state and state.active and state.orig then AuxLib.Update = state.orig end
end

-- ===== main ==================================================================
local function run()
  local inst = mc.mcGetInstance(); if not inst then return end
  local LOG = newLog(inst)
  LOG.log("Outputs Full Auto Diagnostic start (Enabled=%d)", sigR(sigH(inst, mc.OSIG_MACHINE_ENABLED)))

  -- Temporarily force library logging/tracing on; restore at end
  local prevDbg = pvG(inst, 4990) or 0
  local prevTrc = pvG(inst, 4992) or 0
  pvS(inst, 4990, 1)
  pvS(inst, 4992, 1)
  LOG.log("Logging: prev #4990=%d #4992=%d -> forcing ON", prevDbg, prevTrc)

  -- install temporary freeze switch
  local gate = installFreezeGate(inst, LOG)

  -- snapshot
  local snap = {}
  for _,d in ipairs(DEV) do
    local h = sigH(inst, d.osig)
    snap[d.key] = { osig=sigR(h), auto=pvG(inst,d.autoPV), tgt=pvG(inst,d.tgtPV) }
  end
  LOG.log("SNAPSHOT:")
  for _,d in ipairs(DEV) do
    local s=snap[d.key]
    LOG.log("  %-8s OSIG=%d AUTO=%d TGT=%d", d.key, s.osig, s.auto, s.tgt)
  end

  -- TEST 1: Freeze Aux, force OFF, watch 1s → EXTERNAL?
  local freezePrior = pvG(inst, 4991)
  pvS(inst, 4991, 1)
  LOG.log("TEST1: Freeze Aux (#4991=1), force OFF, watch 1s…")
  for _,d in ipairs(DEV) do sigW(sigH(inst,d.osig), 0) end
  sleep(1000)
  local ext = {}
  for _,d in ipairs(DEV) do
    local s = sigR(sigH(inst,d.osig)); ext[d.key] = (s==1)
    LOG.log("  %-8s after1s=%d  %s", d.key, s, s==1 and "REASSERTED (EXTERNAL)" or "held-LOW")
  end

  -- TEST 2: Unfreeze; deterministic Aux checks
  pvS(inst, 4991, freezePrior) -- restore previous freeze state
  LOG.log("TEST2: Aux live; manual then auto checks")
  local auxVerdict = {}
  for _,d in ipairs(DEV) do
    local h = sigH(inst, d.osig)

    -- Manual expected behavior (AUTO=0)
    pvS(inst, d.autoPV, 0); pvS(inst, d.tgtPV, 1)
    if _G.AuxLib and _G.AuxLib.Update then _G.AuxLib.Update(inst) end
    sleep(50)
    local on1 = sigR(h)
    pvS(inst, d.tgtPV, 0)
    if _G.AuxLib and _G.AuxLib.Update then _G.AuxLib.Update(inst) end
    sleep(50)
    local on2 = sigR(h)

    local manualOK = (on1==1 and on2==0)

    -- Auto behavior (AUTO=1)
    pvS(inst, d.autoPV, 1); pvS(inst, d.tgtPV, 0)
    if _G.AuxLib and _G.AuxLib.Update then _G.AuxLib.Update(inst) end
    sleep(50)
    local autoOn = sigR(h)

    -- Direct OFF under Aux (should reveal Aux reassert)
    sigW(h, 0); sleep(200); local d200 = sigR(h); sleep(800); local d1000 = sigR(h)

    local verdict
    if ext[d.key] then verdict = "EXTERNAL_REASSERT (plugin/hardware)"
    elseif not manualOK then verdict = "AUX_MANUAL_PATH_BAD (check Request/PVs/rules)"
    elseif autoOn==1 and (d200==1 or d1000==1) then verdict = "AUX_REASSERT (auto driving ON)"
    else verdict = "OK (manual works; auto not forcing on)" end

    auxVerdict[d.key] = {manualOK=manualOK, autoOn=autoOn, d200=d200, d1000=d1000, verdict=verdict}

    LOG.log("  %-8s MANUAL: T1=%d T0=%d | AUTO=%d | DirectOFF +200=%d +1000=%d → %s",
      d.key, on1, on2, autoOn, d200, d1000, verdict)
  end

  -- RESTORE to snapshot
  LOG.log("RESTORE: returning PVs and outputs to snapshot…")
  for _,d in ipairs(DEV) do
    pvS(inst, d.autoPV, snap[d.key].auto)
    pvS(inst, d.tgtPV,  snap[d.key].tgt)
    sigW(sigH(inst,d.osig), snap[d.key].osig==1)
  end

  -- SUMMARY
  LOG.log("\n=== SUMMARY ===")
  for _,d in ipairs(DEV) do
    local e = ext[d.key] and "EXTERNAL_REASSERT" or "-"
    local a = auxVerdict[d.key]
    LOG.log("%-8s ext=%s  manualOK=%s  autoOn=%d  directOff(+1s)=%d  → %s",
      d.key, e, tostring(a.manualOK), a.autoOn, a.d1000, a.verdict)
  end

  LOG.log("\nReport: %s", LOG.file)
  -- Restore prior logging/tracing PVs
  pvS(inst, 4990, prevDbg or 0)
  pvS(inst, 4992, prevTrc or 0)
  LOG.log("Logging restored: #4990=%d #4992=%d", prevDbg, prevTrc)
  LOG.close()

  -- remove freeze gate wrapper
  removeFreezeGate(gate)
end

run()
