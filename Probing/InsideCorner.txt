-- Inside Corner Probe - M311 Implementation

-- Required Pound Variables:
-- #300 = Probe tip diameter
-- #303 = Fast feedrate for probing
-- #304 = Slow feedrate for final probe
-- #305 = Maximum probe travel distance
-- #391 = M311 output: Edge position (adjusted for probe radius)

-- Required Macro:
-- m311.mcs must exist in your profile's Macros folder

local inst = mc.mcGetInstance()
if not inst then 
    return 
end

-- ============================================
-- CONSTANTS FOR SENTINEL MODE AND SAFETY
-- ============================================
local SENTINEL_VALUE = -999999.0      -- Impossible machine position for failure detection
local PROBE_SIGNAL = mc.ISIG_PROBE1   -- Touch probe signal
local PROBE_SETTLE_MS = 100          -- Probe signal settle time

-- Check if T90 (probe) is active
local currentTool = mc.mcToolGetCurrent(inst)
-- Check if probe is physically deployed (output 7)
local probeDownHandle = mc.mcSignalGetHandle(inst, mc.OSIG_OUTPUT7)
local probeDeployed = mc.mcSignalGetState(probeDownHandle)

-- Check both conditions - T90 is current AND probe is deployed
if currentTool ~= 90 or probeDeployed ~= 1 then
    -- Determine parent window
    local parent = wx.NULL
    local app = wx.wxGetApp()
    if app then
        local ok, top = pcall(function() return app:GetTopWindow() end)
        if ok and top then parent = top end
    end
    
    -- Show error dialog
    local dlgW, dlgH = 340, 200
    local sw = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_X) or 1024
    local sh = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_Y) or 768
    local posX = math.floor((sw - dlgW) / 2)
    local posY = math.floor((sh - dlgH) / 2)
    
    local errorDlg = wx.wxDialog(parent, wx.wxID_ANY,
        "Probe Not Active",
        wx.wxPoint(posX, posY), wx.wxSize(dlgW, dlgH),
        wx.wxDEFAULT_DIALOG_STYLE)
    
    local panel = wx.wxPanel(errorDlg, wx.wxID_ANY)
    local sizer = wx.wxBoxSizer(wx.wxVERTICAL)
    
    -- Error message
    local msg = wx.wxStaticText(panel, wx.wxID_ANY,
        "Please activate T90 (probe) before using inside corner probe.\n\n" ..
        "Click 'Change Tool to T90' to activate the probe,\n" ..
        "or 'Cancel' to exit.")
    msg:SetFont(wx.wxFont(10, wx.wxFONTFAMILY_DEFAULT, wx.wxFONTSTYLE_NORMAL, wx.wxFONTWEIGHT_NORMAL))
    sizer:Add(msg, 1, wx.wxALL + wx.wxALIGN_CENTER, 20)
    
    -- Button sizer
    local btnSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
    
    -- Change Tool button
    local changeBtn = wx.wxButton(panel, wx.wxID_ANY, "Change Tool to T90")
    changeBtn:SetMinSize(wx.wxSize(130, 28))
    btnSizer:Add(changeBtn, 0, wx.wxRIGHT, 10)
    
    -- Cancel button
    local cancelBtn = wx.wxButton(panel, wx.wxID_CANCEL, "Cancel")
    cancelBtn:SetMinSize(wx.wxSize(90, 28))
    btnSizer:Add(cancelBtn, 0, wx.wxLEFT, 0)
    
    sizer:Add(btnSizer, 0, wx.wxALIGN_CENTER + wx.wxBOTTOM, 15)
    
    -- Handle Change Tool button
    changeBtn:Connect(wx.wxID_ANY, wx.wxEVT_COMMAND_BUTTON_CLICKED, function(event)
        errorDlg:EndModal(wx.wxID_YES)  -- Use YES as indicator to change tool
    end)
    
    panel:SetSizer(sizer)
    errorDlg:Centre()
    
    local result = errorDlg:ShowModal()
    errorDlg:Destroy()
    
    if result == wx.wxID_YES then
        -- Execute tool change and exit - user will need to click probe again
        mc.mcCntlGcodeExecuteWait(inst, "T90 M6")
        mc.mcCntlSetLastError(inst, "T90 activated - click Inside Corner Probe again to continue")
        return
    else
        return  -- User cancelled
    end
end

-- Helper function to safely read profile integers
local function ProfileGetInt(section, key, default)
    local strValue = mc.mcProfileGetString(inst, section, key, tostring(default))
    return tonumber(strValue) or default
end

-- Helper function to safely write profile integers
local function ProfileSetInt(section, key, value)
    return mc.mcProfileWriteString(inst, section, key, tostring(value))
end

-- ============================================
-- SENTINEL PROBE FUNCTION
-- ============================================
-- Executes M311 probe with reliable failure detection using sentinel mode
local function ExecuteSentinelProbe(probeCommand, directionName)
    -- ============================================
    -- PRE-PROBE COLLISION DETECTION
    -- ============================================
    -- Check if probe is already triggered before movement
    if mc.mcSignalGetState(inst, PROBE_SIGNAL) == 1 then
        local msg = string.format(
            "PROBE STUCK\n\n" ..
            "Probe is already triggered before %s movement.\n\n" ..
            "Possible causes:\n" ..
            "• Probe tip is touching something\n" ..
            "• Probe cable fault or short circuit\n" ..
            "• Probe needs to be reset\n\n" ..
            "Clear the probe and retry.", directionName)
        wx.wxMessageBox(msg, "Probe Stuck", wx.wxOK + wx.wxICON_ERROR)
        error(string.format("Probe stuck before %s movement", directionName))
    end
    
    -- Enable sentinel mode for M311 v1.4.0+
    mc.mcCntlSetPoundVar(inst, 388, 1)
    
    -- Set sentinel values before probe - these will remain unchanged if probe fails
    mc.mcCntlSetPoundVar(inst, 389, SENTINEL_VALUE)  -- Machine X result
    mc.mcCntlSetPoundVar(inst, 390, SENTINEL_VALUE)  -- Machine Y result  
    mc.mcCntlSetPoundVar(inst, 391, SENTINEL_VALUE)  -- Work coordinate result
    mc.mcCntlSetPoundVar(inst, 392, SENTINEL_VALUE)  -- Reserved
    
    -- Execute probe command
    local rc = mc.mcCntlGcodeExecuteWait(inst, probeCommand)
    
    -- Clear sentinel mode flag (M311 v1.4.0 does this but be explicit)
    mc.mcCntlSetPoundVar(inst, 388, 0)
    
    -- Check for probe failure using sentinel detection
    local resultMachine = mc.mcCntlGetPoundVar(inst, 389)  -- Machine coordinate
    local resultWork = mc.mcCntlGetPoundVar(inst, 391)     -- Work coordinate
    
    if resultMachine == SENTINEL_VALUE then
        -- Probe failed - sentinel value unchanged means no contact detected
        local maxTravel = mc.mcCntlGetPoundVar(inst, 305) or 0.5
        local msg = string.format(
            "%s PROBE FAILURE\n\n" ..
            "The probe did not make contact within %.3f inches.\n\n" ..
            "Possible causes:\n" ..
            "• Probe not connected or not triggered\n" ..
            "• Edge is beyond probe travel distance\n" ..
            "• Part may be missing or misaligned\n\n" ..
            "The probe sequence has stopped.",
            directionName, maxTravel)
        
        wx.wxMessageBox(msg, "Probe Failure", wx.wxOK + wx.wxICON_ERROR)
        error(string.format("%s probe failed - no contact detected", directionName))
    end
    
    return resultWork, resultMachine
end

-- ============================================
-- SOFT LIMITS CHECKING
-- ============================================
-- Calculates maximum safe travel distance in given direction from current position
function GetMaxSafeTravel(axis, direction, currentMachPos)
    local softMin, rc1 = mc.mcAxisGetSoftlimitMin(inst, axis)
    local softMax, rc2 = mc.mcAxisGetSoftlimitMax(inst, axis)
    local softEnabled = mc.mcSoftLimitGetState(inst, axis)
    
    if softEnabled ~= 1 or rc1 ~= mc.MERROR_NOERROR or rc2 ~= mc.MERROR_NOERROR then
        return 999  -- No soft limits enabled, return large number
    end
    
    local safetyBuffer = 0.010  -- 10 thousandths safety margin
    
    if direction > 0 then
        -- Moving in positive direction
        local available = softMax - currentMachPos - safetyBuffer
        return math.max(0, available)
    else
        -- Moving in negative direction  
        local available = currentMachPos - softMin - safetyBuffer
        return math.max(0, available)
    end
end

-- ============================================
-- SMART RETRY LOGIC
-- ============================================
-- Executes probe with retry capability for improved reliability
local function ProbeWithRetry(probeCommand, directionName, maxAttempts)
    maxAttempts = maxAttempts or 2  -- Default 2 attempts
    
    for attempt = 1, maxAttempts do
        local ok, resultWork, resultMachine = pcall(ExecuteSentinelProbe, probeCommand, directionName)
        
        if ok then
            -- Probe succeeded
            return resultWork, resultMachine
        else
            -- Probe failed
            if attempt < maxAttempts then
                mc.mcCntlSetLastError(inst, string.format("%s probe failed, retrying (%d/%d)...", 
                                                        directionName, attempt, maxAttempts))
                -- Brief pause before retry to allow any transient issues to clear
                mc.mcCntlExecuteWait(inst, 200)  -- 200ms delay
            else
                -- All attempts exhausted, re-raise the error
                error(string.format("%s probe failed after %d attempts", directionName, maxAttempts))
            end
        end
    end
end

-- Load saved settings
local lastCorner = ProfileGetInt("InsideCornerProbe", "CornerSelection", 1)
local lastAction = ProfileGetInt("InsideCornerProbe", "ActionMode", 1)

-- Determine parent window
local parent = wx.NULL
local app = wx.wxGetApp()
if app then
    local ok, top = pcall(function() return app:GetTopWindow() end)
    if ok and top then parent = top end
end

-- Dialog dimensions - compact
local dlgW, dlgH = 320, 220
local sw = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_X) or 1024
local sh = wx.wxSystemSettings.GetMetric(wx.wxSYS_SCREEN_Y) or 768
local posX = math.floor((sw - dlgW) / 2)
local posY = math.floor((sh - dlgH) / 2)

-- Create main dialog
local dlg = wx.wxDialog(parent, wx.wxID_ANY,
    "Inside Corner Probe",
    wx.wxPoint(posX, posY), wx.wxSize(dlgW, dlgH),
    wx.wxDEFAULT_DIALOG_STYLE)

-- Main panel
local panel = wx.wxPanel(dlg, wx.wxID_ANY)
local mainSizer = wx.wxBoxSizer(wx.wxVERTICAL)

-- Corner selection in 2x2 grid with clear coordinate labels
local cornerChoices = {
    "-X, +Y",  -- Top Left
    "+X, +Y",  -- Top Right
    "-X, -Y",  -- Bottom Left  
    "+X, -Y"   -- Bottom Right
}

local cornerBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Corner Type")
local cornerCenterSizer = wx.wxBoxSizer(wx.wxHORIZONTAL)
cornerCenterSizer:AddStretchSpacer()

local cornerRadio = wx.wxRadioBox(panel, wx.wxID_ANY,
    "", wx.wxDefaultPosition, wx.wxDefaultSize,
    cornerChoices, 2, wx.wxRA_SPECIFY_COLS)
cornerRadio:SetSelection(lastCorner - 1)  -- 0-based index

cornerCenterSizer:Add(cornerRadio, 0, wx.wxALL, 5)
cornerCenterSizer:AddStretchSpacer()
cornerBox:Add(cornerCenterSizer, 0, wx.wxEXPAND, 0)
mainSizer:Add(cornerBox, 0, wx.wxALL + wx.wxEXPAND, 10)

-- Combined Options Section - more compact
local optionsBox = wx.wxStaticBoxSizer(wx.wxVERTICAL, panel, "Probe Options")

-- Action (using wxRadioBox for reliability)
local actionChoices = {"Set Datum", "Print Coords"}
local actionRadio = wx.wxRadioBox(panel, wx.wxID_ANY,
    "Action", wx.wxDefaultPosition, wx.wxDefaultSize,
    actionChoices, 2, wx.wxRA_SPECIFY_COLS)
actionRadio:SetSelection(lastAction - 1)  -- 0-based index

optionsBox:Add(actionRadio, 0, wx.wxEXPAND + wx.wxALL, 5)
mainSizer:Add(optionsBox, 0, wx.wxLEFT + wx.wxRIGHT + wx.wxBOTTOM + wx.wxEXPAND, 10)

-- Spacer before buttons
mainSizer:AddStretchSpacer()

-- Create standard button sizer
local buttonSizer = wx.wxStdDialogButtonSizer()
local okBtn = wx.wxButton(panel, wx.wxID_OK, "OK")
local cancelBtn = wx.wxButton(panel, wx.wxID_CANCEL, "Cancel")

okBtn:SetMinSize(wx.wxSize(90, 28))
cancelBtn:SetMinSize(wx.wxSize(90, 28))

buttonSizer:AddButton(okBtn)
buttonSizer:AddButton(cancelBtn)
buttonSizer:Realize()

mainSizer:Add(buttonSizer, 0, wx.wxALL + wx.wxALIGN_CENTER, 8)

-- Apply layout
panel:SetSizer(mainSizer)
mainSizer:Fit(panel)
dlg:Fit()
dlg:Centre()

-- Show dialog and handle result
if dlg:ShowModal() == wx.wxID_OK then
    -- Get selections using proven GetSelection() method (returns 0-based index)
    local cornerSel = cornerRadio:GetSelection() + 1  -- Convert to 1-based
    local actionSel = actionRadio:GetSelection() + 1
    
    -- Save settings
    ProfileSetInt("InsideCornerProbe", "CornerSelection", cornerSel)
    ProfileSetInt("InsideCornerProbe", "ActionMode", actionSel)
    
    dlg:Destroy()
    
    -- Check if M311 macro exists
    local profileName = mc.mcProfileGetName(inst)
    local macroPath = mc.mcCntlGetMachDir(inst) .. "\\Profiles\\" .. profileName .. "\\Macros\\m311.mcs"
    
    local file = io.open(macroPath, "r")
    if not file then
        mc.mcCntlSetLastError(inst, "ERROR: M311 macro not found at: " .. macroPath)
        wx.wxMessageBox("M311 macro not found!\n\nPlease ensure m311.mcs exists in:\n" .. macroPath, 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
        return
    else
        file:close()
    end
    
    -- Execute probing sequence using M311
    local function ExecuteCornerProbe()
        -- Check if probe is already triggered
        if mc.mcSignalGetState(inst, mc.ISIG_PROBE) == 1 then
            wx.wxMessageBox("Probe is already triggered!", "Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        
        -- Initialize probe log
        local profileName = mc.mcProfileGetName(inst)
        local probeLogPath = mc.mcCntlGetMachDir(inst) .. "\\Profiles\\" .. profileName .. "\\ProbeLog.csv"
        local logFile = io.open(probeLogPath, "a")
        if logFile then
            -- Write header if file is new/empty
            local fileSize = logFile:seek("end")
            if fileSize == 0 then
                logFile:write("Timestamp,Method,X,Y,Z\n")
            end
            logFile:close()
        end
        
        -- Helper function to log probe events
        local function LogProbeEvent(method, x, y, z)
            local ok, err = pcall(function()
                local logFile = io.open(probeLogPath, "a")
                if logFile then
                    local timestamp = os.date("%Y-%m-%d %H:%M:%S")
                    local logEntry = string.format("%s,%s,%.4f,%.4f,%.4f\n",
                        timestamp, method, x, y, z)
                    logFile:write(logEntry)
                    logFile:close()
                end
            end)
            -- Silent fail on logging errors
        end
        
        -- Get probe parameters from pound variables
        local probeDiameter = mc.mcCntlGetPoundVar(inst, 300)
        local fastFeed = mc.mcCntlGetPoundVar(inst, 303)
        local slowFeed = mc.mcCntlGetPoundVar(inst, 304)
        local maxTravel = mc.mcCntlGetPoundVar(inst, 305)
        
        -- Validate and set defaults
        if type(probeDiameter) ~= "number" or probeDiameter <= 0 then 
            probeDiameter = 0.125  -- Default 1/8" probe
        end
        if type(fastFeed) ~= "number" or fastFeed <= 0 then fastFeed = 30 end
        if type(slowFeed) ~= "number" or slowFeed <= 0 then slowFeed = 5 end
        if type(maxTravel) ~= "number" or maxTravel <= 0 then maxTravel = 1.0 end
        
        -- Check for uninitialized pound variables
        if fastFeed < -1e300 or slowFeed < -1e300 or maxTravel < -1e300 then
            mc.mcCntlSetLastError(inst, "ERROR: Probe parameters not initialized. Set #300-305")
            wx.wxMessageBox("Probe parameters not initialized!\n\nPlease set pound variables:\n" ..
                          "#300 = Probe diameter\n" ..
                          "#303 = Fast feed\n#304 = Slow feed\n#305 = Max travel", 
                          "Configuration Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        
        -- Determine probe directions based on corner selection
        local xDirection, yDirection
        
        if cornerSel == 1 then      -- -X, +Y (Top Left)
            xDirection = 2  -- S2 M311 (Probe -X)
            yDirection = 3  -- S3 M311 (Probe +Y)
        elseif cornerSel == 2 then  -- +X, +Y (Top Right)
            xDirection = 1  -- S1 M311 (Probe +X)
            yDirection = 3  -- S3 M311 (Probe +Y)
        elseif cornerSel == 3 then  -- -X, -Y (Bottom Left)
            xDirection = 2  -- S2 M311 (Probe -X)
            yDirection = 4  -- S4 M311 (Probe -Y)
        else                        -- +X, -Y (Bottom Right)
            xDirection = 1  -- S1 M311 (Probe +X)
            yDirection = 4  -- S4 M311 (Probe -Y)
        end
        
        mc.mcCntlSetLastError(inst, "Starting inside corner probe sequence...")
        
        -- Capture starting state in BOTH coordinate systems
        local startState = {
            -- Machine positions for ALL movements (G53 commands)
            machX = mc.mcAxisGetMachinePos(inst, 0),
            machY = mc.mcAxisGetMachinePos(inst, 1),
            machZ = mc.mcAxisGetMachinePos(inst, 2),
            
            -- Work positions for display and logging ONLY
            workX = mc.mcAxisGetPos(inst, mc.X_AXIS),
            workY = mc.mcAxisGetPos(inst, mc.Y_AXIS),
            workZ = mc.mcAxisGetPos(inst, mc.Z_AXIS)
        }
        
        mc.mcCntlSetLastError(inst, string.format("Start position: X%.4f Y%.4f", startState.workX, startState.workY))
        
        -- ============================================
        -- SOFT LIMITS VALIDATION
        -- ============================================
        -- Determine probe directions based on corner selection
        local xDir = (cornerSel == 1 or cornerSel == 3) and -1 or 1  -- -X for corners 1,3; +X for 2,4
        local yDir = (cornerSel == 1 or cornerSel == 2) and 1 or -1  -- +Y for corners 1,2; -Y for 3,4
        
        -- Validate X direction probe won't hit soft limits
        local maxXTravel = GetMaxSafeTravel(mc.X_AXIS, xDir, startState.machX)
        if maxXTravel < maxTravel then
            local msg = string.format(
                "X DIRECTION SOFT LIMIT ERROR\n\n" ..
                "Cannot probe full distance (%.3f\") due to soft limits.\n" ..
                "Available travel: %.3f\"\n\n" ..
                "Possible solutions:\n" ..
                "• Move probe closer to the part\n" ..
                "• Reduce probe travel distance (#305)",
                maxTravel, maxXTravel)
            wx.wxMessageBox(msg, "Soft Limit Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        
        -- Validate Y direction probe won't hit soft limits  
        local maxYTravel = GetMaxSafeTravel(mc.Y_AXIS, yDir, startState.machY)
        if maxYTravel < maxTravel then
            local msg = string.format(
                "Y DIRECTION SOFT LIMIT ERROR\n\n" ..
                "Cannot probe full distance (%.3f\") due to soft limits.\n" ..
                "Available travel: %.3f\"\n\n" ..
                "Possible solutions:\n" ..
                "• Move probe closer to the part\n" ..
                "• Reduce probe travel distance (#305)",
                maxTravel, maxYTravel)
            wx.wxMessageBox(msg, "Soft Limit Error", wx.wxOK + wx.wxICON_ERROR)
            return false
        end
        
        -- PROBE X DIRECTION FIRST
        mc.mcCntlSetLastError(inst, "Probing X direction...")
        local xProbeCmd = string.format("S%d M311", xDirection)
        local xEdge, xEdgeMachine = ProbeWithRetry(xProbeCmd, "X direction")
        
        -- Log X probe
        LogProbeEvent(xProbeCmd, xEdge, startState.workY, startState.workZ)
        
        mc.mcCntlSetLastError(inst, string.format("X edge found at: %.4f", xEdge))
        
        -- Validate probe actually moved (not just hit travel limit)
        local xMovement = math.abs(xEdge - startState.workX)
        if xMovement < 0.001 then
            mc.mcCntlSetLastError(inst, "ERROR: X probe did not move - check probe connection")
            return false
        elseif xMovement >= (maxTravel - 0.001) then
            mc.mcCntlSetLastError(inst, "WARNING: X probe may have hit travel limit")
        end
        
        -- RETURN TO START POSITION using machine coordinates
        mc.mcCntlSetLastError(inst, "Returning to start position...")
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f Y%.4f", startState.machX, startState.machY))
        
        -- PROBE Y DIRECTION
        mc.mcCntlSetLastError(inst, "Probing Y direction...")
        local yProbeCmd = string.format("S%d M311", yDirection)
        local yEdge, yEdgeMachine = ProbeWithRetry(yProbeCmd, "Y direction")
        
        -- Log Y probe
        LogProbeEvent(yProbeCmd, startState.workX, yEdge, startState.workZ)
        
        mc.mcCntlSetLastError(inst, string.format("Y edge found at: %.4f", yEdge))
        
        -- Validate probe actually moved
        local yMovement = math.abs(yEdge - startState.workY)
        if yMovement < 0.001 then
            mc.mcCntlSetLastError(inst, "ERROR: Y probe did not move - check probe connection")
            return false
        elseif yMovement >= (maxTravel - 0.001) then
            mc.mcCntlSetLastError(inst, "WARNING: Y probe may have hit travel limit")
        end
        
        -- RETURN TO ORIGINAL START POSITION using machine coordinates
        mc.mcCntlSetLastError(inst, "Returning to original start position...")
        mc.mcCntlGcodeExecuteWait(inst, string.format("G53 G0 X%.4f Y%.4f", startState.machX, startState.machY))
        
        -- Calculate corner position in work coordinates
        -- Since M6 handles the offset when T90 is active, the edge positions are already correct
        local datumX = xEdge
        local datumY = yEdge
        mc.mcCntlSetLastError(inst, string.format("Corner found at: X%.4f Y%.4f", datumX, datumY))
        
        -- Get current work offset
        local modalOffset = mc.mcCntlGetPoundVar(inst, 4014)
        local currentOffset = 54  -- Default G54
        if type(modalOffset) == "number" and modalOffset >= 54 and modalOffset <= 59 then
            currentOffset = math.floor(modalOffset + 0.5)
        end
        
        -- FIXED: Correct work offset variable mapping
        local workOffsetVars = {
            [54] = {x = 5221, y = 5222, z = 5223},  -- G54
            [55] = {x = 5241, y = 5242, z = 5243},  -- G55
            [56] = {x = 5261, y = 5262, z = 5263},  -- G56
            [57] = {x = 5281, y = 5282, z = 5283},  -- G57
            [58] = {x = 5301, y = 5302, z = 5303},  -- G58
            [59] = {x = 5321, y = 5322, z = 5323}   -- G59
        }
        
        local offsets = workOffsetVars[currentOffset]
        
        -- FIXED: Calculate machine coordinates properly
        -- Machine Position = Current Machine Position + (Datum Work Position - Current Work Position)
        local currentMachX = mc.mcAxisGetMachinePos(inst, mc.X_AXIS)
        local currentMachY = mc.mcAxisGetMachinePos(inst, mc.Y_AXIS)
        local currentWorkX = mc.mcAxisGetPos(inst, mc.X_AXIS)
        local currentWorkY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
        
        local cornerMachX = currentMachX + (datumX - currentWorkX)
        local cornerMachY = currentMachY + (datumY - currentWorkY)
        
        mc.mcCntlSetLastError(inst, string.format("Datum work position: X%.4f Y%.4f", datumX, datumY))
        mc.mcCntlSetLastError(inst, string.format("Datum machine position: X%.4f Y%.4f", 
                                                 cornerMachX, cornerMachY))
        
        if actionSel == 1 then -- Set Datum
            if offsets then
                -- Set new work offset values
                -- We want the corner position to become work coordinate 0,0
                -- So the work offset should equal the machine position of the corner
                mc.mcCntlSetPoundVar(inst, offsets.x, cornerMachX)
                mc.mcCntlSetPoundVar(inst, offsets.y, cornerMachY)
                
                -- Keep the Z offset unchanged
                local currentZOffset = mc.mcCntlGetPoundVar(inst, offsets.z)
                mc.mcCntlSetPoundVar(inst, offsets.z, currentZOffset)
                
                -- Force work offset update by executing G10 L2
                -- G10 L2 P[offset] X[value] Y[value] sets work offset
                local offsetP = currentOffset - 53  -- G54=P1, G55=P2, etc.
                local g10Command = string.format("G10 L2 P%d X%.4f Y%.4f", 
                                               offsetP, cornerMachX, cornerMachY)
                mc.mcCntlSetLastError(inst, "Executing: " .. g10Command)
                mc.mcCntlGcodeExecuteWait(inst, g10Command)
                
                -- Now activate the work offset
                local gcode = string.format("G%d", currentOffset)
                mc.mcCntlGcodeExecuteWait(inst, gcode)
                
                local offsetName = "G" .. tostring(currentOffset)
                mc.mcCntlSetLastError(inst, string.format("Work offset %s updated: Corner is now X0 Y0", offsetName))
                
                -- Verify the new position
                local newWorkX = mc.mcAxisGetPos(inst, mc.X_AXIS)
                local newWorkY = mc.mcAxisGetPos(inst, mc.Y_AXIS)
                
                mc.mcCntlSetLastError(inst, string.format("Current position is now: X%.4f Y%.4f", 
                                                         newWorkX, newWorkY))
                
                -- Verify offset was stored
                local verifyX = mc.mcCntlGetPoundVar(inst, offsets.x)
                local verifyY = mc.mcCntlGetPoundVar(inst, offsets.y)
                mc.mcCntlSetLastError(inst, string.format("%s offset stored as: X%.4f Y%.4f", 
                                                         offsetName, verifyX, verifyY))
            else
                mc.mcCntlSetLastError(inst, "ERROR: Invalid work offset")
            end
        else
            -- Print coordinates only
            mc.mcCntlSetLastError(inst, "===== CORNER PROBE RESULTS =====")
            mc.mcCntlSetLastError(inst, string.format("Corner work coordinates: X%.4f Y%.4f", datumX, datumY))
            mc.mcCntlSetLastError(inst, string.format("Corner machine coordinates: X%.4f Y%.4f", 
                                                     cornerMachX, cornerMachY))
            
            -- Calculate what the current position would be if corner was set to 0,0
            local currentPosIfZeroed = {
                x = currentMachX - cornerMachX,
                y = currentMachY - cornerMachY
            }
            mc.mcCntlSetLastError(inst, string.format("Your position relative to corner: X%.4f Y%.4f", 
                                                     currentPosIfZeroed.x, currentPosIfZeroed.y))
            
            -- Show which work offset would be affected
            local offsetName = "G" .. tostring(currentOffset)
            mc.mcCntlSetLastError(inst, string.format("Current work offset: %s", offsetName))
            mc.mcCntlSetLastError(inst, "================================")
        end
        
        return true
    end
    
    -- Execute the probing sequence with proper error handling
    local success, result = pcall(ExecuteCornerProbe)
    
    if not success then
        -- Lua error occurred
        mc.mcCntlSetLastError(inst, "ERROR: Lua error - " .. tostring(result))
        wx.wxMessageBox("Lua error in probe sequence:\n" .. tostring(result), 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
    elseif result == false then
        -- ExecuteCornerProbe returned false (probe failure)
        -- Error message already set in status bar by ExecuteCornerProbe
        wx.wxMessageBox("Probe sequence failed!\n\nCheck the status bar for details.", 
                       "Probe Error", wx.wxOK + wx.wxICON_ERROR)
    else
        -- Success
        mc.mcCntlSetLastError(inst, "Inside corner probe completed successfully")
    end
    
else
    -- User cancelled
    dlg:Destroy()
end