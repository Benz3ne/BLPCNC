-- OutputsFlipTest.txt
-- Purpose: End-to-end diagnostic to identify why outputs 3–6 won’t turn OFF and who reasserts them.
-- Usage:
--   Option A (Console):
--     local inst = mc.mcGetInstance()
--     dofile(mc.mcCntlGetMachDir(inst).."\\Profiles\\BLP\\Scripts\\Diagnostics\\OutputsFlipTest.txt")
--     RunOutputsFlipTest(inst)
--   Option B (Button):
--     local inst = mc.mcGetInstance()
--     dofile(mc.mcCntlGetMachDir(inst).."\\Profiles\\BLP\\Scripts\\Diagnostics\\OutputsFlipTest.txt")
--     RunOutputsFlipTest(inst)

local function now() return os.clock() end
local function ts() return os.date("%H:%M:%S") end

local function Sleep(ms)
  wx.wxMilliSleep(ms)
end

local function ReadSig(inst, idOrName)
  local id = (type(idOrName)=="number") and idOrName or mc[idOrName]
  local h = mc.mcSignalGetHandle(inst, id)
  if not h or h == 0 then return -1 end
  return mc.mcSignalGetState(h) or -1
end

local function WriteSig(inst, idOrName, v)
  if SystemLib and SystemLib.SignalSetState then
    return SystemLib.SignalSetState(inst, ((type(idOrName)=="number") and idOrName or mc[idOrName]), (v ~= 0))
  end
  local id = (type(idOrName)=="number") and idOrName or mc[idOrName]
  local h = mc.mcSignalGetHandle(inst, id)
  if not h or h == 0 then return false end
  mc.mcSignalSetState(h, (v ~= 0) and 1 or 0)
  return true
end

local function PVget(inst, n)
  if SystemLib and SystemLib.PoundVarGet then return SystemLib.PoundVarGet(inst, n) end
  return mc.mcCntlGetPoundVar(inst, n)
end

local function PVset(inst, n, v)
  if SystemLib and SystemLib.PoundVarSet then return SystemLib.PoundVarSet(inst, n, v) end
  return mc.mcCntlSetPoundVar(inst, n, v)
end

local function Log(inst, fh, lvl, msg)
  local line = string.format("%s [%s] %s", ts(), lvl, msg)
  if SystemLib and SystemLib.Log then SystemLib.Log(inst, line, lvl) else mc.mcCntlSetLastError(inst, line) end
  if fh then fh:write(line.."\n"); fh:flush() end
end

local function pollFor(inst, id, want, msWindow, msStep)
  local t0 = now()
  while (now() - t0) * 1000.0 < msWindow do
    local rb = ReadSig(inst, id)
    if rb == want then return true, rb end
    Sleep(msStep or 20)
  end
  return false, ReadSig(inst, id)
end

local DEV = {
  { name="boot",     id=mc.OSIG_OUTPUT3, auto=402, target=403 },
  { name="dust",     id=mc.OSIG_OUTPUT4, auto=400, target=404 },
  { name="vacRear",  id=mc.OSIG_OUTPUT5, auto=401, target=411 },
  { name="vacFront", id=mc.OSIG_OUTPUT6, auto=401, target=412 },
}

local function snapshot(inst)
  local s = {}
  for _,d in ipairs(DEV) do
    s[d.name] = {
      out   = ReadSig(inst, d.id),
      auto  = PVget(inst, d.auto),
      targ  = PVget(inst, d.target),
    }
  end
  return s
end

local function fmtSnap(s)
  local t = {}
  for k,v in pairs(s) do
    table.insert(t, string.format("%s{out=%s auto=%s targ=%s}", k, tostring(v.out), tostring(v.auto), tostring(v.targ)))
  end
  table.sort(t)
  return table.concat(t, "  ")
end

function RunOutputsFlipTest(inst)
  inst = inst or mc.mcGetInstance()
  local machDir = mc.mcCntlGetMachDir(inst)
  local logPath = machDir.."\\Profiles\\BLP\\OutputsFlipTest_"..os.date("%Y%m%d-%H%M%S")..".log"
  local fh = io.open(logPath, "w")

  -- Enable debug visuals
  PVset(inst, 4990, 1)    -- SystemLib debug mode ON
  _G.__SIG_TRACE = true   -- enable SignalSetState tracer (see patch)
  Log(inst, fh, "INFO", "=== Outputs Flip Test START ===")
  Log(inst, fh, "INFO", "Log: "..logPath)

  local en = ReadSig(inst, mc.OSIG_MACHINE_ENABLED)
  Log(inst, fh, "INFO", "Machine enabled="..tostring(en))

  -- Baseline
  local base = snapshot(inst)
  Log(inst, fh, "INFO", "Baseline: "..fmtSnap(base))

  -- PHASE 1: Normal system (no blocks)
  Log(inst, fh, "INFO", "PHASE 1: Normal system (no blocks); manual OFF via AuxLib → observe reassert")
  for _,d in ipairs(DEV) do
    if AuxLib and AuxLib.Request then
      AuxLib.Request(inst, { device=d.name, action="manual.off" })
      if AuxLib and AuxLib.Update then AuxLib.Update(inst) end
      local ok, rb = pollFor(inst, d.id, 0, 800, 20)
      Log(inst, fh, ok and "INFO" or "WARNING",
          string.format("P1 %s manual.off result: ok=%s rb=%s", d.name, tostring(ok), tostring(rb)))
      Sleep(200)
      local rb2 = ReadSig(inst, d.id)
      if rb2 ~= 0 then
        Log(inst, fh, "WARNING", string.format("P1 %s reasserted to %s within 1s", d.name, tostring(rb2)))
      end
    else
      Log(inst, fh, "ERROR", "AuxLib.Request missing; cannot run PHASE 1")
    end
  end

  -- PHASE 2: Block AuxLib writes; set manual OFF again; observe
  Log(inst, fh, "INFO", "PHASE 2: Block AuxLib writes (__AUX_WRITE_BLOCK=true); set PV targets to OFF; observe outputs")
  _G.__AUX_WRITE_BLOCK = true
  for _,d in ipairs(DEV) do
    if AuxLib and AuxLib.Request then
      AuxLib.Request(inst, { device=d.name, action="manual.off" })
    end
    if AuxLib and AuxLib.Update then AuxLib.Update(inst) end
    local ok, rb = pollFor(inst, d.id, 0, 800, 20)
    Log(inst, fh, ok and "INFO" or "WARNING",
        string.format("P2 %s (block) manual.off result: ok=%s rb=%s", d.name, tostring(ok), tostring(rb)))
    Sleep(200)
    local rb2 = ReadSig(inst, d.id)
    if rb2 ~= 0 then
      Log(inst, fh, "WARNING", string.format("P2 %s reasserted to %s within 1s (external to AuxLib)", d.name, tostring(rb2)))
    end
  end

  -- PHASE 3: Direct hardware write; observe
  Log(inst, fh, "INFO", "PHASE 3: Direct mc write (bypass AuxLib/PLC); observe")
  for _,d in ipairs(DEV) do
    WriteSig(inst, d.id, 0)
    local ok, rb = pollFor(inst, d.id, 0, 800, 20)
    Log(inst, fh, ok and "INFO" or "WARNING",
        string.format("P3 %s direct write OFF: ok=%s rb=%s", d.name, tostring(ok), tostring(rb)))
    Sleep(200)
    local rb2 = ReadSig(inst, d.id)
    if rb2 ~= 0 then
      Log(inst, fh, "ERROR", string.format("P3 %s still HIGH after direct write (plugin/brain likely mapping)", d.name))
    end
  end

  -- Summarize
  local fin = snapshot(inst)
  Log(inst, fh, "INFO", "Final snapshot: "..fmtSnap(fin))

  Log(inst, fh, "INFO", "Guidance:")
  Log(inst, fh, "INFO", "- If PHASE 2 or PHASE 3 shows reassertion, something OUTSIDE AuxLib is forcing these outputs (Brain or controller mapping).")
  Log(inst, fh, "INFO", "- If only PHASE 1 shows reassertion but PHASE 2/3 do not, AuxLib/PLC logic is flipping them back (check device.auto/safety).")
  Log(inst, fh, "INFO", "- If all phases keep them OFF, UI buttons not reflecting state is a control-name binding issue in ScreenLoad (btn names).")
  Log(inst, fh, "INFO", "=== Outputs Flip Test END ===")

  if fh then fh:close() end
end

return true
