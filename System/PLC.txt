-- C:\Mach4Hobby\Profiles\BLP\Scripts\System\PLC.txt
-- Exposes PLC_Init(inst) and PLC_Tick(inst). The GUI PLC shim calls these.

----------------------------------------------------------------
-- Helpers
----------------------------------------------------------------
-- Always take ONLY the first return from scr.GetProperty (value, rc)
local function scrProp(name, prop)
  return select(1, scr.GetProperty(name, prop))
end

-- Safe numeric read from a screen control
local function scrNumber(name, prop)
  local v = scrProp(name, prop)
  return tonumber(v) or 0
end

----------------------------------------------------------------
-- One-time init (handles, caches, first-run stuff)
----------------------------------------------------------------
function PLC_Init(inst)
  local mc = mc

  -- runtime state (single table)
  _G.__plc = _G.__plc or {
    handles = {}, spin = {}, air = {deb=0,last=-1},
    tool = {last17=-1}, enableSeen = 0
  }
  local P = _G.__plc

  -- safe require (uses globals if ScreenLoad already exposed them)
  local function tryRequire(name)
    local ok, mod = pcall(require, name)
    if ok and type(mod)=="table" then return mod end
    return _G[name]
  end
  P.SystemLib = tryRequire("SystemLib") or P.SystemLib
  P.ToolLib   = tryRequire("ToolLib")   or P.ToolLib
  P.AuxLib    = tryRequire("AuxLib")    or P.AuxLib

  -- signal handle cache
  function P.h(sig)
    local h = P.handles[sig]
    if not h or h == 0 then h = mc.mcSignalGetHandle(inst, sig); P.handles[sig] = h end
    return h
  end

  -- pound-var helpers
  function P.pvGet(id)
    local SL = P.SystemLib
    if SL and SL.PoundVarGet then return tonumber(SL.PoundVarGet(inst,id)) or 0 end
    return tonumber(mc.mcCntlGetPoundVar(inst,id)) or 0
  end
  function P.pvSet(id,v)
    local SL = P.SystemLib
    if SL and SL.PoundVarSet then return SL.PoundVarSet(inst,id,v) end
    return mc.mcCntlSetPoundVar(inst,id,v)
  end

  -- common signal handles
  P.hInLowAir  = P.h(mc.ISIG_INPUT6)      -- Low air (1=LOW)
  P.hToolSense = P.h(mc.ISIG_INPUT17)     -- Tool present (1=present)
  P.hEn        = P.h(mc.OSIG_MACHINE_ENABLED)
  P.hSpindleOn = P.h(mc.OSIG_SPINDLEON)

  ----------------------------------------------------------------
  -- Mach default "first run" actions (run once here, not every tick)
  ----------------------------------------------------------------
  -- Keyboard inputs: force a state that makes KeyboardInputsToggle() do a disable/enable
  local iReg = mc.mcIoGetHandle(inst, "Keyboard/Enable")
  pcall(mc.mcIoSetState, iReg, 1)
  if type(_G.KeyboardInputsToggle)=="function" then pcall(_G.KeyboardInputsToggle) end

  -- Initialize fractional DROs (if those helpers exist)
  if type(_G.DecToFrac)=="function" then
    pcall(_G.DecToFrac, 0); pcall(_G.DecToFrac, 1); pcall(_G.DecToFrac, 2)
  end

  -- Restore persistent DROs (your table names preserved)
  local DROTable = {
    [1034] = "droEdgeFinder",
    [1035] = "droGageBlock",
    [1036] = "droGageBlockT",
  }
  for _, droName in pairs(DROTable) do
    local val = mc.mcProfileGetString(inst, "PersistentDROs", droName, "NotFound")
    if val ~= "NotFound" then pcall(scr.SetProperty, droName, "Value", val) end
  end
end

----------------------------------------------------------------
-- Per-cycle work
----------------------------------------------------------------
function PLC_Tick(inst)
  local mc = mc
  -- Keep compatibility with Mach defaults
  _G.testcount = (_G.testcount or 0) + 1

  local machState = mc.mcCntlGetState(inst)
  local inCycle   = (mc.mcCntlIsInCycle(inst) == 1)

  -------------------------------------------------------
  --  Coroutine resume (kept from your default PLC)
  -------------------------------------------------------
  if (_G.wait ~= nil) and (machState == mc.MC_STATE_IDLE) then
    if coroutine.status(_G.wait) == "suspended" then coroutine.resume(_G.wait) end
  end

  -------------------------------------------------------
  --  UI updates you had in the default PLC (kept as-is)
  -------------------------------------------------------
  -- Plate align LED (G68)  -- FIXED: use scrNumber() so tonumber() gets one arg
  do
    local curLedState   = scrNumber("ledPlateAlign", "Value")
    local curAlignState = math.abs((mc.mcCntlGetPoundVar(inst, 4016) - 69))
    if curLedState ~= curAlignState then
      pcall(scr.SetProperty, "ledPlateAlign", "Value", tostring(curAlignState))
    end
  end

  -- Cycle time label (assumes global machEnabled/time as in default PLC)
  if (_G.machEnabled == 1) then
    local cycletime = mc.mcCntlGetRunTime(inst, _G.time)
    if type(_G.SecondsToTime)=="function" then
      pcall(scr.SetProperty, "CycleTime", "Label", _G.SecondsToTime(cycletime))
    end
  end

  -- Height Offset LED (gate write)
  do
    local HOState = mc.mcCntlGetPoundVar(inst, 4008)
    local cur = select(1, scr.GetProperty("ledHOffset", "Value"))
    local want = (HOState == 49) and "0" or "1"  -- 49 = '1' char in some post chains
    if cur ~= want then pcall(scr.SetProperty, "ledHOffset", "Value", want) end
  end

  -- Ratio DROs  -- tightened to use helper for consistency
  do
    local spinmotormax = scrNumber('droSpinMotorMax','Value'); if spinmotormax == 0 then spinmotormax = 1 end
    local rangemax     = scrNumber('droRangeMax','Value')
    pcall(scr.SetProperty, 'droRatio', 'Value', tostring(rangemax / spinmotormax))
    local range   = select(1, mc.mcSpindleGetCurrentRange(inst))
    local fbratio = select(1, mc.mcSpindleGetFeedbackRatio(inst, range))
    pcall(scr.SetProperty, 'droFeedbackRatio', 'Value', tostring(fbratio))
  end

  -------------------------------------------------------
  --  Libraries (single source of truth) — call ONCE per tick
  -------------------------------------------------------
  do
    local P = _G.__plc or {}
    local ToolLib = (P.ToolLib or _G.ToolLib)
    local AuxLib  = (P.AuxLib  or _G.AuxLib)
    if ToolLib and ToolLib.Update then pcall(ToolLib.Update, inst) end
    if AuxLib and (AuxLib.Update or AuxLib.update) then
      pcall(AuxLib.Update or AuxLib.update, inst)
    end
  end

  -- === UI sync (gated; repaint only on change, includes AUTO PVs) ===
  do
    local P = _G.__plc or {}; _G.__plc = P
    local S = AuxLib and AuxLib.State
    if S then

      -- Cheap PV accessor; defers to SystemLib when available
      local function pv(n)
        if SystemLib and SystemLib.PoundVarGet then return SystemLib.PoundVarGet(inst, n) end
        return mc.mcCntlGetPoundVar(inst, n)
      end

      local function snap()
        local d  = S(inst, "dust")     or {}
        local b  = S(inst, "boot")     or {}
        local vf = S(inst, "vacFront") or {}
        local vr = S(inst, "vacRear")  or {}
        local hs = mc.mcSignalGetHandle(inst, mc.OSIG_MACHINE_SOFTLIMITS)
        local sl = hs and mc.mcSignalGetState(hs) or 0
        return {
          dust={on=(d.on or 0),  auto=(d.auto or 0)},
          boot={on=(b.on or 0),  auto=(b.auto or 0)},
          vacFront={on=(vf.on or 0), auto=(vf.auto or 0)},
          vacRear={on=(vr.on or 0), auto=(vr.auto or 0)},
          softlimits=sl,
        }
      end

      local st = snap()

      -- Include PVs so AUTO-only changes trigger repaint immediately
      local a400 = tonumber(pv(400)) or 0  -- dust AUTO
      local a401 = tonumber(pv(401)) or 0  -- vacuum AUTO (both)
      local a402 = tonumber(pv(402)) or 0  -- boot AUTO

      local sig = table.concat({
        st.dust.on, st.dust.auto,
        st.boot.on, st.boot.auto,
        st.vacFront.on, st.vacFront.auto,
        st.vacRear.on, st.vacRear.auto,
        st.softlimits,
        a400, a401, a402
      }, ",")

      if sig ~= P._ui_sig then
        P._ui_sig = sig
        if UI and UI.SyncOutputs then pcall(UI.SyncOutputs, st) end
      end
    end
  end

  -- === Low air pressure (1.0 s debounce) ===
  do
    local P = _G.__plc or {}; _G.__plc = P
    P.air = P.air or { last=0, t0=0 }
    local lowNow = (mc.mcSignalGetState(P.hInLowAir) == 1)

    if lowNow then
      if P.air.t0 == 0 then P.air.t0 = os.clock() end
      if (os.clock() - P.air.t0) >= 1.0 and P.air.last ~= 1 then
        local st = mc.mcCntlGetState(inst)
        if st == mc.MC_STATE_FRUN or st == mc.MC_STATE_MRUN then
          mc.mcCntlFeedHold(inst); mc.mcCntlCycleStop(inst)
        end
        if mc.mcSignalGetState(P.hSpindleOn) == 1 then mc.mcSpindleSetDirection(inst, 0) end
        mc.mcCntlEnable(inst, 0)
        _G.lowAirDisabled = true
        _G.needLowAirDialog, _G.lowAirDialogType, _G.lowAirDialogMessage = true, "error", "Air pressure is LOW. Machine has been disabled."
        P.air.last = 1
      end
    else
      if P.air.last == 1 then
        _G.lowAirDisabled = false
        _G.needLowAirDialog, _G.lowAirDialogType, _G.lowAirDialogMessage = true, "info", "Air pressure restored. Re-enable the machine to continue."
      end
      P.air.last, P.air.t0 = 0, 0
    end
  end

  -------------------------------------------------------
  --  Spindle spin-up delay after M6 (armed by #495, seconds in #496)
  -------------------------------------------------------
  do
    local P = _G.__plc
    if P.pvGet(495) ~= 0 then
      if mc.mcSignalGetState(P.hSpindleOn) == 1 then
        if not P.spin.t0 then mc.mcCntlFeedHold(inst); P.spin.t0 = os.clock() end
        local need = tonumber(P.pvGet(496)) or 3
        if P.spin.t0 and (os.clock() - P.spin.t0) >= need then
          P.pvSet(495, 0); P.spin.t0 = nil; mc.mcCntlCycleStart(inst)
        end
      else
        P.spin.t0 = nil
      end
    else
      P.spin.t0 = nil
    end
  end

  -------------------------------------------------------
  --  Tool-present sensor → set T0 on removal when safe
  -------------------------------------------------------
  do
    local P = _G.__plc
    local present = (mc.mcSignalGetState(P.hToolSense) == 1)
    if P.tool.last17 < 0 then P.tool.last17 = present and 1 or 0 end
    if P.tool.last17 == 1 and (not present) then
      local inCycle = (mc.mcCntlIsInCycle(inst) == 1)
      local state   = mc.mcCntlGetState(inst)
      local m6      = (P.pvGet(499) ~= 0)
      if (not inCycle) and state == mc.MC_STATE_IDLE and not m6 then
        mc.mcToolSetCurrent(inst, 0)
      end
    end
    P.tool.last17 = present and 1 or 0
  end

  -------------------------------------------------------
  --  H-offset resync request (ScreenLoad applies G49/G43 via MDI)
  -------------------------------------------------------
  do
    local P = _G.__plc
    local curTool = mc.mcToolGetCurrent(inst) or 0
    local activeH = tonumber(P.pvGet(4120)) or 0
    local idle    = (mc.mcCntlGetState(inst) == mc.MC_STATE_IDLE)
    P.tool._t = P.tool._t or curTool
    P.tool._h = P.tool._h or activeH
    if idle and (curTool ~= P.tool._t or activeH ~= P.tool._h) then
      _G.requestHApply = (curTool > 0 and curTool < 90) and curTool or 0
      _G.ScreenLoadWatchesHApply = true
      P.tool._t = curTool; P.tool._h = activeH
    end
  end

  -------------------------------------------------------
  --  Startup tool prompt (first enable with T0 + tool present)
  -------------------------------------------------------
  do
    local P = _G.__plc
    local en = mc.mcSignalGetState(P.hEn)
    if en == 1 and P.enableSeen == 0 then
      P.enableSeen = 1
      local t0      = (mc.mcToolGetCurrent(inst) or 0) == 0
      local hasTool = (mc.mcSignalGetState(P.hToolSense) == 1)
      local sup     = (P.pvGet(498) == 1)   -- optional suppress PV
      if hasTool and t0 and not sup then
        _G.needToolPrompt        = true
        _G.toolPromptIsStartup   = true
        _G.toolPromptRequestTime = os.clock()
      end
    elseif en == 0 then
      P.enableSeen = 0
    end
  end

end
