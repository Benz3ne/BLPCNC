--[[
AuxFreezeTrace.txt  — single‑file patch (drop‑in)
Purpose:
  • Give you a KILL‑SWITCH to freeze AuxLib’s output writes (#4991)
  • Trace and log EVERY Lua write to OSIG_OUTPUT3..6 with caller file/line
  • (Optional) make AuxLib.State() report the REAL on/off using live OSIG readback
  • Zero project changes required; safe to remove at any time (restart restores originals)

How to use (any one of these):
  A) Click a button that runs:  SystemLib.RunProfileScript(inst, "AuxFreezeTrace.txt")
  B) From ScreenLoad.txt:      dofile("C:/Mach4Hobby/Profiles/BLP/Scripts/Dependencies/AuxFreezeTrace.txt")
  C) From MDI/console:         SystemLib.RunProfileScript(inst, "AuxFreezeTrace.txt")

Quick controls after load:
  • _G.AuxTrace.Freeze(true)      -- sets #4991=1 (AuxLib.Update will skip writes)
  • _G.AuxTrace.Freeze(false)     -- sets #4991=0 (unfreeze)
  • _G.AuxTrace.ToggleFreeze()
  • _G.AuxTrace.Status()          -- prints freeze + current OSIG states
  • _G.AuxTrace.EnableTrace(true/false)  -- turn caller tracing on/off

Where logs go:
  <MachDir>\Profiles\<Profile>\Reports\AuxFreezeTrace-YYYYMMDD-HHMMSS.log
  (Also mirrors key lines to the status bar via mcCntlSetLastError)
]]

local mc = mc
local wx = require("wx")

-- ===== paths + logging ========================================================
local function getProfileDir(inst)
  local mach = mc.mcCntlGetMachDir(inst)
  local ok, prof = pcall(mc.mcProfileGetName, inst)
  return (mach .. "\\Profiles\\" .. (ok and prof or "BLP")):gsub("/","\\")
end
local function nowUTC() local t=os.date("!*t"); return string.format("%04d%02d%02d-%02d%02d%02d",t.year,t.month,t.day,t.hour,t.min,t.sec) end
local function ensureDir(p) os.execute(string.format('if not exist "%s" mkdir "%s"', p, p)) end
local function newLogger(inst)
  local base = getProfileDir(inst) .. "\\Reports"; ensureDir(base)
  local file = base .. "\\AuxFreezeTrace-"..nowUTC()..".log"
  local fh = assert(io.open(file, "w"))
  local function line(fmt, ...)
    local msg = (select('#', ...) > 0) and string.format(fmt, ...) or tostring(fmt)
    fh:write(os.date("%H:%M:%S "), msg, "\n"); fh:flush()
    mc.mcCntlSetLastError(inst, msg)
  end
  return { file=file, log=line, close=function() fh:close() end }
end

-- ===== small helpers ==========================================================
local function sigHandle(inst, id) local ok,h=pcall(mc.mcSignalGetHandle,inst,id); return ok and h or nil end
local function sigState(h) local ok,s=pcall(mc.mcSignalGetState,h); return ok and (s==1 and 1 or 0) or -1 end
local function setPV(inst, n, v) pcall(mc.mcCntlSetPoundVar, inst, n, tonumber(v) or 0) end
local function getPV(inst, n) local ok,v=pcall(mc.mcCntlGetPoundVar, inst, n); return ok and tonumber(v) or 0 end

-- Our devices of interest
local MAP = {
  dust     = { osig = mc.OSIG_OUTPUT4, autoPV=400, tgtPV=404, label="DustCollect" },
  boot     = { osig = mc.OSIG_OUTPUT3, autoPV=402, tgtPV=403, label="DustBoot" },
  vacRear  = { osig = mc.OSIG_OUTPUT5, autoPV=401, tgtPV=411, label="VacRear" },
  vacFront = { osig = mc.OSIG_OUTPUT6, autoPV=401, tgtPV=412, label="VacFront" },
}

-- ===== install patch (deferred until libs are present) ========================
local inst = mc.mcGetInstance()
local L = newLogger(inst)
L.log("AuxFreezeTrace: loading… (profile dir: %s)", getProfileDir(inst))

_G.AuxTrace = _G.AuxTrace or {}
local AuxTrace = _G.AuxTrace
AuxTrace._traceEnabled = true

function AuxTrace.EnableTrace(on)
  AuxTrace._traceEnabled = (on ~= false)
  L.log("[TRACE] caller tracing %s", AuxTrace._traceEnabled and "ENABLED" or "DISABLED")
end

function AuxTrace.Freeze(on)
  setPV(inst, 4991, on and 1 or 0)
  L.log("[FREEZE] AuxLib.Update is %s (#4991=%d)", on and "FROZEN" or "LIVE", getPV(inst,4991))
end
function AuxTrace.ToggleFreeze() AuxTrace.Freeze(getPV(inst,4991)==0) end

function AuxTrace.Status()
  local en = sigState(sigHandle(inst, mc.OSIG_MACHINE_ENABLED))
  local lines = { string.format("STATUS: Enabled=%d Freeze=%d", en, getPV(inst,4991)) }
  for k,c in pairs(MAP) do
    local h = sigHandle(inst, c.osig)
    table.insert(lines, string.format("  %-8s OSIG=%d auto=%d tgt=%d", k, sigState(h), getPV(inst,c.autoPV), getPV(inst,c.tgtPV)))
  end
  for _,s in ipairs(lines) do L.log(s) end
end

-- ===== wrappers ===============================================================
local function installWrappers()
  local AuxLib = rawget(_G, "AuxLib")
  local SystemLib = rawget(_G, "SystemLib")
  if not AuxLib or not SystemLib then return false end

  -- 1) Freeze gate for AuxLib.Update
  if type(AuxLib.Update)=="function" and not AuxLib._AFT_wrapped then
    local ORIG = AuxLib.Update
    AuxLib.Update = function(i, ...)
      if getPV(i or inst, 4991) == 1 then
        -- Throttle message (every ~500ms)
        local t = os.clock(); AuxTrace._lastSkip = AuxTrace._lastSkip or 0
        if t - AuxTrace._lastSkip > 0.5 then
          L.log("[FREEZE] Skipping AuxLib.Update writes (kill‑switch active)")
          AuxTrace._lastSkip = t
        end
        return true
      end
      return ORIG(i or inst, ...)
    end
    AuxLib._AFT_wrapped = true
    L.log("Wrapped AuxLib.Update with #4991 freeze gate")
  end

  -- 2) Caller trace for SystemLib.SignalSetState (only OSIG 3..6)
  if type(SystemLib.SignalSetState)=="function" and not SystemLib._AFT_wrapped then
    local ORIG = SystemLib.SignalSetState
    SystemLib.SignalSetState = function(i, idOrHandle, want)
      local id = idOrHandle
      if type(idOrHandle) ~= "number" then
        -- assume handle
        local ok, n = pcall(mc.mcSignalGetState, idOrHandle) -- touch to validate
        id = idOrHandle -- keep as handle for ORIG; we’ll compute numeric id for log if possible
      end

      local numericId = nil
      -- Try to map handle to numeric signal id (best effort)
      if type(idOrHandle) ~= "number" then
        for _,sid in ipairs({mc.OSIG_OUTPUT3, mc.OSIG_OUTPUT4, mc.OSIG_OUTPUT5, mc.OSIG_OUTPUT6}) do
          if sigHandle(inst, sid) == idOrHandle then numericId = sid; break end
        end
      else
        numericId = idOrHandle
      end

      local interesting = numericId==mc.OSIG_OUTPUT3 or numericId==mc.OSIG_OUTPUT4 or numericId==mc.OSIG_OUTPUT5 or numericId==mc.OSIG_OUTPUT6
      if interesting and AuxTrace._traceEnabled then
        local where = debug.getinfo(2, "Sl") or {}
        L.log("[TRACE] write %s -> %s  @%s:%s", tostring(numericId or idOrHandle), tostring(want), tostring(where.short_src or "?"), tostring(where.currentline or "?"))
      end

      local rc = ORIG(i or inst, idOrHandle, want)

      if interesting and AuxTrace._traceEnabled then
        -- readback
        local h = (type(idOrHandle)=="number") and sigHandle(i or inst, idOrHandle) or idOrHandle
        local rb = h and sigState(h) or -1
        L.log("[TRACE]   readback=%d", rb)
      end
      return rc
    end
    SystemLib._AFT_wrapped = true
    L.log("Wrapped SystemLib.SignalSetState with caller tracing (OSIG 3..6)")
  end

  -- 3) Optional: make AuxLib.State reflect LIVE OSIG readback for our four devices
  if type(AuxLib.State)=="function" and not AuxLib._AFT_state_wrapped then
    local ORIG = AuxLib.State
    AuxLib.State = function(i, name, ...)
      local t = ORIG(i or inst, name, ...)
      if type(name)=="string" and MAP[name] and type(t)=="table" then
        local h = sigHandle(i or inst, MAP[name].osig)
        local live = (h and sigState(h) or 0)
        t.on = (live==1) and 1 or 0
        t.live = live
        t.note = "on reflects live OSIG"
      end
      return t
    end
    AuxLib._AFT_state_wrapped = true
    L.log("Patched AuxLib.State to prefer live OSIG for dust/boot/vac*")
  end

  return true
end

-- Try immediately, else retry a few times (libs may not yet be loaded)
local ok = installWrappers()
if not ok then
  L.log("Libraries not ready; will retry to install wrappers…")
  local tries, timer = 0, wx.wxTimer()
  timer:Start(250)
  timer:Connect(wx.wxEVT_TIMER, function()
    tries = tries + 1
    if installWrappers() or tries > 40 then
      timer:Stop(); timer:Disconnect(wx.wxEVT_TIMER)
      L.log(installWrappers() and "Wrappers installed on retry" or "Wrappers not installed (timeout)")
    end
  end)
end

-- Expose a tiny one‑shot to prove external reassertor in 1s
function AuxTrace.ProveExternal()
  L.log("[PROVE] Forcing OFF, freezing Aux, watching 1s for reassert…")
  AuxTrace.Freeze(true)
  for k,c in pairs(MAP) do local h=sigHandle(inst,c.osig); if h then mc.mcSignalSetState(h,0) end end
  wx.wxMilliSleep(1000)
  for k,c in pairs(MAP) do
    local h=sigHandle(inst,c.osig); local s=h and sigState(h) or -1
    L.log(string.format("[PROVE] %-8s after 1s: %d", k, s))
  end
  L.log("If any are 1 while frozen → controller/plugin is reasserting (not Lua)")
end

-- Print an initial status snapshot
AuxTrace.Status()
L.log("AuxFreezeTrace ready. Log file: %s", L.file)
